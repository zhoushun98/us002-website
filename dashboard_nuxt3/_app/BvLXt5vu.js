var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { cv as toDate, cw as addMonths, cx as addDays, cy as constructFrom, cz as normalizeDates, cA as differenceInCalendarDays, cB as differenceInMilliseconds, cC as millisecondsInMinute, cD as getRoundingMethod, cE as getDefaultOptions, cF as getDaysInMonth, cG as addSeconds, o as openBlock, e as createElementBlock, i as createBaseVNode, a9 as addStoreHooks, aa as defineStore, r as ref, ax as toDecimal, cH as useActiveMarketStore, aw as useMarketsStore, q as useUserStateStore, c3 as useConversionPathStore, U as URLService, _ as _export_sfc, cI as MarketsDropdown, b5 as CrossSVG, P as PAGE_CONTEXT, n as nextTick, y as resolveComponent, aH as withDirectives, bV as vModelText, bK as withKeys, g as createTextVNode, f as createVNode, aI as vShow, J as normalizeClass, bY as themeConstants, cJ as useThemeStore, bM as useLocalStorage, l as computed, bT as localStorageConstants, bN as storeToRefs, cK as watchEffect, bQ as watch, aA as constants$1, cL as RadioButton, cM as SettingsMenu, cN as LabeledSwitch, c as createBlock, w as withCtx, F as Fragment, a5 as renderList, a$ as normalizeStyle, h as createCommentVNode, ae as renderSlot, a4 as BtsLink, t as toDisplayString, A as AppIcon, bh as clickOutside, bi as resolveDirective, b3 as withModifiers, G as Transition, af as currenciesConstants, a as axiosInstance, aE as accountConstants, az as useSubAccountStore, aX as usePollingStore, ab as useErrorTracking, ac as shallowRef, aj as _, bP as timersConstants, bR as useCurrenciesStore, ag as numberFormatter, cj as _sfc_main$1g, b_ as Uuid, bx as validators, C as CONSTANTS, p as Checkbox, aN as useBalancesStore, B as BtsButton, cO as DownloadAppMenu, cP as HeaderVaspDisclaimer, cQ as ProSwitch, aG as AccountTypeIcon, cR as PlatformNotification, cS as AccountMenu, cT as BitstampProLogo, cU as BitstampDemoLogo, cV as UserMenu, cW as MenuToggleIcon, cX as useSubAccounts, ca as useFavoritesStore, aW as usePreferredCurrencyStore, c5 as buildKey, cY as conversionPathToPrice, a0 as Decimal, cZ as getNextFundingFormattedDate, ad as trackInteraction, V as AppTooltip, b as createSlots, ar as createStaticVNode, aB as marketConstants, c_ as mergeModels, c$ as useModel, d as unref, ch as isRef, d0 as DropdownSelector, ah as CurrencyIcon, d1 as TabSelector, u as useToastStore, I as constants$3, al as getDate, K as buildUrl, d2 as trackException, aO as ResponseCodes, bO as useUserPermissions, d3 as useWebsocketStore, d4 as useBranch, d5 as WSApi, d6 as onBeforeMount, s as setInterval, d7 as onBeforeUnmount, as as CURRENCIES, am as onMounted, d8 as useRouter, d9 as markRaw, D as resolveDynamicComponent, da as format, ay as constants$4, b$ as TransitionGroup, c1 as LocalStorageService, db as fromUnixTime, dc as getUnixTime, bo as lodashExports, dd as getTime, de as isIos, at as CopyDataIconButton, x as formatDate, df as reactive, dg as defineComponent, dh as useSlots, di as toRef, dj as onUnmounted, bm as normalizeProps, dk as guardReactiveProps, bj as mergeProps, dl as Teleport, dm as h, dn as render$7, dp as useAttrs, dq as toValue, dr as getMonth, ds as isAfter, dt as isValid, du as onBeforeUpdate, dv as startOfYear, dw as startOfWeek, dx as getCurrentScope, dy as onScopeDispose, dz as parse, dA as getWeek, dB as getISOWeek, dC as isDate, dD as RadioGroup, dE as parseNumberSafely, aF as Dropdown, aT as ThemeBasedImage, $ as ENDPOINTS_PRELOADED_DATA, dF as isAndroid, a8 as PageRouteSymbol } from "./BEpVD-aq.js";
import { a as addMinutes, m as makeElementsArray, c as createElementIfNotDefined, S as Swiper, b as SwiperSlide, F, M as MarginRatioStatusIndicator, D as DraggableSettings, E as ExpandToggler } from "./CroXI9Sg.js";
import { u as useTradeviewTickersStore, a as useTradesStore, b as useOrderbook100Store, c as useField, d as useForm, R as REVERSAL_DISCLAIMER, e as defineRule, w as wrapper, f as useFeatureStatusStore, g as featureStatusConstants, s as subDays, h as subMonths, i as candlesApi, j as asyncThrottle, k as sub } from "./Cy77iO80.js";
import { d as deepFreeze } from "./BwaZ2ET2.js";
import { u as useVisibilityStore } from "./ljMJl-cz.js";
import { B as BtsForm } from "./D4HcQE78.js";
import { G as GeneralNotification } from "./qPMKhu5A.js";
import { S as SubAccountTransferForm } from "./DE9JBhJI.js";
import { S as SCREEN_SIZES, T as ToastsAndLiquidationAlerts, u as useNotificationStore } from "./G1TgZVbr.js";
import { u as useFeeScheduleStore } from "./glEryrjR.js";
import { P as PastPerformanceDisclaimer } from "./M-ITQhO8.js";
import { A as AccordionGroup, a as AccordionItem } from "./DEiKZxP9.js";
import { c as constants$2 } from "./Ptg4BVLI.js";
import { u as useOpenPositionsStore, p as positionsApi, M as MarginSettingTag, O as OpenOrdersTriggerField } from "./aBqvei-l.js";
import { u as useOrdersStore, a as useOrderFormatter } from "./CmPxTZ2S.js";
import { b as branchEvents } from "./BPUc829R.js";
import { s as subHours, a as addHours } from "./DgnSKGeG.js";
import { t as tradeHistoryV2Api } from "./Bn75D-61.js";
import { S as SpinnerInButton } from "./DZeX0Rdc.js";
import { P as Pagination } from "./C-G9XUT5.js";
import { p as positionSettlementHistoryApi } from "./gNhDlNDw.js";
import { u as useSmallBalancesStore } from "./CKbNCCPq.js";
import { A as ActionMenu } from "./CI4CM-Pf.js";
import { f as formatISO } from "./C0APx8OL.js";
import { a as api } from "./BWYKm-Na.js";
import "./CZjLos_N.js";
import "./CpoBxDnQ.js";
import "./fJkJxxwc.js";
import "./C4uvih28.js";
import "./BMFhygwF.js";
function add(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const dateWithMonths = months || years ? addMonths(_date, months + years * 12) : _date;
  const dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1e3;
  return constructFrom(date, +dateWithDays + msToAdd);
}
function addQuarters(date, amount, options) {
  return addMonths(date, amount * 3, options);
}
function addWeeks(date, amount, options) {
  return addDays(date, amount * 7, options);
}
function addYears(date, amount, options) {
  return addMonths(date, amount * 12, options);
}
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}
function getQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}
function differenceInCalendarYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() - earlierDate_.getFullYear();
}
function differenceInDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const sign = compareLocalAsc(laterDate_, earlierDate_);
  const difference = Math.abs(
    differenceInCalendarDays(laterDate_, earlierDate_)
  );
  laterDate_.setDate(laterDate_.getDate() - sign * difference);
  const isLastDayNotFull = Number(
    compareLocalAsc(laterDate_, earlierDate_) === -sign
  );
  const result = sign * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function compareLocalAsc(laterDate, earlierDate) {
  const diff = laterDate.getFullYear() - earlierDate.getFullYear() || laterDate.getMonth() - earlierDate.getMonth() || laterDate.getDate() - earlierDate.getDate() || laterDate.getHours() - earlierDate.getHours() || laterDate.getMinutes() - earlierDate.getMinutes() || laterDate.getSeconds() - earlierDate.getSeconds() || laterDate.getMilliseconds() - earlierDate.getMilliseconds();
  if (diff < 0) return -1;
  if (diff > 0) return 1;
  return diff;
}
function differenceInMinutes(dateLeft, dateRight, options) {
  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff);
}
function endOfDay(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function differenceInYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(laterDate_, earlierDate_);
  const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));
  laterDate_.setFullYear(1584);
  earlierDate_.setFullYear(1584);
  const partial = compareAsc(laterDate_, earlierDate_) === -sign;
  const result = sign * (diff - +partial);
  return result === 0 ? 0 : result;
}
function normalizeInterval(context, interval) {
  const [start, end] = normalizeDates(context, interval.start, interval.end);
  return { start, end };
}
function eachDayOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +start : +end;
  const date = reversed ? end : start;
  date.setHours(0, 0, 0, 0);
  let step = 1;
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date.setDate(date.getDate() + step);
    date.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}
function startOfQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3;
  _date.setMonth(month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function eachQuarterOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +startOfQuarter(start) : +startOfQuarter(end);
  let date = reversed ? startOfQuarter(end) : startOfQuarter(start);
  let step = 1;
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date = addQuarters(date, step);
  }
  return reversed ? dates.reverse() : dates;
}
function startOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfWeek(date, options) {
  var _a2, _b, _c, _d;
  const defaultOptions = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3 + 3;
  _date.setMonth(month, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function getDay(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getDay();
}
function getHours(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getHours();
}
function getMinutes(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getMinutes();
}
function getSeconds(date) {
  return toDate(date).getSeconds();
}
function getYear(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getFullYear();
}
function isBefore(date, dateToCompare) {
  return +toDate(date) < +toDate(dateToCompare);
}
function isEqual(leftDate, rightDate) {
  return +toDate(leftDate) === +toDate(rightDate);
}
function isSameQuarter(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return +startOfQuarter(dateLeft_) === +startOfQuarter(dateRight_);
}
function setMonth(date, month, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const midMonth = constructFrom(date, 0);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}
function set(date, values, options) {
  let _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(+_date)) return constructFrom(date, NaN);
  if (values.year != null) _date.setFullYear(values.year);
  if (values.month != null) _date = setMonth(_date, values.month);
  if (values.date != null) _date.setDate(values.date);
  if (values.hours != null) _date.setHours(values.hours);
  if (values.minutes != null) _date.setMinutes(values.minutes);
  if (values.seconds != null) _date.setSeconds(values.seconds);
  if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);
  return _date;
}
function setHours(date, hours, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setHours(hours);
  return _date;
}
function setMilliseconds(date, milliseconds, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setMilliseconds(milliseconds);
  return _date;
}
function setMinutes(date, minutes, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  date_.setMinutes(minutes);
  return date_;
}
function setSeconds(date, seconds, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setSeconds(seconds);
  return _date;
}
function setYear(date, year, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(+date_)) return constructFrom(date, NaN);
  date_.setFullYear(year);
  return date_;
}
function subMinutes(date, amount, options) {
  return addMinutes(date, -amount, options);
}
function subSeconds(date, amount, options) {
  return addSeconds(date, -amount);
}
function subWeeks(date, amount, options) {
  return addWeeks(date, -amount, options);
}
function subYears(date, amount, options) {
  return addYears(date, -amount, options);
}
function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === "string" && swiper.isElement) {
      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === "string") res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res) return el;
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (subEl) {
        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
        }
      }
    });
  }
  function update() {
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit("navigationPrev");
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit("navigationNext");
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(" "));
      }
    };
    nextEl.forEach((el) => initButton(el, "next"));
    prevEl.forEach((el) => initButton(el, "prev"));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
    };
    nextEl.forEach((el) => destroyButton(el, "next"));
    prevEl.forEach((el) => destroyButton(el, "prev"));
  }
  on("init", () => {
    if (swiper.params.navigation.enabled === false) {
      disable();
    } else {
      init();
      update();
    }
  });
  on("toEdge fromEdge lock unlock", () => {
    update();
  });
  on("destroy", () => {
    destroy();
  });
  on("enable disable", () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (swiper.enabled) {
      update();
      return;
    }
    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
  });
  on("click", (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper.isElement && !targetIsButton) {
      const path = e.path || e.composedPath && e.composedPath();
      if (path) {
        targetIsButton = path.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit("navigationShow");
      } else {
        emit("navigationHide");
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
    init();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update,
    init,
    destroy
  });
}
const _hoisted_1$19 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 12.1 12.1"
};
function render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$19, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      fill: "currentColor",
      d: "M11.76 10.34 9.22 7.8A5 5 0 1 0 7.8 9.22l2.54 2.54zM5.05 8.05a3 3 0 1 1 3-3 3 3 0 0 1-3 3"
    }, null, -1)
  ]));
}
const SearchSVG = { render: render$6 };
const useTradeviewTriggerValueStore = addStoreHooks(
  defineStore("tradeviewTriggerValueStore", () => {
    const amountSetByTrigger = ref(null);
    const priceSetByTrigger = ref(null);
    function setAmountSetByTrigger(amount) {
      amountSetByTrigger.value = toDecimal(amount);
    }
    function setPriceSetByTrigger(price) {
      priceSetByTrigger.value = toDecimal(price);
    }
    return {
      amountSetByTrigger,
      priceSetByTrigger,
      setAmountSetByTrigger,
      setPriceSetByTrigger
    };
  })
);
function useSetActiveMarket() {
  const activeMarketStore = useActiveMarketStore();
  const marketsStore = useMarketsStore();
  const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
  const userStateStore = useUserStateStore();
  const conversionPathStore = useConversionPathStore();
  function setActiveMarket(marketKey, skipPushState = false) {
    if (activeMarketStore.activeMarket.key === marketKey || !marketsStore.getVisibleMarket(marketKey)) {
      return;
    }
    if (!skipPushState) {
      const path = URLService.getPageUrl("proTrade", { market: marketKey });
      window.history.pushState({ path }, "", path);
    }
    activeMarketStore.setActiveMarket(marketKey);
    tradeviewTriggerValueStore.setPriceSetByTrigger(null);
    tradeviewTriggerValueStore.setAmountSetByTrigger(null);
    if (userStateStore.isLoggedIn) {
      conversionPathStore.loadUsdConversionPath(activeMarketStore.activeMarket.counter);
    }
  }
  return {
    setActiveMarket
  };
}
const _sfc_main$1f = {
  name: "TradeviewMarketSelector",
  components: {
    MarketsDropdown,
    SearchSVG,
    CrossSVG
  },
  props: {
    mobile: {
      type: Boolean,
      default: false,
      required: false
    },
    isOpen: {
      type: Boolean,
      default: false,
      required: false
    }
  },
  emits: ["close"],
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      userStateStore: useUserStateStore()
    };
  },
  data() {
    return {
      searchTerm: "",
      searchCandidate: null,
      areDerivativesEnabled: PAGE_CONTEXT.derivativesEnabled ?? false
    };
  },
  watch: {
    isOpen(isNowOpen) {
      if (isNowOpen) {
        nextTick(() => {
          var _a2;
          (_a2 = this.$refs.search) == null ? void 0 : _a2.focus();
        });
      }
    }
  },
  methods: {
    /**
     * @param {module:markets.Market} market
     * @return {string}
     */
    buildTradeLinkFn(market) {
      return URLService.getPageUrl("proTrade", { market: market.key });
    },
    onChangedSelectedMarket(newMarket) {
      this.clearSearch();
      if (newMarket !== this.activeMarketStore.activeMarket.key) {
        this.setActiveMarket(newMarket);
      }
      this.closeDropdown();
    },
    closeDropdown() {
      this.$emit("close");
    },
    clearSearch() {
      this.searchTerm = "";
    },
    updateSearchCandidate(candidatePairKey) {
      this.searchCandidate = candidatePairKey;
    },
    onEnterKeyUp() {
      if (!this.searchCandidate || !this.searchTerm) {
        return;
      }
      this.onChangedSelectedMarket(this.searchCandidate);
      this.clearSearch();
    },
    onCompositionUpdate() {
      setTimeout(() => {
        var _a2;
        this.searchTerm = ((_a2 = this.$refs.search) == null ? void 0 : _a2.value) ?? "";
      }, 100);
    }
  }
};
const _hoisted_1$18 = { class: "market-selector__search-wrapper" };
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SearchSVG = resolveComponent("SearchSVG");
  const _component_CrossSVG = resolveComponent("CrossSVG");
  const _component_MarketsDropdown = resolveComponent("MarketsDropdown");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["market-selector", {
      "market-selector--mobile": $props.mobile,
      "market-selector--with-tabs": $setup.userStateStore.isLoggedIn || $data.areDerivativesEnabled
    }])
  }, [
    createBaseVNode("div", _hoisted_1$18, [
      withDirectives(createBaseVNode("input", {
        id: "header-market-selector-search-input",
        ref: "search",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.searchTerm = $event),
        class: "market-selector__search",
        placeholder: "Search",
        title: "Press Enter to switch to highlighted market",
        onKeyup: [
          _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("close"), ["esc"])),
          _cache[2] || (_cache[2] = withKeys((...args) => $options.onEnterKeyUp && $options.onEnterKeyUp(...args), ["enter"]))
        ],
        onCompositionupdate: _cache[3] || (_cache[3] = (...args) => $options.onCompositionUpdate && $options.onCompositionUpdate(...args))
      }, null, 544), [
        [vModelText, $data.searchTerm]
      ]),
      _cache[4] || (_cache[4] = createTextVNode()),
      createVNode(_component_SearchSVG, { class: "market-selector__search-icon" }),
      _cache[5] || (_cache[5] = createTextVNode()),
      withDirectives(createVNode(_component_CrossSVG, {
        class: "market-selector__delete-icon",
        onClick: $options.clearSearch
      }, null, 8, ["onClick"]), [
        [vShow, $data.searchTerm]
      ])
    ]),
    _cache[6] || (_cache[6] = createTextVNode()),
    createVNode(_component_MarketsDropdown, {
      "search-term": $data.searchTerm,
      "has-close-button": $props.mobile,
      "is-open": $props.isOpen,
      "tickers-store-instance": $setup.tradeviewTickersStore,
      "build-trade-link-fn": $options.buildTradeLinkFn,
      onChangeActiveMarket: $options.onChangedSelectedMarket,
      onCloseDropdown: $options.closeDropdown,
      onUpdateSearchCandidate: $options.updateSearchCandidate
    }, null, 8, ["search-term", "has-close-button", "is-open", "tickers-store-instance", "build-trade-link-fn", "onChangeActiveMarket", "onCloseDropdown", "onUpdateSearchCandidate"])
  ], 2);
}
const TradeviewMarketSelector = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$Z], ["__scopeId", "data-v-55bb3dd2"]]);
const _hoisted_1$17 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xml:space": "preserve",
  viewBox: "0 0 12 12"
};
function render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$17, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      fill: "currentColor",
      d: "M6 9.5.3 3.9l1.4-1.4L6 6.7l4.3-4.2 1.4 1.4z"
    }, null, -1)
  ]));
}
const ArrowDownSVG = { render: render$5 };
const TRADEVIEW_NAME = "Tradeview";
const constants = {
  TRADEVIEW_NAME,
  ORDERBOOK: {
    SIDES: {
      ASKS: "asks",
      BIDS: "bids"
    },
    LAYOUT: {
      STACKED: "stacked",
      ASKS: "asks",
      BIDS: "bids"
    },
    SETTINGS: {
      TOOLTIP_ENABLED: "tooltip_enabled",
      TOOLTIPS_LINKED: "tooltips_linked"
    }
  },
  UNIT_GROUPS: [
    [1e9, "G"],
    [1e6, "M"],
    [1e3, "k"]
  ],
  LOCALE: "en-US",
  RESPONSE_CODES: {
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    REQUIRED_2FA: "required_2fa"
  },
  TIMERS: {
    POLLING_ORDERS: {
      TIME: 1e3 * 60,
      ID: "polling_orders"
    },
    // If this polling time is set too high, there might be issue on "wake-up from sleep" refreshes
    POLLING_ORDERBOOK: {
      TIME: 1e3 * 60 * 5,
      ID: "polling_orderbook"
    },
    POLLING_USER_BALANCE: {
      TIME: 1e3 * 60 * 5,
      ID: "polling_user_balance"
    },
    POLLING_USER_TRADES: {
      TIME: 1e3 * 60 * 5,
      ID: "polling_user_trades"
    },
    POLLING_TICKERS: {
      TIME: 1e3 * 60 * 15,
      ID: "polling_tickers"
    },
    POLLING_ORDER_HISTORY: {
      TIME: 1e3 * 60 * 15,
      ID: "polling_order_history"
    },
    POLLING_MARKETS: {
      TIME: 1e3 * 60 * 5,
      ID: "polling_markets"
    },
    SOCKET_RECONNECTION: {
      TIME: 1e4,
      ID: "web_sockets_reconnect"
    },
    TRADEBOOK: {
      ANIMATION: 300,
      MIN_THROTTLE: 500,
      MAX_THROTTLE: 3e3
    },
    ORDERBOOK: {
      ANIMATION: 300,
      MIN_THROTTLE: 700,
      MIN_THROTTLE_FAST: 100,
      MAX_THROTTLE: 5e3
    },
    PRICECHART: {
      MIN_THROTTLE: 500,
      MAX_THROTTLE: 3e3
    },
    OPEN_ORDERS: {
      ANIMATION: 100
    },
    DEPTH_CHART: {
      MIN_THROTTLE: 2e3,
      MAX_THROTTLE: 5e3,
      PRICE_ANIMATION_DURATION: 400
    },
    TICKERS: {
      SUBSCRIBE_TO_WS_IF_MENU_OPEN_DELAY: 10 * 1e3,
      // milliseconds
      UNSUBSCRIBE_FROM_WS_IF_MENU_CLOSED_FOR: 5 * 60 * 1e3
      // milliseconds
    },
    TRADES: {
      DEBOUNCE: 500,
      THROTTLE: 500
    }
  },
  NOTIFICATIONS: {
    MAX_ORDER_FILLED_NOTIFICATIONS_DISPLAYED: 4,
    MAX_ORDER_REMOVED_NOTIFICATIONS_DISPLAYED: 4
  },
  LOCAL_STORAGE: {
    PRICE_CHART: "tradingView.layout",
    APPLICATION: "application",
    THEME: "theme",
    TV_COLOR_SCHEME: "bts-tv-color-scheme",
    TRADING_VIEW_INTERVAL: "bts-tv-interval"
  },
  DEPTH_CHART_SIZE_LIMIT: 500,
  TRADING_VIEW: {
    CHART_TYPES: {
      STYLE_BARS: 0,
      STYLE_CANDLES: 1,
      STYLE_LINE: 2,
      STYLE_AREA: 3,
      STYLE_HEIKEN_ASHI: 8,
      STYLE_HOLLOW_CANDLES: 9,
      STYLE_BASELINE: 10
    }
  },
  FPSThrottlingLimit: 30,
  /* As defined in Bitstamp repo: apps/tradeview/service.py:fetch_price_history_last_entries */
  PRICE_HISTORY_MAX_RESULTS: 5e3,
  FORCE_RELOAD: {
    STORAGE_KEY: "lastForceReloadTime",
    MIN_MS_BEFORE_NEXT_RELOAD: 600 * 1e3
  },
  FILTERS: {
    ALL: "_ALL",
    FAVORITE: "_FAV"
  },
  CURRENCIES: {
    CURRENCY_XRP: "XRP",
    CURRENCY_USD: "USD"
  },
  RELOAD_MAX_DELAY_SECONDS: 20 * 60,
  // 20 minutes
  MARKET_ORDER_FORM_INPUT: {
    AMOUNT: "amount",
    TOTAL: "total"
  },
  SETTING_KEYS: {
    POST_ONLY_ON_BY_DEFAULT: "postOnlyOnByDefault",
    SHOW_FILL_NOTIFICATIONS: "showFillNotifications"
  },
  // Main account tag
  MAIN_ACCOUNT_ID: "main",
  COLOR_SCHEMES: {
    CLASSIC: "classic",
    FUNKY: "funky-monkey"
  },
  TRADEVIEW_HEADER_DROPDOWNS: {
    MARKET_SELECTOR: 1,
    APP_DOWNLOAD: 2,
    USER: 3,
    SUB_ACCOUNT: 4,
    SETTINGS: 5
  },
  MARKET_FILTER: {
    CURRENT_MARKET: "current",
    ALL: "all"
  }
};
deepFreeze(constants);
const theme$1 = {
  CLASS: themeConstants.LIGHT,
  CLASS_TRADING_VIEW: "theme-light",
  COLORS: {
    BACKGROUND: "#fff",
    GRID: "#eaeaea",
    SCALE_LINE: "#d7d7d7",
    ORDER_LINE_BASE: "#898989",
    TREND_DOWN: "#ee5236"
  },
  COLOR_SCHEMES: {
    [constants.COLOR_SCHEMES.FUNKY]: {},
    [constants.COLOR_SCHEMES.CLASSIC]: {}
  }
};
const theme = {
  CLASS: themeConstants.DARK,
  CLASS_TRADING_VIEW: "theme-dark",
  COLORS: {},
  COLOR_SCHEMES: {
    [constants.COLOR_SCHEMES.FUNKY]: {
      TREND_DOWN: "#EE5236",
      TREND_UP: "#02CA7E",
      ORDER_LINE_BUY_TEXT_COLOR: "#000000"
    },
    [constants.COLOR_SCHEMES.CLASSIC]: {
      TREND_DOWN: "#DF4249",
      TREND_UP: "#00A159"
    }
  }
};
const DEFAULT_COLORS = {
  BACKGROUND: "#14171A",
  GRID: "#1C1F21",
  SCALE_LINE: "#2D2F33",
  SCALE_TEXT: "#585b62",
  CROSSHAIR: "#63666d",
  TREND_DOWN: "#df4249",
  TREND_UP: "#00a159",
  TRADINGVIEW_LINE: "#217af2",
  ORDER_LINE_BASE: "#4a4c51",
  ORDER_LINE_BORDER: "#000000",
  TEXT_BRIGHT: "#ffffff",
  ORDER_LINE_BUY_TEXT_COLOR: "#FFFFFF"
};
const mergeThemeWithDefaults = (theme2, colorScheme) => {
  return {
    ...theme2,
    COLORS: {
      ...DEFAULT_COLORS,
      ...theme2.COLORS,
      ...theme2.COLOR_SCHEMES[colorScheme]
    }
  };
};
const loadThemes = (colorScheme = constants.COLOR_SCHEMES.CLASSIC) => {
  return {
    [themeConstants.DARK]: mergeThemeWithDefaults(theme, colorScheme),
    [themeConstants.LIGHT]: mergeThemeWithDefaults(theme$1, colorScheme)
  };
};
const storeName$g = "tradeviewThemeStore";
const useTradeviewThemeStore = addStoreHooks(
  defineStore(storeName$g, () => {
    const themeStore = useThemeStore({ caller: storeName$g });
    const activeColorScheme = useLocalStorage(constants.LOCAL_STORAGE.TV_COLOR_SCHEME, constants.COLOR_SCHEMES.CLASSIC);
    const tradeviewThemeSettings = ref(Object.freeze(loadThemes(activeColorScheme.value)));
    const activeTradeviewThemeSettings = computed(() => {
      return tradeviewThemeSettings.value[themeStore.activeTheme] ?? tradeviewThemeSettings.value[themeConstants.DARK];
    });
    function setColorScheme(newColorScheme) {
      activeColorScheme.value = newColorScheme;
      tradeviewThemeSettings.value = Object.freeze(loadThemes(newColorScheme));
      const pageRoot = document.getElementsByTagName("html")[0];
      pageRoot.classList.remove(constants.COLOR_SCHEMES.FUNKY, constants.COLOR_SCHEMES.CLASSIC);
      pageRoot.classList.add(newColorScheme);
    }
    return {
      activeColorScheme,
      activeTradeviewThemeSettings,
      setColorScheme
    };
  })
);
const openPositionColumnDefinitions = Object.freeze([
  {
    title: "Market",
    slotKey: "market",
    stickyLeft: true,
    configurable: false
  },
  {
    title: "Amount",
    slotKey: "amount",
    tooltip: "The total size of the position.",
    textAlignRight: true
  },
  {
    title: "Value",
    slotKey: "value",
    tooltip: "Quote currency value of position based on mark price.",
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "",
    // Defined in OpenPositions.vue
    slotKey: "strikePrice",
    settingsTitle: "Strike price",
    tooltip: "",
    // Defined in OpenPositions.vue
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "Mark price",
    slotKey: "markPrice",
    tooltip: "Price used for PNL and margin calculations. It can differ from the last price traded to avoid price manipulation",
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "",
    // Defined in OpenPositions.vue
    slotKey: "entryPrice",
    settingsTitle: "Entry price",
    tooltip: "",
    // Defined in OpenPositions.vue
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "ELP",
    settingsTitle: "Est. Liquidation Price",
    slotKey: "estimatedLiquidationPrice",
    tooltip: "Estimated mark price at which your position will be incrementally liquidated.",
    textAlignRight: true
  },
  {
    title: "RSPnL",
    slotKey: "rsPnl",
    tooltip: "The profits and losses that have been realized since the last settlement by closing a futures position. Futures RSPnL is included in your account equity and can be used as trading margin, but is only available for withdrawal after settlement. At settlement, futures RSPnL will be transferred to your cash balance and reset to 0.",
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "USPnL",
    slotKey: "usPnl",
    tooltip: "The profits and losses from open positions since the last settlement. USPnL is included in your account equity and can be used as trading margin, but is not available for withdrawal. At settlement, futures USPnL will be transferred to your cash balance and reset to 0.",
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "Settled PnL",
    slotKey: "settledPnl",
    tooltip: "Already settled P&L from the time the position was opened to the last settlement period.",
    textAlignRight: true,
    optional: true
  },
  {
    title: "In Settlement PnL",
    slotKey: "inSettlementPnl",
    tooltip: "The profits and losses of open and closed positions that are to be settled within the currently running periodic settlement.",
    textAlignRight: true,
    optional: true
  },
  {
    title: "PnL",
    slotKey: "pnl",
    tooltip: "Total PnL represents the sum of all unsettled and settled profits and losses since position inception.",
    textAlignRight: true,
    onByDefault: true
  },
  // Collateral is relevant for isolated positions only
  {
    title: "Collateral",
    slotKey: "collateral",
    textAlignRight: true,
    optional: true,
    onByDefault: true
  },
  {
    title: "IMr",
    slotKey: "imr",
    tooltip: "The initial margin ratio reserved for your open orders and open positions. If the value rises above 100%, open orders that would increase your positions gets cancelled and you are only able to place orders that reduce your positions.",
    textAlignRight: true
  },
  {
    title: "MMr",
    slotKey: "mmr",
    tooltip: "The maintenance margin ratio reserved for your open orders and open positions. If the value rises above 100%, your positions will get incrementally liquidated until the MM ratio value is again 100% or lower.",
    textAlignRight: true
  },
  {
    title: "IM",
    settingsTitle: "Initial margin",
    slotKey: "im",
    tooltip: "Initial margin",
    textAlignRight: true,
    optional: true
  },
  {
    title: "MM",
    settingsTitle: "Maintenance margin",
    slotKey: "mm",
    tooltip: "Maintenance margin",
    textAlignRight: true,
    optional: true
  },
  {
    title: "Imp. lev.",
    settingsTitle: "Implied leverage",
    slotKey: "impliedLeverage",
    tooltip: "Implied leverage",
    textAlignRight: true,
    optional: true
  },
  // Equity is relevant for isolated positions only
  {
    title: "Equity",
    slotKey: "equity",
    textAlignRight: true,
    optional: true
  },
  {
    title: "ID",
    settingsTitle: "Position ID",
    slotKey: "id",
    optional: true
  },
  {
    slotKey: "actions",
    textAlignRight: true,
    stickyRight: true,
    configurable: false
  }
]);
const useTradeviewSettingsStore = addStoreHooks(
  defineStore("tradeviewSettingsStore", () => {
    const areFillNotificationsEnabled = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_SETTINGS_FILL_NOTIFICATIONS,
      true
    );
    const areOrderDeletedNotificationsEnabled = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_SETTINGS_ORDER_DELETED_NOTIFICATIONS,
      true
    );
    const isPostOnlyOnAsDefaultEnabled = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_SETTINGS_POST_ONLY_BY_DEFAULT,
      false
    );
    const marketOrderFormInputType = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_MARKET_ORDER_FORM_INPUT_TYPE,
      constants.MARKET_ORDER_FORM_INPUT.AMOUNT,
      {
        listenToStorageChanges: false
      }
    );
    const areOnChartPositionsEnabled = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_SHOW_OPEN_POSITIONS_ON_CHART,
      true,
      {
        listenToStorageChanges: false
      }
    );
    const areOnChartOrdersEnabled = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_SHOW_OPEN_ORDERS_ON_CHART,
      true,
      {
        listenToStorageChanges: false
      }
    );
    const isFullScreenMode = ref(false);
    const areUserOrdersInAllPairMode = ref(true);
    const areSmallBalancesVisible = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_SHOW_SMALL_BALANCES,
      true,
      {
        listenToStorageChanges: false
      }
    );
    const isHorizontalLineOnPlusClickEnabled = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_IS_HORIZONTAL_LINE_ON_PLUS_CLICK_ENABLED,
      false
    );
    const rememberLastTif = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_REMEMBER_LAST_TIF,
      false
    );
    const openPositionColumnSettings = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TV_OPEN_POSITION_COLUMNS,
      _getDefaultOpenPositionColumnSettingsState()
    );
    const positionHistoryOptionalColumnVisibility = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_POSITION_HISTORY_OPTIONAL_COLUMNS,
      {}
    );
    function setAreFillNotificationsEnabledSetting(value) {
      areFillNotificationsEnabled.value = value;
    }
    function setAreOrderDeletedNotificationsEnabledSetting(areEnabled) {
      areOrderDeletedNotificationsEnabled.value = areEnabled;
    }
    function setIsPostOnlyOnByDefaultEnabledSetting(value) {
      isPostOnlyOnAsDefaultEnabled.value = value;
    }
    function setMarketOrderFormInputType(value) {
      marketOrderFormInputType.value = value;
    }
    function setAreOnChartPositionsEnabled(value) {
      areOnChartPositionsEnabled.value = value;
    }
    function setAreOnChartOrdersEnabled(value) {
      areOnChartOrdersEnabled.value = value;
    }
    function setIsFullScreenMode(value) {
      isFullScreenMode.value = value;
    }
    function setAreUserOrdersInAllPairMode(value) {
      areUserOrdersInAllPairMode.value = value;
    }
    function setAreSmallBalancesVisible(areVisible) {
      areSmallBalancesVisible.value = areVisible;
    }
    function setIsRememberLastTifSettingEnabled(isEnabled) {
      rememberLastTif.value = isEnabled;
    }
    function setIsHorizontalLineOnPlusClickedEnabled(areVisible) {
      isHorizontalLineOnPlusClickEnabled.value = areVisible;
    }
    function setOpenPositionColumnSettings(settings) {
      openPositionColumnSettings.value = settings;
    }
    function _getDefaultOpenPositionColumnSettingsState() {
      return openPositionColumnDefinitions.filter(({ configurable }) => configurable !== false).map(
        ({
          slotKey,
          optional,
          onByDefault
        }, index2) => ({
          key: slotKey,
          active: onByDefault || !optional,
          order: index2,
          optional
        })
      );
    }
    function resetOpenPositionColumnSettings() {
      openPositionColumnSettings.value = _getDefaultOpenPositionColumnSettingsState();
    }
    function togglePositionHistoryOptionalColumnVisibility(columnId) {
      positionHistoryOptionalColumnVisibility.value = {
        ...positionHistoryOptionalColumnVisibility.value,
        [columnId]: !(positionHistoryOptionalColumnVisibility.value[columnId] ?? false)
      };
    }
    return {
      areFillNotificationsEnabled,
      areOrderDeletedNotificationsEnabled,
      isPostOnlyOnAsDefaultEnabled,
      marketOrderFormInputType,
      areOnChartPositionsEnabled,
      areOnChartOrdersEnabled,
      isFullScreenMode,
      areUserOrdersInAllPairMode,
      areSmallBalancesVisible,
      rememberLastTif,
      isHorizontalLineOnPlusClickEnabled,
      openPositionColumnSettings,
      positionHistoryOptionalColumnVisibility,
      setAreFillNotificationsEnabledSetting,
      setAreOrderDeletedNotificationsEnabledSetting,
      setIsPostOnlyOnByDefaultEnabledSetting,
      setMarketOrderFormInputType,
      setAreOnChartPositionsEnabled,
      setAreOnChartOrdersEnabled,
      setIsFullScreenMode,
      setAreUserOrdersInAllPairMode,
      setAreSmallBalancesVisible,
      setIsRememberLastTifSettingEnabled,
      setIsHorizontalLineOnPlusClickedEnabled,
      togglePositionHistoryOptionalColumnVisibility,
      setOpenPositionColumnSettings,
      resetOpenPositionColumnSettings
    };
  })
);
new AudioContext();
const sounds = /* @__PURE__ */ new Map();
function bufferSounds(files) {
  return new Promise((resolve) => {
    files.forEach((f) => {
      const audio = new Audio(f);
      sounds.set(f, audio);
    });
    resolve();
  });
}
function playSound(sound) {
  const s = sounds.get(sound);
  if (!s) {
    return;
  }
  s.play().then(() => {
  }).catch(() => {
  });
}
const PublicBearBeep = "" + new URL("bear.CMwuHbtK.mp3", import.meta.url).href;
const PublicBullBeep = "" + new URL("bull.DwmKCkDA.mp3", import.meta.url).href;
const UserTradeSoundBuy = "" + new URL("tv-private-trade-1-buy.D4Dh89XG.mp3", import.meta.url).href;
const UserTradeSoundSell = "" + new URL("tv-private-trade-1-sell.B2ctEvZm.mp3", import.meta.url).href;
function usePublicTradeSounds(tradesStore) {
  const isPublicTradeSoundEnabled = useLocalStorage(
    localStorageConstants.LOCAL_STORAGE.TRADEVIEW_PUBLIC_TRADE_SOUNDS,
    false,
    { listenToStorageChanges: false }
  );
  let prevIsPublicTradeSoundEnabled = isPublicTradeSoundEnabled.value;
  const arePublicSoundsLoaded = ref(false);
  const arePublicSoundsLoading = ref(false);
  function toggleIsPublicTradeSoundEnabled() {
    isPublicTradeSoundEnabled.value = !isPublicTradeSoundEnabled.value;
  }
  function playPublicTradeSound(trades) {
    if (!isPublicTradeSoundEnabled.value || trades.length === 0 || !arePublicSoundsLoaded.value) {
      return;
    }
    playSound(trades[0].takerSide === constants$1.ORDER_SIDE.BUY ? PublicBullBeep : PublicBearBeep);
  }
  watchEffect(async () => {
    if (isPublicTradeSoundEnabled.value && !arePublicSoundsLoading.value && !arePublicSoundsLoaded.value) {
      arePublicSoundsLoading.value = true;
      try {
        await bufferSounds([PublicBullBeep, PublicBearBeep]);
        arePublicSoundsLoaded.value = true;
        arePublicSoundsLoading.value = false;
      } catch (e) {
      }
    }
  });
  watch(tradesStore.activeMarketTrades, (newTrades, prevTrades) => {
    if (prevTrades.length === 0) {
      return;
    }
    playPublicTradeSound(newTrades);
  });
  watch(tradesStore.processingHiddenState, (newProcessingHiddenState) => {
    if (newProcessingHiddenState) {
      prevIsPublicTradeSoundEnabled = isPublicTradeSoundEnabled.value;
      isPublicTradeSoundEnabled.value = false;
    } else {
      isPublicTradeSoundEnabled.value = prevIsPublicTradeSoundEnabled;
    }
  });
  return {
    isPublicTradeSoundEnabled,
    toggleIsPublicTradeSoundEnabled,
    playPublicTradeSound
  };
}
function useUserTradeSounds() {
  const isUserTradeSoundEnabled = useLocalStorage(
    localStorageConstants.LOCAL_STORAGE.TRADEVIEW_USER_TRADE_SOUNDS,
    false
  );
  const areUserSoundsLoaded = ref(false);
  const areUserSoundsLoading = ref(false);
  function toggleIsUserTradeSoundEnabled() {
    isUserTradeSoundEnabled.value = !isUserTradeSoundEnabled.value;
  }
  function playUserTradeSound(trade) {
    if (!isUserTradeSoundEnabled.value || !areUserSoundsLoaded.value) {
      return;
    }
    playSound(trade.side === constants$1.ORDER_SIDE.BUY ? UserTradeSoundBuy : UserTradeSoundSell);
  }
  watchEffect(async () => {
    if (isUserTradeSoundEnabled.value && !areUserSoundsLoading.value && !areUserSoundsLoaded.value) {
      areUserSoundsLoading.value = true;
      try {
        await bufferSounds([UserTradeSoundBuy, UserTradeSoundSell]);
        areUserSoundsLoaded.value = true;
        areUserSoundsLoading.value = false;
      } catch (e) {
      }
    }
  });
  return {
    isUserTradeSoundEnabled,
    toggleIsUserTradeSoundEnabled,
    playUserTradeSound
  };
}
const useTradeviewSoundsStore = addStoreHooks(
  defineStore("tradeviewSoundsStore", () => {
    const tradesStore = storeToRefs(useTradesStore());
    const { playPublicTradeSound, toggleIsPublicTradeSoundEnabled, isPublicTradeSoundEnabled } = usePublicTradeSounds(tradesStore);
    const { playUserTradeSound, toggleIsUserTradeSoundEnabled, isUserTradeSoundEnabled } = useUserTradeSounds();
    return {
      // Public trade sounds
      playPublicTradeSound,
      toggleIsPublicTradeSoundEnabled,
      isPublicTradeSoundEnabled,
      // User trade sounds
      playUserTradeSound,
      toggleIsUserTradeSoundEnabled,
      isUserTradeSoundEnabled
    };
  })
);
const _sfc_main$1e = {
  name: "UserSettings",
  components: {
    RadioButton,
    SettingsMenu,
    LabeledSwitch
  },
  props: {
    mobile: {
      type: Boolean,
      default: false,
      required: false
    }
  },
  setup() {
    return {
      tradeviewSoundsStore: useTradeviewSoundsStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewThemeStore: useTradeviewThemeStore(),
      themeStore: useThemeStore(),
      userStateStore: useUserStateStore()
    };
  },
  data() {
    return {
      activeColorScheme: this.tradeviewThemeStore.activeColorScheme
    };
  },
  computed: {
    colorSchemeOptions() {
      return [
        {
          value: constants.COLOR_SCHEMES.CLASSIC,
          up: theme.COLOR_SCHEMES[constants.COLOR_SCHEMES.CLASSIC].TREND_UP,
          down: theme.COLOR_SCHEMES[constants.COLOR_SCHEMES.CLASSIC].TREND_DOWN
        },
        {
          value: constants.COLOR_SCHEMES.FUNKY,
          up: theme.COLOR_SCHEMES[constants.COLOR_SCHEMES.FUNKY].TREND_UP,
          down: theme.COLOR_SCHEMES[constants.COLOR_SCHEMES.FUNKY].TREND_DOWN
        }
      ];
    },
    settings() {
      let settings = [
        {
          label: "Public trade sounds",
          onToggle: this.tradeviewSoundsStore.toggleIsPublicTradeSoundEnabled,
          isActive: this.tradeviewSoundsStore.isPublicTradeSoundEnabled,
          testId: "switchSoundIndicators"
        }
      ];
      if (this.isAuthenticated) {
        const derivativesSettings = [];
        if (PAGE_CONTEXT.derivativesEnabled) {
          derivativesSettings.push({
            label: "Show open positions on chart",
            onToggle: () => this.tradeviewSettingsStore.setAreOnChartPositionsEnabled(
              !this.tradeviewSettingsStore.areOnChartPositionsEnabled
            ),
            isActive: this.tradeviewSettingsStore.areOnChartPositionsEnabled,
            testId: "switchShowPositions"
          });
        }
        settings = [
          ...settings,
          {
            label: "Play sound for your trades",
            onToggle: this.tradeviewSoundsStore.toggleIsUserTradeSoundEnabled,
            isActive: this.tradeviewSoundsStore.isUserTradeSoundEnabled,
            testId: "switchUserSoundIndicators"
          },
          {
            label: "Show open orders on chart",
            onToggle: () => this.tradeviewSettingsStore.setAreOnChartOrdersEnabled(
              !this.tradeviewSettingsStore.areOnChartOrdersEnabled
            ),
            isActive: this.tradeviewSettingsStore.areOnChartOrdersEnabled,
            testId: "switchShowOpenOrders"
          },
          ...derivativesSettings,
          {
            label: "Show fill notifications",
            onToggle: () => this.tradeviewSettingsStore.setAreFillNotificationsEnabledSetting(
              !this.tradeviewSettingsStore.areFillNotificationsEnabled
            ),
            isActive: this.tradeviewSettingsStore.areFillNotificationsEnabled,
            testId: "switchShowFillNotifications"
          },
          {
            label: "Show order removal notifications",
            onToggle: () => this.tradeviewSettingsStore.setAreOrderDeletedNotificationsEnabledSetting(
              !this.tradeviewSettingsStore.areOrderDeletedNotificationsEnabled
            ),
            isActive: this.tradeviewSettingsStore.areOrderDeletedNotificationsEnabled,
            testId: "switchShowOrderDeletedNotifications"
          },
          {
            label: "Post only on by default",
            onToggle: () => this.tradeviewSettingsStore.setIsPostOnlyOnByDefaultEnabledSetting(
              !this.tradeviewSettingsStore.isPostOnlyOnAsDefaultEnabled
            ),
            isActive: this.tradeviewSettingsStore.isPostOnlyOnAsDefaultEnabled,
            testId: "switchPostOnlyDefault"
          },
          {
            label: "Draw horizontal line on plus",
            onToggle: () => this.tradeviewSettingsStore.setIsHorizontalLineOnPlusClickedEnabled(
              !this.tradeviewSettingsStore.isHorizontalLineOnPlusClickEnabled
            ),
            isActive: this.tradeviewSettingsStore.isHorizontalLineOnPlusClickEnabled,
            testId: "switchIsHorizontalLineOnPlusClickEnabled"
          },
          {
            label: "Remember last TIF choice",
            onToggle: () => this.tradeviewSettingsStore.setIsRememberLastTifSettingEnabled(
              !this.tradeviewSettingsStore.rememberLastTif
            ),
            isActive: this.tradeviewSettingsStore.rememberLastTif,
            testId: "switchIsRememberLastTifEnabled"
          }
        ];
      }
      return settings;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    }
  },
  watch: {
    activeColorScheme(newColorScheme) {
      if (!newColorScheme) {
        return;
      }
      this.tradeviewThemeStore.setColorScheme(newColorScheme);
    }
  }
};
const _hoisted_1$16 = { class: "settings-menu__content" };
const _hoisted_2$N = { class: "color-scheme-picker" };
const _hoisted_3$J = { class: "color-scheme-badges" };
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabeledSwitch = resolveComponent("LabeledSwitch");
  const _component_RadioButton = resolveComponent("RadioButton");
  const _component_SettingsMenu = resolveComponent("SettingsMenu");
  return openBlock(), createBlock(_component_SettingsMenu, {
    "compact-switch": !$props.mobile,
    mobile: $props.mobile,
    class: "settings-menu",
    title: "Tradeview settings"
  }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$16, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.settings, (setting) => {
          return openBlock(), createBlock(_component_LabeledSwitch, {
            key: setting.testId,
            "data-test": setting.testId,
            label: setting.label,
            value: setting.isActive,
            compact: !$props.mobile,
            "onUpdate:value": setting.onToggle
          }, null, 8, ["data-test", "label", "value", "compact", "onUpdate:value"]);
        }), 128)),
        _cache[4] || (_cache[4] = createTextVNode()),
        $setup.themeStore.isDarkThemeActive ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _cache[2] || (_cache[2] = createBaseVNode("label", { class: "color-scheme-picker-label" }, "Color scheme", -1)),
          _cache[3] || (_cache[3] = createTextVNode()),
          createBaseVNode("div", _hoisted_2$N, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.colorSchemeOptions, (colorScheme) => {
              return openBlock(), createBlock(_component_RadioButton, {
                key: colorScheme.value,
                modelValue: $data.activeColorScheme,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.activeColorScheme = $event),
                value: colorScheme.value,
                label: ""
              }, {
                label: withCtx(() => [
                  createBaseVNode("div", _hoisted_3$J, [
                    createBaseVNode("div", {
                      class: "color-scheme-badges__badge",
                      style: normalizeStyle(`background-color: ${colorScheme.up};`)
                    }, null, 4),
                    _cache[1] || (_cache[1] = createTextVNode()),
                    createBaseVNode("div", {
                      class: "color-scheme-badges__badge",
                      style: normalizeStyle(`background-color: ${colorScheme.down};`)
                    }, null, 4)
                  ])
                ]),
                _: 2
              }, 1032, ["modelValue", "value"]);
            }), 128))
          ])
        ], 64)) : createCommentVNode("", true)
      ])
    ]),
    _: 1
  }, 8, ["compact-switch", "mobile"]);
}
const UserSettings = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$Y], ["__scopeId", "data-v-b0499bcb"]]);
const _sfc_main$1d = {
  name: "SideMenu"
};
const _hoisted_1$15 = { class: "side-menu" };
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$15, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
const SideMenu = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$X], ["__scopeId", "data-v-bc6f3405"]]);
const _sfc_main$1c = {
  name: "AnonMenuLinks",
  components: { BtsLink },
  props: {
    inSideMenu: {
      type: Boolean,
      default: false
    },
    hideEarnLinks: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      isDemoMode: this.$constants.demoMode ?? false
    };
  },
  computed: {
    filteredItems() {
      if (!this.inSideMenu) {
        return this.navigationLinks.filter((item) => !item.sidebarOnly && !item.hide);
      } else {
        return this.navigationLinks.filter((item) => !item.hide);
      }
    },
    navigationLinks() {
      return [
        {
          name: this.inSideMenu ? "Institutions & Partners" : "Institutions",
          link: "institutionsMarketingPage"
        },
        {
          name: "Pro",
          link: "proMarketingPage"
        },
        {
          name: "Mobile Apps",
          link: "mobile"
        },
        {
          name: "Earn Stake",
          link: "bitstampStaking",
          hide: this.hideEarnLinks
        },
        {
          name: "Earn Lend",
          link: "bitstampLending",
          hide: this.hideEarnLinks
        },
        {
          name: "Markets",
          link: "markets"
        },
        {
          name: "Tradeview",
          link: "tradeview",
          active: true
        },
        {
          name: "Blog",
          link: "blog",
          hide: this.isDemoMode
        },
        {
          name: "Learn",
          link: "learnCenter",
          hide: this.isDemoMode
        },
        {
          name: this.$t("components.navigation.mobileMenu.getBitstampApp"),
          link: "mobileApp",
          downloadLink: true,
          sidebarOnly: true,
          newTab: true
        }
      ];
    }
  },
  methods: {
    getPageUrl(name) {
      if (name === "blog") {
        return this.$constants.blogUrl;
      } else if (name === "mobileApp") {
        return URLService.getPageUrl("appStoreRedirect", {}, true, {
          r: "mobile",
          source: "navigation"
        }, true);
      }
      return URLService.getPageUrl(name);
    }
  }
};
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BtsLink = resolveComponent("BtsLink");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["anon-menu-links", {
      "anon-menu-links--in-header": !$props.inSideMenu,
      "anon-menu-links--in-side-menu": $props.inSideMenu
    }])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.filteredItems, (item) => {
      return openBlock(), createBlock(_component_BtsLink, {
        key: item.name,
        to: $options.getPageUrl(item.link),
        external: "",
        class: normalizeClass([{
          "anon-menu-links__item--active": item.active,
          "anon-menu-links__item--download-link": item.downloadLink
        }, "anon-menu-links__item"]),
        "new-tab": item.newTab
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(item.name), 1)
        ]),
        _: 2
      }, 1032, ["to", "class", "new-tab"]);
    }), 128))
  ], 2);
}
const AnonMenuLinks = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$W], ["__scopeId", "data-v-be58b7b8"]]);
const useTradeviewHeaderDropdownStore = addStoreHooks(
  defineStore("tradeviewHeaderDropdownStore", () => {
    const activeDropdown = ref(null);
    function openDropdown(dropdown) {
      activeDropdown.value = dropdown;
    }
    function closeDropdown(dropdown) {
      if (activeDropdown.value === dropdown) {
        activeDropdown.value = null;
      }
    }
    function closeAll() {
      activeDropdown.value = null;
    }
    return {
      activeDropdown,
      openDropdown,
      closeDropdown,
      closeAll
    };
  })
);
const _sfc_main$1b = {
  name: "HeaderDropdownMenu",
  components: { AppIcon },
  directives: {
    clickOutside
  },
  props: {
    type: {
      type: Number,
      required: true
    },
    triggerIcon: {
      type: String,
      default: "monochrome/user.svg"
    },
    triggerTestId: {
      type: String,
      required: true
    }
  },
  setup() {
    return {
      tradeviewHeaderDropdownStore: useTradeviewHeaderDropdownStore()
    };
  },
  computed: {
    isActive() {
      return this.tradeviewHeaderDropdownStore.activeDropdown === this.type;
    }
  },
  methods: {
    toggle() {
      if (this.tradeviewHeaderDropdownStore.activeDropdown === this.type) {
        this.close();
      } else {
        this.tradeviewHeaderDropdownStore.openDropdown(this.type);
      }
    },
    close() {
      this.tradeviewHeaderDropdownStore.closeDropdown(this.type);
    }
  }
};
const _hoisted_1$14 = ["test-id"];
const _hoisted_2$M = {
  key: 0,
  class: "header-dropdown"
};
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppIcon = resolveComponent("AppIcon");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["icon-nav__item", { "icon-nav__item--active": $options.isActive }])
  }, [
    createBaseVNode("div", {
      class: "header-dropdown-trigger",
      "test-id": $props.triggerTestId,
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.toggle && $options.toggle(...args), ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "trigger", {}, () => [
        createVNode(_component_AppIcon, {
          icon: $props.triggerIcon,
          class: "icon-nav__icon"
        }, null, 8, ["icon"])
      ], true)
    ], 8, _hoisted_1$14),
    _cache[1] || (_cache[1] = createTextVNode()),
    createVNode(Transition, { name: "expand" }, {
      default: withCtx(() => [
        $options.isActive ? withDirectives((openBlock(), createElementBlock("div", _hoisted_2$M, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])), [
          [_directive_click_outside, $options.close]
        ]) : createCommentVNode("", true)
      ]),
      _: 3
    })
  ], 2);
}
const HeaderDropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$V], ["__scopeId", "data-v-360f3a41"]]);
function parseMarginInfo(data) {
  return {
    // TODO: get currency from API
    currency: currenciesConstants.CURRENCY_USD,
    accountMarginAvailable: toDecimal(data.accountMarginAvailable),
    accountMarginReserved: toDecimal(data.accountMarginReserved),
    initialMarginRatio: data.initialMarginRatio === null ? null : toDecimal(data.initialMarginRatio),
    maintenanceMarginRatio: data.maintenanceMarginRatio === null ? null : toDecimal(data.maintenanceMarginRatio),
    accountMargin: toDecimal(data.accountMargin),
    impliedLeverage: data.impliedLeverage,
    perAsset: data.assets.reduce((acc, asset) => {
      return {
        ...acc,
        [asset.asset]: {
          currencyCode: asset.asset,
          available: toDecimal(asset.available),
          marginAvailable: toDecimal(asset.marginAvailable),
          reserved: toDecimal(asset.reserved),
          totalAmount: toDecimal(asset.totalAmount)
        }
      };
    }, {})
  };
}
const MarginInfoAPI = {
  get({ account = accountConstants.MAIN_ACCOUNT_ID } = {}) {
    return axiosInstance.get(
      URLService.buildUrl("marginInfoResource", {
        unique_id: account
      })
    ).then((data) => {
      var _a2;
      return parseMarginInfo((_a2 = data.data) == null ? void 0 : _a2.data);
    });
  }
};
const storeName$f = "tradeviewMarginInfoStore";
const useTradeviewMarginInfoStore = addStoreHooks(
  defineStore(storeName$f, () => {
    const subAccountStore = useSubAccountStore({ caller: storeName$f });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$f }));
    const activeMarketStore = useActiveMarketStore({ caller: storeName$f });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$f }));
    const { isHidden } = storeToRefs(useVisibilityStore({ caller: storeName$f }));
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$f }));
    const pollingStore = usePollingStore({ caller: storeName$f });
    const $errorTracking = useErrorTracking();
    const accountMargin = ref(null);
    const accountMarginAvailable = ref(null);
    const accountMarginReserved = ref(null);
    const accountImRatio = ref(null);
    const accountMmRatio = ref(null);
    const accountMarginCurrency = ref(null);
    const accountImpliedLeverage = ref(null);
    const marginPerCurrency = shallowRef(null);
    const isAccountMarginDataAvailable = computed(() => {
      return accountMargin.value !== null && accountMarginAvailable.value !== null;
    });
    const canFetchDerivativesOrderApis = computed(() => {
      return isLoggedIn.value && !activeMarketStore.isSpot && subAccountStore.doesActiveAccountSupportDerivatives && !isHidden.value && !!activeMarketStore.activeMarket;
    });
    let stopPollingFn = () => {
    };
    const fetchMarginInfo = _.throttle(async () => {
      if (!canFetchDerivativesOrderApis.value) {
        return;
      }
      try {
        const data = await MarginInfoAPI.get({
          account: subAccountStore.activeSubAccountId,
          useTradeviewAxios: true
        });
        accountMargin.value = data.accountMargin;
        accountMarginAvailable.value = data.accountMarginAvailable;
        accountMarginReserved.value = data.accountMarginReserved;
        accountImRatio.value = data.initialMarginRatio;
        accountMmRatio.value = data.maintenanceMarginRatio;
        accountImpliedLeverage.value = data.impliedLeverage;
        accountMarginCurrency.value = data.currency;
        marginPerCurrency.value = data.perAsset;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }, timersConstants.THROTTLE_MARGIN_BALANCES);
    function startPolling() {
      if (!canFetchDerivativesOrderApis.value) {
        return;
      }
      const { stop } = pollingStore.startPolling({
        interval: timersConstants.POLLING_MARGIN_BALANCES.TIME,
        id: timersConstants.POLLING_MARGIN_BALANCES.ID,
        fn: fetchMarginInfo
      });
      stopPollingFn = stop;
    }
    function stopPolling() {
      stopPollingFn();
      stopPollingFn = () => {
      };
    }
    function resetState() {
      accountMargin.value = null;
      accountMarginAvailable.value = null;
      accountMarginReserved.value = null;
      accountImRatio.value = null;
      accountMmRatio.value = null;
      accountImpliedLeverage.value = null;
      accountMarginCurrency.value = null;
      marginPerCurrency.value = null;
    }
    function _init() {
      if (canFetchDerivativesOrderApis.value) {
        fetchMarginInfo();
        startPolling();
      }
      return () => {
        stopPollingFn();
      };
    }
    watch(activeSubAccountId, () => {
      if (!subAccountStore.doesActiveAccountSupportDerivatives) {
        stopPolling();
        resetState();
      } else {
        fetchMarginInfo();
        if (!pollingStore.isPollingActiveForId(timersConstants.POLLING_MARGIN_BALANCES.ID)) {
          startPolling();
        }
      }
    });
    watch(
      activeMarket,
      (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
          return;
        }
        stopPolling();
        if (canFetchDerivativesOrderApis.value) {
          fetchMarginInfo();
          startPolling();
        } else {
          resetState();
        }
      },
      {
        deep: true
      }
    );
    watch(isHidden, (isNowHidden) => {
      if (isNowHidden) {
        stopPolling();
      } else if (canFetchDerivativesOrderApis.value) {
        fetchMarginInfo();
        startPolling();
      }
    });
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        stopPolling();
        resetState();
      }
    });
    return {
      accountMargin,
      accountMarginAvailable,
      accountMarginReserved,
      accountImRatio,
      accountMmRatio,
      accountMarginCurrency,
      marginPerCurrency,
      isAccountMarginDataAvailable,
      fetchMarginInfo,
      _init
    };
  })
);
const _sfc_main$1a = {
  name: "MarginBalances",
  setup() {
    return {
      currenciesStore: useCurrenciesStore(),
      tradeviewMarginInfoStore: useTradeviewMarginInfoStore()
    };
  },
  computed: {
    accountIMr() {
      var _a2;
      if (this.tradeviewMarginInfoStore.accountImRatio === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: ((_a2 = this.tradeviewMarginInfoStore.accountImRatio) == null ? void 0 : _a2.mul(100)) ?? 0,
        decimals: 2
      })}%`;
    },
    accountMMr() {
      var _a2;
      if (this.tradeviewMarginInfoStore.accountMmRatio === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: ((_a2 = this.tradeviewMarginInfoStore.accountMmRatio) == null ? void 0 : _a2.mul(100)) ?? 0,
        decimals: 2
      })}%`;
    },
    accountMargin() {
      return numberFormatter.price({
        value: this.tradeviewMarginInfoStore.accountMargin,
        decimals: this.collateralCurrency.decimals,
        currencyCode: this.collateralCurrency.code,
        currencySymbol: this.collateralCurrency.symbol
      });
    },
    accountMarginAvailable() {
      return numberFormatter.price({
        value: this.tradeviewMarginInfoStore.accountMarginAvailable,
        decimals: this.collateralCurrency.decimals,
        currencyCode: this.collateralCurrency.code,
        currencySymbol: this.collateralCurrency.symbol
      });
    },
    collateralCurrency() {
      return this.currenciesStore.getCurrency(this.tradeviewMarginInfoStore.accountMarginCurrency);
    }
  }
};
const _hoisted_1$13 = {
  key: 0,
  class: "margin-balances"
};
const _hoisted_2$L = { class: "column" };
const _hoisted_3$I = { class: "column__item" };
const _hoisted_4$B = { class: "column" };
const _hoisted_5$v = { class: "column__item" };
const _hoisted_6$s = { class: "column" };
const _hoisted_7$p = { class: "column__item" };
const _hoisted_8$o = { class: "column" };
const _hoisted_9$j = { class: "column__item" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.tradeviewMarginInfoStore.isAccountMarginDataAvailable ? (openBlock(), createElementBlock("div", _hoisted_1$13, [
    createBaseVNode("div", _hoisted_2$L, [
      _cache[0] || (_cache[0] = createBaseVNode("div", { class: "column__title" }, "\n        Account margin\n      ", -1)),
      _cache[1] || (_cache[1] = createTextVNode()),
      createBaseVNode("div", _hoisted_3$I, toDisplayString($options.accountMargin), 1)
    ]),
    _cache[8] || (_cache[8] = createTextVNode()),
    createBaseVNode("div", _hoisted_4$B, [
      _cache[2] || (_cache[2] = createBaseVNode("div", { class: "column__title" }, "\n        Margin available\n      ", -1)),
      _cache[3] || (_cache[3] = createTextVNode()),
      createBaseVNode("div", _hoisted_5$v, toDisplayString($options.accountMarginAvailable), 1)
    ]),
    _cache[9] || (_cache[9] = createTextVNode()),
    createBaseVNode("div", _hoisted_6$s, [
      _cache[4] || (_cache[4] = createBaseVNode("div", { class: "column__title" }, "\n        Account IMr\n      ", -1)),
      _cache[5] || (_cache[5] = createTextVNode()),
      createBaseVNode("div", _hoisted_7$p, toDisplayString($options.accountIMr), 1)
    ]),
    _cache[10] || (_cache[10] = createTextVNode()),
    createBaseVNode("div", _hoisted_8$o, [
      _cache[6] || (_cache[6] = createBaseVNode("div", { class: "column__title" }, "\n        Account MMr\n      ", -1)),
      _cache[7] || (_cache[7] = createTextVNode()),
      createBaseVNode("div", _hoisted_9$j, toDisplayString($options.accountMMr), 1)
    ])
  ])) : createCommentVNode("", true);
}
const MarginBalances = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$U], ["__scopeId", "data-v-525e2ac1"]]);
const _sfc_main$19 = {
  name: "TradeviewModalButton",
  props: {
    primary: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  methods: {
    onClick(e) {
      this.$emit("click", e);
    }
  }
};
const _hoisted_1$12 = ["disabled"];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    disabled: $props.disabled,
    class: normalizeClass(["modal-button", {
      "modal-button--primary": $props.primary,
      "modal-button--disabled": $props.disabled
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 10, _hoisted_1$12);
}
const TradeviewModalButton = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$T], ["__scopeId", "data-v-f6f7e7e3"]]);
const storeName$e = "tradeviewModalStore";
const useTradeviewModalStore = addStoreHooks(
  defineStore(storeName$e, () => {
    const activeModal = ref(null);
    const lastRequestedModalType = ref(null);
    async function setSelfAsActiveModalIfNoOtherModalActive(modalId) {
      if (activeModal.value === null) {
        activeModal.value = modalId;
        return true;
      }
      return false;
    }
    async function clearActiveModalIfSameAsId(modalId) {
      lastRequestedModalType.value = null;
      if (activeModal.value === modalId) {
        activeModal.value = null;
        return true;
      }
      return false;
    }
    function requestModalOpening(modalType) {
      if (activeModal.value) {
        return false;
      }
      lastRequestedModalType.value = modalType;
      return true;
    }
    function clearLastRequestedModal() {
      lastRequestedModalType.value = null;
    }
    return {
      activeModal,
      lastRequestedModalType,
      setSelfAsActiveModalIfNoOtherModalActive,
      clearActiveModalIfSameAsId,
      requestModalOpening,
      clearLastRequestedModal
    };
  })
);
const STYLE_INFO = "info";
const STYLE_ERROR = "error";
const _sfc_main$18 = {
  name: "TradeviewModal",
  components: {
    TradeviewModalButton,
    AppScrollbar: _sfc_main$1g
  },
  props: {
    xScrollDisable: {
      type: Boolean,
      default: true
    },
    isOpen: {
      type: Boolean,
      default: false
    },
    modalStyle: {
      type: String,
      default: STYLE_INFO
    },
    confirmText: {
      type: String,
      required: false,
      default: void 0
    },
    cancelText: {
      type: String,
      required: false,
      default: void 0
    },
    title: {
      type: String,
      required: false,
      default: void 0
    },
    closeOnOutsideClick: {
      type: Boolean,
      default: false
    },
    confirmDisabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:isOpen", "close", "open", "reveal", "hide", "confirm"],
  setup() {
    return {
      tradeviewModalStore: useTradeviewModalStore()
    };
  },
  data() {
    return {
      STYLE_ERROR,
      modalId: Uuid()
    };
  },
  computed: {
    isDisplayed() {
      return this.isOpen && this.tradeviewModalStore.activeModal === this.modalId;
    }
  },
  watch: {
    "tradeviewModalStore.activeModal": {
      handler(activeModal) {
        if (this.isOpen && activeModal === null) {
          this.tradeviewModalStore.setSelfAsActiveModalIfNoOtherModalActive(this.modalId);
        }
      }
    },
    isOpen: {
      handler(isNowOpen) {
        if (isNowOpen) {
          this.tradeviewModalStore.setSelfAsActiveModalIfNoOtherModalActive(this.modalId);
        } else {
          this.tradeviewModalStore.clearActiveModalIfSameAsId(this.modalId);
        }
      },
      immediate: true
    },
    isDisplayed(isNowDisplayed) {
      var _a2, _b;
      if (isNowDisplayed) {
        document.body.classList.add("modal--is-open");
        this.redirectFocus();
        (_a2 = this.$el) == null ? void 0 : _a2.addEventListener("keydown", this.onKeyDown);
        this.$emit("open", true);
      } else {
        this.teardownModal();
        (_b = this.$el) == null ? void 0 : _b.removeEventListener("keydown", this.onKeyDown);
        this.$emit("close");
      }
    }
  },
  beforeUnmount() {
    if (this.isOpen) {
      this.teardownModal();
    }
    this.tradeviewModalStore.clearActiveModalIfSameAsId(this.modalId);
  },
  methods: {
    onBackdropClick(closeFn) {
      if (this.closeOnOutsideClick) {
        closeFn();
      }
    },
    close() {
      this.tradeviewModalStore.clearLastRequestedModal();
      this.$emit("update:isOpen", false);
      this.$emit("close");
    },
    redirectFocus() {
      var _a2;
      (_a2 = this.$refs.content) == null ? void 0 : _a2.focus();
    },
    /**
     * Prevent focusing element in background of modal using `tab` key
     */
    restrictFocus(event) {
      if (!this.$refs.content.contains(event.target)) {
        event.stopPropagation();
        this.$refs.content.focus();
      }
    },
    teardownModal() {
      document.removeEventListener("focus", this.restrictFocus, true);
      if (this.lastFocusedElement) {
        this.lastFocusedElement.focus();
      }
    },
    onAfterEnter() {
      this.$emit("reveal");
      this.lastFocusedElement = document.activeElement;
      this.$refs.content.focus();
      document.addEventListener("focus", this.restrictFocus, true);
    },
    onAfterLeave() {
      this.$emit("hide");
      document.body.classList.remove("modal--is-open");
    },
    onKeyDown(event) {
      if (this.isOpen && "key" in event) {
        if (event.key === "Escape" || event.key === "Esc") {
          this.close(event);
        }
      }
    }
  },
  STYLE_ERROR
};
const _hoisted_1$11 = {
  ref: "content",
  class: "modal",
  tabindex: "-1"
};
const _hoisted_2$K = { class: "modal__header" };
const _hoisted_3$H = { class: "modal__title" };
const _hoisted_4$A = { class: "flex flex--align-center flex--gap-small" };
const _hoisted_5$u = {
  key: 0,
  class: "error-icon"
};
const _hoisted_6$r = {
  key: 0,
  class: "modal__footer"
};
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppScrollbar = resolveComponent("AppScrollbar");
  const _component_TradeviewModalButton = resolveComponent("TradeviewModalButton");
  const _component_portal = resolveComponent("portal");
  return openBlock(), createBlock(_component_portal, { to: "modal" }, {
    default: withCtx(() => [
      createVNode(Transition, {
        name: "modal--transition",
        mode: "out-in",
        onAfterEnter: $options.onAfterEnter,
        onAfterLeave: $options.onAfterLeave
      }, {
        default: withCtx(() => [
          $options.isDisplayed ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "modal-wrapper",
            "data-test": "modalWrapper",
            onClick: _cache[4] || (_cache[4] = withModifiers(($event) => $options.onBackdropClick($options.close), ["self"]))
          }, [
            createBaseVNode("div", _hoisted_1$11, [
              createBaseVNode("div", _hoisted_2$K, [
                createBaseVNode("div", _hoisted_3$H, [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createBaseVNode("div", _hoisted_4$A, [
                      $props.modalStyle === $data.STYLE_ERROR ? (openBlock(), createElementBlock("div", _hoisted_5$u, _cache[5] || (_cache[5] = [
                        createBaseVNode("div", { class: "error-icon__img" }, null, -1)
                      ]))) : createCommentVNode("", true),
                      _cache[6] || (_cache[6] = createTextVNode()),
                      createBaseVNode("span", null, toDisplayString($props.title), 1)
                    ])
                  ], true)
                ]),
                _cache[7] || (_cache[7] = createTextVNode()),
                createBaseVNode("div", {
                  class: "modal__close icon-close",
                  "data-test": "closeModal",
                  onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args))
                })
              ]),
              _cache[9] || (_cache[9] = createTextVNode()),
              createVNode(_component_AppScrollbar, {
                "always-visible": "",
                "x-scroll-disable": $props.xScrollDisable,
                class: "modal__content modal-content"
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "body", {
                    tabindex: "0",
                    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.blur && _ctx.blur(...args))
                  }, void 0, true)
                ]),
                _: 3
              }, 8, ["x-scroll-disable"]),
              _cache[10] || (_cache[10] = createTextVNode()),
              _ctx.$slots.footer || $props.confirmText || $props.cancelText ? (openBlock(), createElementBlock("div", _hoisted_6$r, [
                renderSlot(_ctx.$slots, "footer", {}, () => [
                  $props.cancelText ? (openBlock(), createBlock(_component_TradeviewModalButton, {
                    key: 0,
                    "test-id": "modal-button-cancel",
                    onClick: $options.close
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString($props.cancelText), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("", true),
                  _cache[8] || (_cache[8] = createTextVNode()),
                  $props.confirmText ? (openBlock(), createBlock(_component_TradeviewModalButton, {
                    key: 1,
                    "test-id": "modal-button-confirm",
                    primary: "",
                    disabled: $props.confirmDisabled,
                    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("confirm"))
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString($props.confirmText), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])) : createCommentVNode("", true)
                ], true)
              ])) : createCommentVNode("", true),
              _cache[11] || (_cache[11] = createTextVNode()),
              createBaseVNode("div", {
                class: "modal__focus-redirect",
                "data-test": "modalFocusRedirect",
                tabindex: "0",
                onFocus: _cache[3] || (_cache[3] = withModifiers((...args) => $options.redirectFocus && $options.redirectFocus(...args), ["stop"]))
              }, null, 32)
            ], 512)
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave"])
    ]),
    _: 3
  });
}
const TradeviewModal = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$S], ["__scopeId", "data-v-7a4941b3"]]);
const _sfc_main$17 = {
  name: "ProCreateSubAccountModal",
  components: {
    AppForm: BtsForm,
    TradeviewModal
  },
  props: {
    initialAccountMarketType: {
      type: Number,
      required: false,
      default: null
    }
  },
  emits: ["close", "subAccountCreated"],
  setup() {
    return {
      subAccountStore: useSubAccountStore()
    };
  },
  data() {
    return {
      isValid: true,
      requestInFlight: false,
      formModel: {
        name: null,
        selectedMarketType: this.initialAccountMarketType ?? null
      }
    };
  },
  computed: {
    formSchema() {
      return {
        fields: [
          {
            type: "input",
            model: "name",
            validator: [
              validators.string.locale({
                textTooBig: "A name is limited to {1} characters, currently using {0}."
              }),
              validators.regexp.locale({
                invalidFormat: "You can only use alphanumeric characters and spaces."
              }),
              this.nameValidation
            ],
            pattern: "^[0-9a-zA-Z ]*$",
            fieldOptions: {
              inputType: "text",
              max: 30,
              autocomplete: "off",
              label: "Sub account name (optional)",
              testId: "sub-account-name"
            }
          },
          {
            type: "select",
            model: "selectedMarketType",
            visible: this.areMultipleMarketTypesAllowed,
            values: this.accountMarketTypeOptions,
            fieldOptions: {
              label: "Type",
              testId: "sub-account-type",
              inputHasIcon: true
            }
          }
        ]
      };
    },
    areMultipleMarketTypesAllowed() {
      var _a2, _b;
      return (((_b = (_a2 = CONSTANTS) == null ? void 0 : _a2.allowedSubAccountMarketTypes) == null ? void 0 : _b.length) ?? 0) > 1;
    },
    accountMarketTypeOptions() {
      var _a2;
      return ((_a2 = CONSTANTS.allowedSubAccountMarketTypes) == null ? void 0 : _a2.map((type) => {
        let icon = "monochrome/spot-account.svg";
        let text = accountConstants.ACCOUNT_MARKET_TYPES_DISPLAY.SPOT;
        if (type === accountConstants.ACCOUNT_MARKET_TYPES.DERIVATIVES) {
          icon = "monochrome/derivatives-account.svg";
          text = accountConstants.ACCOUNT_MARKET_TYPES_DISPLAY.DERIVATIVES;
        }
        return {
          value: type,
          text,
          icon
        };
      })) ?? [];
    }
  },
  mounted() {
    if (!this.areMultipleMarketTypesAllowed) {
      setTimeout(() => {
        var _a2;
        (_a2 = document.getElementById("form_name")) == null ? void 0 : _a2.focus();
      }, 100);
    }
    if (!this.areMultipleMarketTypesAllowed) {
      this.formModel = {
        ...this.formModel,
        selectedMarketType: accountConstants.ACCOUNT_MARKET_TYPES.SPOT
      };
    }
  },
  methods: {
    onSubmitRequested() {
      if (this.isValid) {
        this.onConfirm();
      }
    },
    onValidated(isValid2) {
      this.isValid = isValid2;
    },
    closeModal() {
      this.$emit("close");
    },
    async onConfirm() {
      try {
        if (this.requestInFlight) {
          return;
        }
        this.requestInFlight = true;
        const accountName = (this.formModel.name ?? "").trim();
        const newSubAccount = await this.subAccountStore.create(accountName, this.formModel.selectedMarketType);
        this.$emit("subAccountCreated", newSubAccount.id);
      } catch (e) {
      } finally {
        this.requestInFlight = false;
      }
    },
    nameValidation() {
      const trimmedName = (this.formModel.name ?? "").trim();
      if (this.subAccountStore.accountList.find(({ name }) => name === trimmedName)) {
        return ["You already have a sub account with this name."];
      }
      if (["main", "main account"].includes(trimmedName.toLowerCase())) {
        return ["Unable to name sub account as main account."];
      }
    }
  }
};
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppForm = resolveComponent("AppForm");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createBlock(_component_TradeviewModal, {
    "is-open": "",
    "cancel-text": "Cancel",
    "confirm-text": "Create",
    "confirm-disabled": !$data.isValid || $data.requestInFlight,
    onClose: $options.closeModal,
    onConfirm: $options.onConfirm
  }, {
    title: withCtx(() => _cache[0] || (_cache[0] = [
      createTextVNode("\n      Create a new sub account\n    ")
    ])),
    body: withCtx(() => [
      createVNode(_component_AppForm, {
        class: normalizeClass({ "pro-create-account-form": $options.areMultipleMarketTypesAllowed }),
        schema: $options.formSchema,
        model: $data.formModel,
        onSubmitRequested: $options.onSubmitRequested,
        onValidated: $options.onValidated
      }, null, 8, ["class", "schema", "model", "onSubmitRequested", "onValidated"])
    ]),
    _: 1
  }, 8, ["confirm-disabled", "onClose", "onConfirm"]);
}
const ProCreateSubAccountModal = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$R], ["__scopeId", "data-v-dcf98243"]]);
const _sfc_main$16 = {
  name: "SubAccountFundTransferModal",
  components: {
    AppCheckbox: Checkbox,
    SubAccountTransferForm,
    GeneralNotification,
    TradeviewModal
  },
  props: {
    toAccountId: {
      type: Number,
      default: null
    },
    newAccountCreated: {
      type: Boolean,
      default: false
    }
  },
  emits: ["close"],
  setup() {
    return {
      subAccountStore: useSubAccountStore(),
      balancesStore: useBalancesStore(),
      tradeviewMarginInfoStore: useTradeviewMarginInfoStore()
    };
  },
  data() {
    return {
      NOTIFICATION_TYPE_SUCCESS: GeneralNotification.SUCCESS,
      newAccountNotificationDismissed: false,
      keepModalOpenAfterTransfer: false
    };
  },
  methods: {
    onTransfer() {
      setTimeout(() => {
        this.balancesStore.fetch();
        this.tradeviewMarginInfoStore.fetchMarginInfo();
      }, 1e3);
      if (!this.keepModalOpenAfterTransfer) {
        this.closeModal();
      }
    },
    closeModal() {
      this.$emit("close");
    }
  }
};
const _hoisted_1$10 = { class: "flex flex--justify-center" };
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GeneralNotification = resolveComponent("GeneralNotification");
  const _component_SubAccountTransferForm = resolveComponent("SubAccountTransferForm");
  const _component_AppCheckbox = resolveComponent("AppCheckbox");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createBlock(_component_TradeviewModal, {
    "is-open": "",
    onClose: $options.closeModal
  }, {
    title: withCtx(() => _cache[2] || (_cache[2] = [
      createTextVNode("\n      Transfer between accounts\n    ")
    ])),
    body: withCtx(() => [
      $props.newAccountCreated && !$data.newAccountNotificationDismissed ? (openBlock(), createBlock(_component_GeneralNotification, {
        key: 0,
        class: "sub-account-created-notification",
        title: "New sub account created",
        dismissible: "",
        "notification-type": $data.NOTIFICATION_TYPE_SUCCESS,
        onDismiss: _cache[0] || (_cache[0] = ($event) => $data.newAccountNotificationDismissed = true)
      }, {
        default: withCtx(() => _cache[3] || (_cache[3] = [
          createTextVNode("\n        You can now transfer funds to your new sub account and start trading.\n      ")
        ])),
        _: 1
      }, 8, ["notification-type"])) : createCommentVNode("", true),
      _cache[4] || (_cache[4] = createTextVNode()),
      createVNode(_component_SubAccountTransferForm, {
        class: "modal-form",
        "inline-presets": "",
        "inline-result-messages": "",
        "preselected-to-account-id": $props.toAccountId,
        "preselected-asset": $setup.subAccountStore.preselectedTransferAsset,
        presets: [25, 50, 100],
        onTransfer: $options.onTransfer
      }, null, 8, ["preselected-to-account-id", "preselected-asset", "onTransfer"]),
      _cache[5] || (_cache[5] = createTextVNode()),
      createBaseVNode("div", _hoisted_1$10, [
        createVNode(_component_AppCheckbox, {
          checked: $data.keepModalOpenAfterTransfer,
          "onUpdate:checked": _cache[1] || (_cache[1] = ($event) => $data.keepModalOpenAfterTransfer = $event),
          class: "multiple-transfers-choice",
          label: "Keep dialog open for multiple transfers"
        }, null, 8, ["checked"])
      ])
    ]),
    _: 1
  }, 8, ["onClose"]);
}
const SubAccountFundTransferModal = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$Q], ["__scopeId", "data-v-625a45e6"]]);
const navigationLinks = [
  {
    name: "Dashboard",
    link: "proDashboard"
  },
  {
    name: "Trade",
    link: "tradeview",
    active: true
  },
  {
    name: "Deposit",
    link: "deposits_overview",
    permissions: ["deposits_read"],
    condition: !CONSTANTS.demoMode
  },
  {
    name: "Withdraw",
    link: "accountWithdrawals",
    permissions: ["withdrawals_read"],
    condition: !CONSTANTS.demoMode
  },
  {
    name: "Earn",
    link: "earnDashboard",
    permissions: ["earn_read"],
    condition: PAGE_CONTEXT.isEarnPageEnabledForUser && !CONSTANTS.showVaspInvestmentRiskWarning && !CONSTANTS.demoMode
  },
  {
    name: "OTC",
    link: "otcDashboard",
    permissions: ["otc_history_read"],
    condition: PAGE_CONTEXT.isOTCPageEnabledForUser && !CONSTANTS.demoMode
  }
];
const _sfc_main$15 = {
  name: "TradeviewHeader",
  components: {
    BtsLink,
    BtsButton,
    SubAccountFundTransferModal,
    ProCreateSubAccountModal,
    MarginBalances,
    HeaderDropdownMenu,
    DownloadAppMenu,
    HeaderVaspDisclaimer,
    AnonMenuLinks,
    SideMenu,
    ProSwitch,
    UserSettings,
    AppIcon,
    AccountTypeIcon,
    PlatformNotification,
    AccountMenu,
    BitstampProLogo,
    BitstampDemoLogo,
    TradeviewMarketSelector,
    ArrowDownSVG,
    UserMenu,
    MenuToggleIcon,
    Swiper,
    SwiperSlide
  },
  directives: {
    clickOutside
  },
  setup() {
    const { selectAccount } = useSubAccounts();
    return {
      selectAccount,
      activeMarketStore: useActiveMarketStore(),
      currenciesStore: useCurrenciesStore(),
      balancesStore: useBalancesStore(),
      favoritesStore: useFavoritesStore(),
      preferredCurrencyStore: usePreferredCurrencyStore(),
      conversionPathStore: useConversionPathStore(),
      subAccountStore: useSubAccountStore(),
      tradeviewHeaderDropdownStore: useTradeviewHeaderDropdownStore(),
      tradeviewMarginInfoStore: useTradeviewMarginInfoStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      userStateStore: useUserStateStore(),
      modules: [Navigation]
    };
  },
  data() {
    return {
      isDemoMode: CONSTANTS.demoMode ?? false,
      hasMobileApp: CONSTANTS.hasMobileApp ?? false,
      newSubAccountId: null,
      isSideMenuOpen: false,
      dropdowns: constants.TRADEVIEW_HEADER_DROPDOWNS,
      hideEarnLinks: this.$constants.showVaspInvestmentRiskWarning,
      navigationLinks
    };
  },
  computed: {
    initialSelectedMarketType() {
      if (this.activeMarketStore.isPerpetual) {
        return accountConstants.ACCOUNT_MARKET_TYPES.DERIVATIVES;
      }
      return accountConstants.ACCOUNT_MARKET_TYPES.SPOT;
    },
    subAccountToTransferTo() {
      if (this.newSubAccountId) {
        return this.newSubAccountId;
      } else if (!this.subAccountStore.isMainActive) {
        return this.subAccountStore.activeSubAccountId;
      }
      return null;
    },
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    permittedNavigationLinks() {
      return navigationLinks.filter((link) => {
        var _a2;
        return (link.condition ?? true) && (((_a2 = link.permissions) == null ? void 0 : _a2.every((p) => this.$has(p))) ?? true);
      });
    },
    isActiveMarketFavorite() {
      return this.favoritesStore.favoriteMarkets[this.activeMarket.key];
    },
    registerUrl() {
      return URLService.getPageUrl("register");
    },
    loginUrl() {
      return URLService.getPageUrl("login", {}, true, {
        next: URLService.getPageUrl("proTrade", { market: this.activeMarket.key })
      });
    },
    logoLink() {
      if (this.isAuthenticated) {
        return URLService.getPageUrl("dashboardRouter");
      }
      return "/";
    },
    hasSubAccounts() {
      return this.subAccountStore.hasSubAccounts;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    },
    activeSubAccountName() {
      return this.subAccountStore.activeSubAccountDisplayName;
    },
    summary() {
      var _a2, _b;
      const ticker = this.tradeviewTickersStore.activeMarketTicker;
      const counterDecimals = this.activeMarket.decimals.counter;
      const baseDecimals = this.activeMarket.decimals.base;
      const counterCurrency = this.currenciesStore.getCurrency(this.activeMarket.counter);
      const preferredCurrency = this.preferredCurrencyStore.preferredCurrency;
      const conversionPathKey = buildKey(this.activeMarket.counter, preferredCurrency);
      const conversionPath = this.conversionPathStore.conversionPaths[conversionPathKey];
      let volumeInPreferredCurrency = null;
      if (conversionPath) {
        const [conversionRate] = conversionPathToPrice(conversionPath, this.tradeviewTickersStore.tickers);
        const counterVolume = toDecimal((_a2 = ticker.volume) == null ? void 0 : _a2.mul(toDecimal(ticker.vwap)));
        volumeInPreferredCurrency = counterVolume.mul(toDecimal(conversionRate));
      }
      return {
        high: numberFormatter.decimal({ value: ticker.high, decimals: counterDecimals }),
        low: numberFormatter.decimal({ value: ticker.low, decimals: counterDecimals }),
        price: numberFormatter.decimal({ value: ticker.last, decimals: counterDecimals }),
        last24: numberFormatter.percentageChange(ticker.last24),
        counterDisplay: counterCurrency.symbol,
        delta: numberFormatter.decimal({ value: ticker.delta, decimals: counterDecimals }),
        baseVolume: numberFormatter.decimal({
          value: ticker.volume,
          decimals: baseDecimals < 2 ? baseDecimals : 2,
          rounding: Decimal.ROUND_UP
        }),
        preferredCurrencyVolume: volumeInPreferredCurrency === null ? null : numberFormatter.decimal({
          value: volumeInPreferredCurrency,
          decimals: preferredCurrency === currenciesConstants.CURRENCY_BTC ? 8 : 0,
          rounding: Decimal.ROUND_UP
        }),
        changeClass: `price-change--${((_b = ticker.last24) == null ? void 0 : _b.greaterThanOrEqualTo(0)) ? "up" : "down"}`,
        indexPrice: ticker.indexPrice ? numberFormatter.decimal({ value: ticker.indexPrice, decimals: counterDecimals }) : "/",
        markPrice: ticker.markPrice ? numberFormatter.decimal({ value: ticker.markPrice, decimals: counterDecimals }) : "/",
        fundingPercentage: ticker.fundingRate ? `${numberFormatter.decimal({
          value: ticker.fundingRate.mul(100),
          decimals: 4
        })}% @ ${getNextFundingFormattedDate(this.activeMarketStore.activeMarket.fundingInterval)}` : "/"
      };
    },
    formattedAccountValue() {
      const value = this.balancesStore.activeAccountValue;
      if (value === null) {
        return "";
      }
      const currencyCode = this.preferredCurrencyStore.preferredCurrency;
      const counter = this.currenciesStore.getCurrency(currencyCode);
      return numberFormatter.price({
        value,
        decimals: counter.decimals,
        currencySymbol: counter.symbol,
        currencyCode
      });
    },
    isMarketsDropdownActive() {
      return this.tradeviewHeaderDropdownStore.activeDropdown === constants.TRADEVIEW_HEADER_DROPDOWNS.MARKET_SELECTOR;
    },
    showBetaFeedbackLink() {
      return this.$constants.isBetaFeedbackSurveyEnabled;
    }
  },
  methods: {
    openSubAccountTransferModal() {
      this.tradeviewHeaderDropdownStore.closeAll();
      this.subAccountStore.openTransferFundsModal();
    },
    openSubAccountCreateModal() {
      this.tradeviewHeaderDropdownStore.closeAll();
      this.subAccountStore.openCreateSubAccountModal();
    },
    closeSubAccountTransferModal() {
      this.subAccountStore.closeTransferFundsModal();
      this.newSubAccountId = null;
    },
    onSubAccountCreated(newAccountId) {
      this.newSubAccountId = newAccountId;
      this.selectAccount(newAccountId);
      this.subAccountStore.closeCreateSubAccountModal();
      this.subAccountStore.openTransferFundsModal();
    },
    toggleFavorite() {
      this.favoritesStore.toggleMarket(this.activeMarket.key);
    },
    getAccountBalance(accountId) {
      return this.balancesStore.getAccountBalances(accountId);
    },
    getPageUrl(name) {
      return URLService.getPageUrl(name);
    },
    async setActiveAccount(accountId) {
      this.selectAccount(accountId);
      this.closeMarketsDropdown();
      this.tradeviewHeaderDropdownStore.closeDropdown(this.dropdowns.SUB_ACCOUNT);
    },
    toggleMarketsDropdown() {
      if (this.isMarketsMenuOpen) {
        this.closeMarketsDropdown();
      } else {
        this.tradeviewHeaderDropdownStore.openDropdown(constants.TRADEVIEW_HEADER_DROPDOWNS.MARKET_SELECTOR);
      }
      this.closeSideMenu();
    },
    closeMarketsDropdown() {
      this.tradeviewHeaderDropdownStore.closeDropdown(constants.TRADEVIEW_HEADER_DROPDOWNS.MARKET_SELECTOR);
    },
    toggleSideMenu() {
      this.tradeviewHeaderDropdownStore.closeAll();
      this.isSideMenuOpen = !this.isSideMenuOpen;
    },
    closeSideMenu() {
      this.isSideMenuOpen = false;
    }
  }
};
const _hoisted_1$$ = { class: "header-wrapper" };
const _hoisted_2$J = { class: "header__top" };
const _hoisted_3$G = { class: "header__brand" };
const _hoisted_4$z = {
  key: 0,
  class: "header-logo__entity"
};
const _hoisted_5$t = {
  key: 0,
  class: "header__menu header-menu"
};
const _hoisted_6$q = {
  key: 1,
  class: "header__beta-feedback",
  href: "https://surveys.bitstamp.net/s3/a945912f106f",
  target: "_blank"
};
const _hoisted_7$o = { class: "icon-nav__selected-account-name" };
const _hoisted_8$n = { class: "header__notifications" };
const _hoisted_9$i = { class: "header__bottom" };
const _hoisted_10$i = { class: "header__left" };
const _hoisted_11$h = { class: "header__select-market" };
const _hoisted_12$e = { class: "header__current-price price-block" };
const _hoisted_13$e = { class: "sub-header-right" };
const _hoisted_14$d = { class: "market-data" };
const _hoisted_15$d = { class: "market-data__item" };
const _hoisted_16$c = { class: "market-data__item" };
const _hoisted_17$c = { class: "market-data__item" };
const _hoisted_18$b = { class: "market-data__item" };
const _hoisted_19$9 = { class: "market-data__item" };
const _hoisted_20$9 = { class: "market-data__item" };
const _hoisted_21$9 = {
  title: "24 hour volume converted to your preferred currency",
  class: "market-data__title"
};
const _hoisted_22$9 = { class: "market-data__item" };
const _hoisted_23$7 = {
  key: 0,
  class: "header__side-menu"
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppIcon = resolveComponent("AppIcon");
  const _component_BitstampDemoLogo = resolveComponent("BitstampDemoLogo");
  const _component_BitstampProLogo = resolveComponent("BitstampProLogo");
  const _component_BtsLink = resolveComponent("BtsLink");
  const _component_ProSwitch = resolveComponent("ProSwitch");
  const _component_AnonMenuLinks = resolveComponent("AnonMenuLinks");
  const _component_BtsButton = resolveComponent("BtsButton");
  const _component_DownloadAppMenu = resolveComponent("DownloadAppMenu");
  const _component_HeaderDropdownMenu = resolveComponent("HeaderDropdownMenu");
  const _component_AccountTypeIcon = resolveComponent("AccountTypeIcon");
  const _component_AccountMenu = resolveComponent("AccountMenu");
  const _component_UserMenu = resolveComponent("UserMenu");
  const _component_UserSettings = resolveComponent("UserSettings");
  const _component_MenuToggleIcon = resolveComponent("MenuToggleIcon");
  const _component_PlatformNotification = resolveComponent("PlatformNotification");
  const _component_HeaderVaspDisclaimer = resolveComponent("HeaderVaspDisclaimer");
  const _component_ArrowDownSVG = resolveComponent("ArrowDownSVG");
  const _component_swiper_slide = resolveComponent("swiper-slide");
  const _component_swiper = resolveComponent("swiper");
  const _component_MarginBalances = resolveComponent("MarginBalances");
  const _component_TradeviewMarketSelector = resolveComponent("TradeviewMarketSelector");
  const _component_SideMenu = resolveComponent("SideMenu");
  const _component_ProCreateSubAccountModal = resolveComponent("ProCreateSubAccountModal");
  const _component_SubAccountFundTransferModal = resolveComponent("SubAccountFundTransferModal");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock("div", _hoisted_1$$, [
    createBaseVNode("header", {
      class: normalizeClass(["header", { "header--demo-mode": $data.isDemoMode }])
    }, [
      createBaseVNode("div", _hoisted_2$J, [
        createBaseVNode("div", {
          class: normalizeClass(["header__left", { "header__left--anon": !$options.isAuthenticated }])
        }, [
          $data.isDemoMode ? (openBlock(), createBlock(_component_AppIcon, {
            key: 0,
            icon: "monochrome/warning.svg",
            class: "header__demo-indicator"
          })) : createCommentVNode("", true),
          _cache[4] || (_cache[4] = createTextVNode()),
          createBaseVNode("div", _hoisted_3$G, [
            createVNode(_component_BtsLink, {
              title: "Bitstamp",
              class: "header-logo",
              to: $options.logoLink,
              external: ""
            }, {
              default: withCtx(() => [
                $data.isDemoMode ? (openBlock(), createBlock(_component_BitstampDemoLogo, {
                  key: 0,
                  class: "header-logo__img"
                })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createVNode(_component_BitstampProLogo, { class: "header-logo__img" }),
                  _cache[3] || (_cache[3] = createTextVNode()),
                  $options.isAuthenticated && $setup.userStateStore.state.bitstampEntity ? (openBlock(), createElementBlock("span", _hoisted_4$z, toDisplayString($setup.userStateStore.state.bitstampEntity.shortName), 1)) : createCommentVNode("", true)
                ], 64))
              ]),
              _: 1
            }, 8, ["to"])
          ]),
          _cache[5] || (_cache[5] = createTextVNode()),
          $options.isAuthenticated && !$data.isDemoMode ? (openBlock(), createBlock(_component_ProSwitch, { key: 1 })) : createCommentVNode("", true)
        ], 2),
        _cache[18] || (_cache[18] = createTextVNode()),
        $options.isAuthenticated ? (openBlock(), createElementBlock("div", _hoisted_5$t, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.permittedNavigationLinks, (item) => {
            return openBlock(), createBlock(_component_BtsLink, {
              key: item.name,
              to: $options.getPageUrl(item.link),
              external: "",
              class: normalizeClass([{ "header-menu__item--active": item.active }, "header-menu__item"])
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(item.name), 1)
              ]),
              _: 2
            }, 1032, ["to", "class"]);
          }), 128))
        ])) : (openBlock(), createBlock(_component_AnonMenuLinks, {
          key: 1,
          "hide-earn-links": $data.hideEarnLinks,
          class: "header__menu"
        }, null, 8, ["hide-earn-links"])),
        _cache[19] || (_cache[19] = createTextVNode()),
        createBaseVNode("div", {
          class: normalizeClass(["header__right icon-nav", { "header__right--beta": $options.showBetaFeedbackLink }])
        }, [
          !$options.isAuthenticated ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createVNode(_component_BtsLink, {
              class: normalizeClass(["header__button-login auth-button", { "button--demo-mode": $data.isDemoMode }]),
              to: $options.loginUrl,
              external: ""
            }, {
              default: withCtx(() => _cache[6] || (_cache[6] = [
                createTextVNode("\n              Log in\n            ")
              ])),
              _: 1
            }, 8, ["class", "to"]),
            _cache[8] || (_cache[8] = createTextVNode()),
            !$options.showBetaFeedbackLink ? (openBlock(), createBlock(_component_BtsButton, {
              key: 0,
              class: "header__button-register auth-button",
              link: $options.registerUrl,
              external: ""
            }, {
              default: withCtx(() => _cache[7] || (_cache[7] = [
                createTextVNode("\n              Get started\n            ")
              ])),
              _: 1
            }, 8, ["link"])) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true),
          _cache[14] || (_cache[14] = createTextVNode()),
          $options.showBetaFeedbackLink ? (openBlock(), createElementBlock("a", _hoisted_6$q, [
            createVNode(_component_AppIcon, {
              icon: "monochrome/feedback.svg",
              size: "20"
            }),
            _cache[9] || (_cache[9] = createTextVNode()),
            _cache[10] || (_cache[10] = createBaseVNode("span", { class: "header__beta-feedback-text" }, "Give Feedback", -1))
          ])) : createCommentVNode("", true),
          _cache[15] || (_cache[15] = createTextVNode()),
          !$data.isDemoMode && !$data.hasMobileApp ? (openBlock(), createBlock(_component_HeaderDropdownMenu, {
            key: 2,
            type: $data.dropdowns.APP_DOWNLOAD,
            "trigger-icon": "monochrome/smartphone.svg",
            "trigger-test-id": "openDownloadAppMenu"
          }, {
            default: withCtx(() => [
              createVNode(_component_DownloadAppMenu)
            ]),
            _: 1
          }, 8, ["type"])) : createCommentVNode("", true),
          _cache[16] || (_cache[16] = createTextVNode()),
          $options.isAuthenticated ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
            createVNode(_component_HeaderDropdownMenu, {
              type: $data.dropdowns.SUB_ACCOUNT,
              "trigger-test-id": "openAccountMenu"
            }, {
              trigger: withCtx(() => [
                createVNode(_component_AccountTypeIcon, {
                  "supports-derivatives": $setup.subAccountStore.doesActiveAccountSupportDerivatives,
                  "is-main-account": $setup.subAccountStore.isMainActive
                }, null, 8, ["supports-derivatives", "is-main-account"]),
                _cache[11] || (_cache[11] = createTextVNode()),
                createBaseVNode("span", _hoisted_7$o, toDisplayString($options.activeSubAccountName), 1)
              ]),
              default: withCtx(() => [
                _cache[12] || (_cache[12] = createTextVNode()),
                createVNode(_component_AccountMenu, {
                  "manage-sub-accounts-with-modals": "",
                  accounts: $setup.subAccountStore.accountList,
                  "active-account-id": $setup.subAccountStore.activeSubAccountId,
                  "account-balance-getter": $options.getAccountBalance,
                  onSetActiveAccount: $options.setActiveAccount,
                  onRequestNewAccount: $options.openSubAccountCreateModal,
                  onRequestFundTransfer: $options.openSubAccountTransferModal
                }, null, 8, ["accounts", "active-account-id", "account-balance-getter", "onSetActiveAccount", "onRequestNewAccount", "onRequestFundTransfer"])
              ]),
              _: 1
            }, 8, ["type"]),
            _cache[13] || (_cache[13] = createTextVNode()),
            createVNode(_component_HeaderDropdownMenu, {
              type: $data.dropdowns.USER,
              "trigger-icon": $setup.userStateStore.state.isCorporateAccount ? "monochrome/company.svg" : "monochrome/user.svg",
              "trigger-test-id": "openUserMenu"
            }, {
              default: withCtx(() => [
                createVNode(_component_UserMenu, { "formatted-account-value": $options.formattedAccountValue }, null, 8, ["formatted-account-value"])
              ]),
              _: 1
            }, 8, ["type", "trigger-icon"])
          ], 64)) : createCommentVNode("", true),
          _cache[17] || (_cache[17] = createTextVNode()),
          createVNode(_component_HeaderDropdownMenu, {
            type: $data.dropdowns.SETTINGS,
            "trigger-icon": "monochrome/sliders.svg",
            "trigger-test-id": "openSettingsMenu"
          }, {
            default: withCtx(() => [
              createVNode(_component_UserSettings)
            ]),
            _: 1
          }, 8, ["type"])
        ], 2),
        _cache[20] || (_cache[20] = createTextVNode()),
        createBaseVNode("div", {
          class: normalizeClass(["header__side-menu-toggler", { "header__side-menu-toggler--anon": !$options.isAuthenticated }]),
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.toggleSideMenu && $options.toggleSideMenu(...args), ["stop"]))
        }, [
          createVNode(_component_MenuToggleIcon, { "is-open": $data.isSideMenuOpen }, null, 8, ["is-open"])
        ], 2)
      ]),
      _cache[53] || (_cache[53] = createTextVNode()),
      createBaseVNode("div", _hoisted_8$n, [
        createVNode(_component_PlatformNotification, { "full-width": "" }),
        _cache[21] || (_cache[21] = createTextVNode()),
        createVNode(_component_HeaderVaspDisclaimer, { "full-width": "" })
      ]),
      _cache[54] || (_cache[54] = createTextVNode()),
      createBaseVNode("div", _hoisted_9$i, [
        createBaseVNode("div", _hoisted_10$i, [
          $options.isAuthenticated ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["favorite-market", { "favorite-market--active": $options.isActiveMarketFavorite }]),
            title: "Toggle favorite",
            onClick: _cache[1] || (_cache[1] = (...args) => $options.toggleFavorite && $options.toggleFavorite(...args))
          }, [
            createVNode(_component_AppIcon, {
              icon: "monochrome/fav-star-selected.svg",
              class: "favorite-market__icon",
              size: "16"
            })
          ], 2)) : createCommentVNode("", true),
          _cache[22] || (_cache[22] = createTextVNode()),
          createBaseVNode("div", _hoisted_11$h, [
            createBaseVNode("div", {
              class: "selected-market",
              "test-id": "selected-market",
              onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.toggleMarketsDropdown && $options.toggleMarketsDropdown(...args), ["stop"]))
            }, [
              createTextVNode(toDisplayString($options.activeMarket.name) + " ", 1),
              createVNode(_component_ArrowDownSVG, { class: "arrow-icon" })
            ])
          ]),
          _cache[23] || (_cache[23] = createTextVNode()),
          createBaseVNode("div", _hoisted_12$e, toDisplayString($options.summary.counterDisplay) + toDisplayString($options.summary.price), 1)
        ]),
        _cache[51] || (_cache[51] = createTextVNode()),
        createBaseVNode("div", _hoisted_13$e, [
          createBaseVNode("div", _hoisted_14$d, [
            createVNode(_component_swiper, {
              class: "market-data-slider",
              modules: $setup.modules,
              navigation: "",
              "resize-observer": "",
              "slides-per-view": "auto",
              "allow-touch-move": false
            }, {
              default: withCtx(() => [
                _cache[41] || (_cache[41] = createBaseVNode("div", { class: "market-data-slider__fader market-data-slider__fader--left" }, null, -1)),
                _cache[42] || (_cache[42] = createTextVNode()),
                _cache[43] || (_cache[43] = createBaseVNode("div", { class: "market-data-slider__fader market-data-slider__fader--right" }, null, -1)),
                _cache[44] || (_cache[44] = createTextVNode()),
                createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                  default: withCtx(() => [
                    _cache[24] || (_cache[24] = createBaseVNode("div", { class: "market-data__title" }, "\n                  24h Change\n                ", -1)),
                    _cache[25] || (_cache[25] = createTextVNode()),
                    createBaseVNode("div", {
                      class: normalizeClass(["market-data__item", $options.summary.changeClass])
                    }, toDisplayString($options.summary.last24), 3)
                  ]),
                  _: 1
                }),
                _cache[45] || (_cache[45] = createTextVNode()),
                $setup.activeMarketStore.isPerpetual ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                    default: withCtx(() => [
                      _cache[26] || (_cache[26] = createBaseVNode("div", { class: "market-data__title" }, "\n                    Mark price\n                  ", -1)),
                      _cache[27] || (_cache[27] = createTextVNode()),
                      createBaseVNode("div", _hoisted_15$d, toDisplayString($options.summary.markPrice), 1)
                    ]),
                    _: 1
                  }),
                  _cache[32] || (_cache[32] = createTextVNode()),
                  createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                    default: withCtx(() => [
                      _cache[28] || (_cache[28] = createBaseVNode("div", { class: "market-data__title" }, "\n                    Index price\n                  ", -1)),
                      _cache[29] || (_cache[29] = createTextVNode()),
                      createBaseVNode("div", _hoisted_16$c, toDisplayString($options.summary.indexPrice), 1)
                    ]),
                    _: 1
                  }),
                  _cache[33] || (_cache[33] = createTextVNode()),
                  createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                    default: withCtx(() => [
                      _cache[30] || (_cache[30] = createBaseVNode("div", { class: "market-data__title" }, "\n                    Funding\n                  ", -1)),
                      _cache[31] || (_cache[31] = createTextVNode()),
                      createBaseVNode("div", _hoisted_17$c, toDisplayString($options.summary.fundingPercentage), 1)
                    ]),
                    _: 1
                  })
                ], 64)) : createCommentVNode("", true),
                _cache[46] || (_cache[46] = createTextVNode()),
                createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                  default: withCtx(() => [
                    _cache[34] || (_cache[34] = createBaseVNode("div", { class: "market-data__title" }, "\n                  24h High\n                ", -1)),
                    _cache[35] || (_cache[35] = createTextVNode()),
                    createBaseVNode("div", _hoisted_18$b, toDisplayString($options.summary.high), 1)
                  ]),
                  _: 1
                }),
                _cache[47] || (_cache[47] = createTextVNode()),
                createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                  default: withCtx(() => [
                    _cache[36] || (_cache[36] = createBaseVNode("div", { class: "market-data__title" }, "\n                  24h Low\n                ", -1)),
                    _cache[37] || (_cache[37] = createTextVNode()),
                    createBaseVNode("div", _hoisted_19$9, toDisplayString($options.summary.low), 1)
                  ]),
                  _: 1
                }),
                _cache[48] || (_cache[48] = createTextVNode()),
                createVNode(_component_swiper_slide, { class: "market-data__column" }, {
                  default: withCtx(() => [
                    _cache[38] || (_cache[38] = createBaseVNode("div", { class: "market-data__title" }, "\n                  24h Volume\n                ", -1)),
                    _cache[39] || (_cache[39] = createTextVNode()),
                    createBaseVNode("div", _hoisted_20$9, toDisplayString($options.summary.baseVolume) + " " + toDisplayString($options.activeMarket.base), 1)
                  ]),
                  _: 1
                }),
                _cache[49] || (_cache[49] = createTextVNode()),
                $options.summary.preferredCurrencyVolume !== null ? (openBlock(), createBlock(_component_swiper_slide, {
                  key: 1,
                  class: "market-data__column"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_21$9, "\n                  24h Volume (" + toDisplayString($setup.preferredCurrencyStore.preferredCurrency) + ")\n                ", 1),
                    _cache[40] || (_cache[40] = createTextVNode()),
                    createBaseVNode("div", _hoisted_22$9, toDisplayString($options.summary.preferredCurrencyVolume) + " " + toDisplayString($setup.preferredCurrencyStore.preferredCurrency), 1)
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["modules"])
          ]),
          _cache[50] || (_cache[50] = createTextVNode()),
          $options.isAuthenticated && $setup.activeMarketStore.isPerpetual && $setup.subAccountStore.doesActiveAccountSupportDerivatives ? (openBlock(), createBlock(_component_MarginBalances, { key: 0 })) : createCommentVNode("", true)
        ]),
        _cache[52] || (_cache[52] = createTextVNode()),
        createVNode(Transition, { name: "appear-fast" }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_TradeviewMarketSelector, {
              "is-open": $options.isMarketsDropdownActive,
              onClose: $options.closeMarketsDropdown
            }, null, 8, ["is-open", "onClose"]), [
              [vShow, $options.isMarketsDropdownActive],
              [_directive_click_outside, $options.closeMarketsDropdown]
            ])
          ]),
          _: 1
        })
      ]),
      _cache[55] || (_cache[55] = createTextVNode()),
      createVNode(Transition, { name: "slide" }, {
        default: withCtx(() => [
          $data.isSideMenuOpen ? withDirectives((openBlock(), createElementBlock("div", _hoisted_23$7, [
            createVNode(_component_SideMenu, null, {
              default: withCtx(() => [
                $options.isAuthenticated ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($options.permittedNavigationLinks, (item) => {
                  return openBlock(), createBlock(_component_BtsLink, {
                    key: item.name,
                    to: $options.getPageUrl(item.link),
                    external: "",
                    class: normalizeClass([{ "header-menu__item--active": item.active }, "header-menu__item"])
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(item.name), 1)
                    ]),
                    _: 2
                  }, 1032, ["to", "class"]);
                }), 128)) : (openBlock(), createBlock(_component_AnonMenuLinks, {
                  key: 1,
                  "in-side-menu": "",
                  "hide-earn-links": $data.hideEarnLinks
                }, null, 8, ["hide-earn-links"]))
              ]),
              _: 1
            })
          ])), [
            [_directive_click_outside, $options.closeSideMenu]
          ]) : createCommentVNode("", true)
        ]),
        _: 1
      })
    ], 2),
    _cache[56] || (_cache[56] = createTextVNode()),
    $setup.subAccountStore.isCreateSubAccountModalOpen ? (openBlock(), createBlock(_component_ProCreateSubAccountModal, {
      key: 0,
      "initial-account-market-type": $options.initialSelectedMarketType,
      onSubAccountCreated: $options.onSubAccountCreated,
      onClose: $setup.subAccountStore.closeCreateSubAccountModal
    }, null, 8, ["initial-account-market-type", "onSubAccountCreated", "onClose"])) : createCommentVNode("", true),
    _cache[57] || (_cache[57] = createTextVNode()),
    $setup.subAccountStore.isTransferFundsModalOpen ? (openBlock(), createBlock(_component_SubAccountFundTransferModal, {
      key: 1,
      "new-account-created": $data.newSubAccountId !== null,
      "to-account-id": $options.subAccountToTransferTo,
      onClose: $options.closeSubAccountTransferModal
    }, null, 8, ["new-account-created", "to-account-id", "onClose"])) : createCommentVNode("", true)
  ]);
}
const __nuxt_component_0 = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$P], ["__scopeId", "data-v-70ce7c2b"]]);
const branchAttributionMixin = {
  mounted() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("_branch_match_id")) {
      this.$branch.lib.data((_2, response) => {
        if ((response == null ? void 0 : response.data_parsed["~campaign"]) && (response == null ? void 0 : response.data_parsed["~channel"]) && (response == null ? void 0 : response.data_parsed["~feature"]) && (response == null ? void 0 : response.data_parsed["~tags"])) {
          trackInteraction("[Branch] OPEN WEB", response.data_parsed);
        }
      });
    }
  }
};
const settlementBatchApi = {
  list(subAccountId) {
    const url = URLService.buildUrl("settlementGetPreparedBatchesResource", {
      user_id: "me",
      trade_account_unique_id: subAccountId
    });
    return axiosInstance.get(url).then((r) => r.data.data);
  },
  prepare(subAccountId) {
    const url = URLService.buildUrl("settlementPrepareBatchResource", {
      user_id: "me",
      trade_account_unique_id: subAccountId
    });
    return axiosInstance.post(url, {}, { noToastOnError: true }).then((r) => r.data.data);
  },
  settle(batchId) {
    const url = URLService.buildUrl("settlementSettleBatchResource", {
      user_id: "me",
      batch_uuid: batchId
    });
    return axiosInstance.post(url, {}, { noToastOnError: true }).then((r) => r.data.data);
  }
};
const storeName$d = "settlementBatchStore";
const useSettlementBatchStore = addStoreHooks(
  defineStore(storeName$d, () => {
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$d }));
    const { doesActiveAccountSupportPTS, activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$d }));
    const $errorTracking = useErrorTracking();
    const pollingStore = usePollingStore();
    let stopPollingFn = () => {
    };
    const preparedSettlementBatchId = ref(null);
    const initialized = ref(false);
    const isProcessing = ref(false);
    async function fetch() {
      var _a2;
      if (isProcessing.value || !isLoggedIn.value || !doesActiveAccountSupportPTS.value) {
        return;
      }
      isProcessing.value = true;
      try {
        const preparedBatches = await settlementBatchApi.list(activeSubAccountId.value);
        preparedSettlementBatchId.value = ((_a2 = preparedBatches == null ? void 0 : preparedBatches[0]) == null ? void 0 : _a2.uuid) ?? null;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
      isProcessing.value = false;
    }
    function startPolling() {
      if (!isLoggedIn.value) {
        return;
      }
      const { stop } = pollingStore.startPolling({
        id: timersConstants.POLLING_SETTLEMENT_BATCH.ID,
        interval: timersConstants.POLLING_SETTLEMENT_BATCH.TIME,
        fn: fetch
      });
      stopPollingFn = stop;
    }
    function stopPolling() {
      stopPollingFn();
      stopPollingFn = () => {
      };
    }
    function setPreparedSettlementBatchId(id) {
      preparedSettlementBatchId.value = id;
    }
    async function _init() {
      if (initialized.value || !isLoggedIn.value) {
        return;
      }
      if (doesActiveAccountSupportPTS.value) {
        startPolling();
        await fetch();
      }
      initialized.value = true;
      return () => {
        stopPolling();
      };
    }
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        preparedSettlementBatchId.value = null;
        stopPolling();
      }
    });
    watch(activeSubAccountId, async (newId, oldId) => {
      if (newId === oldId) {
        return;
      }
      preparedSettlementBatchId.value = null;
      if (doesActiveAccountSupportPTS.value) {
        startPolling();
        await fetch();
      } else {
        stopPolling();
      }
      initialized.value = true;
    });
    return {
      preparedSettlementBatchId,
      setPreparedSettlementBatchId,
      fetch,
      _init
    };
  })
);
function DeferMixin(count = 10) {
  return {
    data() {
      return {
        displayPriority: 0
      };
    },
    mounted() {
      this.runDisplayPriority();
    },
    methods: {
      runDisplayPriority() {
        const step = () => {
          requestAnimationFrame(() => {
            this.displayPriority++;
            if (this.displayPriority < count) {
              step();
            }
          });
        };
        step();
      },
      defer(priority) {
        return this.displayPriority >= priority;
      }
    }
  };
}
const _sfc_main$14 = {
  components: { AppTooltip },
  props: {
    isHeaderUnderlined: {
      type: Boolean,
      default: false
    },
    isHeaderVisible: {
      type: Boolean,
      default: true
    }
  }
};
const _hoisted_1$_ = { class: "widget widget-layout" };
const _hoisted_2$I = {
  key: 0,
  class: "title"
};
const _hoisted_3$F = {
  key: 1,
  class: "title title--tabs"
};
const _hoisted_4$y = {
  key: 2,
  class: "widget-layout__tabs-and-settings js-right-tabs-and-settings"
};
const _hoisted_5$s = {
  key: 0,
  ref: "tabs",
  class: "tabs"
};
const _hoisted_6$p = {
  key: 1,
  class: "settings"
};
const _hoisted_7$n = {
  key: 0,
  class: "settings__search"
};
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppTooltip = resolveComponent("AppTooltip");
  return openBlock(), createElementBlock("div", _hoisted_1$_, [
    $props.isHeaderVisible ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([{ "header--underline": $props.isHeaderUnderlined }, "header"])
    }, [
      _ctx.$slots.title ? (openBlock(), createElementBlock("span", _hoisted_2$I, [
        renderSlot(_ctx.$slots, "title", {}, void 0, true)
      ])) : createCommentVNode("", true),
      _cache[2] || (_cache[2] = createTextVNode()),
      renderSlot(_ctx.$slots, "icon", {}, void 0, true),
      _cache[3] || (_cache[3] = createTextVNode()),
      _ctx.$slots.titleTabs ? (openBlock(), createElementBlock("div", _hoisted_3$F, [
        renderSlot(_ctx.$slots, "titleTabs", {}, void 0, true)
      ])) : createCommentVNode("", true),
      _cache[4] || (_cache[4] = createTextVNode()),
      _ctx.$slots.tabs || _ctx.$slots.search || _ctx.$slots.settings ? (openBlock(), createElementBlock("div", _hoisted_4$y, [
        _ctx.$slots.tabs ? (openBlock(), createElementBlock("div", _hoisted_5$s, [
          renderSlot(_ctx.$slots, "tabs", {}, void 0, true)
        ], 512)) : createCommentVNode("", true),
        _cache[1] || (_cache[1] = createTextVNode()),
        _ctx.$slots.settings ? (openBlock(), createElementBlock("div", _hoisted_6$p, [
          _ctx.$slots.search ? (openBlock(), createElementBlock("div", _hoisted_7$n, [
            renderSlot(_ctx.$slots, "search", {}, void 0, true)
          ])) : createCommentVNode("", true),
          _cache[0] || (_cache[0] = createTextVNode()),
          createVNode(_component_AppTooltip, {
            icon: "monochrome/sliders.svg",
            "icon-size": 18,
            "max-width": 300,
            placement: "bottom",
            strategy: "fixed",
            type: "dropdown"
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "settings", {}, void 0, true)
            ]),
            _: 3
          })
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ], 2)) : createCommentVNode("", true),
    _cache[5] || (_cache[5] = createTextVNode()),
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
const WidgetLayout = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$O], ["__scopeId", "data-v-02856980"]]);
const _sfc_main$13 = {
  name: "OrderSlider",
  components: {
    VueSlider: F,
    AppTooltip
  },
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    value: {
      type: [String, Number],
      required: false,
      default: 0
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    sliderInterval: {
      type: Number,
      required: false,
      default: 1
    },
    tooltipFormatter: {
      type: [String, Function],
      required: false,
      default: void 0
    },
    // https://nightcatsama.github.io/vue-slider-component/#/basics/marks
    marks: {
      type: [Array, Function, Boolean, Object],
      required: false,
      default: false
    },
    disabledSectionSize: {
      type: Number,
      required: false,
      default: null
    },
    duration: {
      type: Number,
      required: false,
      default: 0
    },
    silent: {
      type: Boolean,
      default: false
    },
    hideLabel: {
      type: Boolean,
      required: false,
      default: true
    },
    // https://nightcatsama.github.io/vue-slider-component/#/api/props?hash=tooltip
    tooltip: {
      type: String,
      required: false,
      default: "active"
    },
    // This can be used to show the current pre-change value combined with custom marks
    preChangeMarkerValue: {
      type: Number,
      required: false,
      default: void 0
    }
  },
  emits: ["update:value"],
  data() {
    return {
      sliderValue: this.min
    };
  },
  computed: {
    hasDisabledSection() {
      return this.disabledSectionSize !== null;
    },
    disabledSectionStyle() {
      if (this.hasDisabledSection) {
        return `width: ${100 - this.disabledSectionSize}%`;
      }
      return void 0;
    },
    vueSliderWithDisabledSectionStyle() {
      if (this.hasDisabledSection) {
        return `width: ${this.disabledSectionSize}%`;
      }
      return void 0;
    }
  },
  watch: {
    value() {
      this.setSliderValue(this.value);
    },
    min() {
      if (this.sliderValue < this.min) {
        this.sliderValue = this.min;
      }
    },
    max() {
      if (this.sliderValue > this.max) {
        this.sliderValue = this.max;
      }
    }
  },
  created() {
    this.setSliderValue(this.value);
  },
  methods: {
    setSliderValue(value) {
      let candidate = parseFloat(`${value}`);
      if (typeof candidate !== "number" || Number.isNaN(candidate)) {
        return;
      }
      if (candidate < this.min) {
        candidate = this.min;
      }
      if (candidate > this.max) {
        candidate = this.max;
      }
      this.sliderValue = candidate;
    },
    onChange(e) {
      this.$emit("update:value", e);
    }
  }
};
const _hoisted_1$Z = ["data-test"];
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_slider = resolveComponent("vue-slider");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["order-slider", { "order-slider--has-disabled-section": $options.hasDisabledSection }])
  }, [
    createVNode(_component_vue_slider, {
      modelValue: $data.sliderValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.sliderValue = $event),
      disabled: $props.disabled,
      min: $props.min,
      max: $props.max,
      interval: $props.sliderInterval,
      tooltip: $props.tooltip,
      "tooltip-formatter": $props.tooltipFormatter,
      "dot-size": 10,
      height: 3,
      marks: $props.marks,
      duration: $props.duration,
      clickable: "",
      contained: "",
      "hide-label": $props.hideLabel,
      "drag-on-click": "",
      silent: $props.silent,
      style: normalizeStyle($options.vueSliderWithDisabledSectionStyle),
      onChange: $options.onChange
    }, createSlots({ _: 2 }, [
      $props.marks ? {
        name: "step",
        fn: withCtx(({ active, value: stepValue }) => [
          createBaseVNode("div", {
            "data-test": `orderSliderStep${stepValue}`,
            class: normalizeClass([
              `step step--${stepValue}`,
              {
                "step--active": active,
                "step--pre-change-marker": stepValue === `${$props.preChangeMarkerValue}`
              }
            ])
          }, null, 10, _hoisted_1$Z)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["modelValue", "disabled", "min", "max", "interval", "tooltip", "tooltip-formatter", "marks", "duration", "hide-label", "silent", "style", "onChange"]),
    _cache[3] || (_cache[3] = createTextVNode()),
    $options.hasDisabledSection ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "disabled-section",
      style: normalizeStyle($options.disabledSectionStyle)
    }, [
      createVNode(_component_AppTooltip, { class: "disabled-section__tooltip" }, {
        trigger: withCtx(() => _cache[1] || (_cache[1] = [
          createBaseVNode("div", { class: "disabled-section__trigger" }, [
            createBaseVNode("div", { class: "disabled-section__marker" })
          ], -1)
        ])),
        default: withCtx(() => [
          _cache[2] || (_cache[2] = createTextVNode()),
          renderSlot(_ctx.$slots, "disabled-section-label", {}, () => [
            createBaseVNode("p", null, toDisplayString(_ctx.$t("components.orderSlider.disabledSection")), 1)
          ], true)
        ]),
        _: 3
      })
    ], 4)) : createCommentVNode("", true)
  ], 2);
}
const OrderSlider = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$N], ["__scopeId", "data-v-9d511f4a"]]);
function parseMaxBuySell(data) {
  return {
    // We allow 1% less than what the API returns to allow for some flexibility, since we're only calling the endpoint
    // once per 5 seconds and by the time the order gets validated server side a lot can change.
    maxBuyAmount: toDecimal(data.maxBuy).mul("0.99"),
    maxSellAmount: toDecimal(data.maxSell).mul("0.99")
  };
}
const maxBuySellAPI = {
  /**
   * @param {number|'main'} account
   * @param {string} market
   * @param {string} orderType
   * @param {number} leverage
   * @param {string} marginMode
   * @param {module:numberUtils.Decimal} limitPrice - for any order that has a limit price
   * @param {module:numberUtils.Decimal} stopPrice - only for TAKE_PROFIT and STOP_LOSS types
   * @param {module:numberUtils.Decimal} activationPrice - for any TRAILING order
   * @param {module:numberUtils.Decimal} trailingDelta - for any TRAILING order
   * @return {Promise<{maxSellAmount: module:numberUtils.Decimal, maxBuyAmount: module:numberUtils.Decimal}>}
   */
  getMaxBuySell({
    account,
    market,
    orderType,
    leverage,
    marginMode,
    limitPrice,
    stopPrice,
    activationPrice,
    trailingDelta
  }) {
    const payload = {
      leverage,
      market,
      marginMode
    };
    payload.orderType = constants$1.ORDER_TYPE_CONFIG[orderType].enumName;
    if (limitPrice) {
      payload.price = limitPrice;
    }
    if (stopPrice) {
      payload.stopPrice = stopPrice;
    }
    if (activationPrice) {
      payload.activationPrice = activationPrice;
    }
    if (trailingDelta) {
      payload.trailingDelta = trailingDelta;
    }
    return axiosInstance.post(
      URLService.buildUrl("maxBuySellResource", {
        unique_id: account
      }),
      payload
    ).then((data) => {
      var _a2;
      return parseMaxBuySell((_a2 = data.data) == null ? void 0 : _a2.data);
    });
  }
};
function parseMarginImpact(data) {
  return toDecimal(data.marginImpact);
}
const marginImpactAPI = {
  /**
   * @param {number|'main'} account
   * @param {string} market
   * @param {string} orderType
   * @param {number} leverage
   * @param {string} marginMode
   * @param {string} orderSide
   * @param {module:numberUtils.Decimal} amount
   * @param {module:numberUtils.Decimal|null} price - only for limit orders
   * @return {Promise<module:numberUtils.Decimal>}
   */
  getMarginImpact({ account, market, orderType, leverage, marginMode, orderSide, amount, price = null }) {
    const payload = {
      leverage,
      market,
      marginMode,
      orderType,
      amount,
      orderSide
    };
    if (price) {
      payload.price = price;
    }
    return axiosInstance.post(
      URLService.buildUrl("marginImpactResource", {
        unique_id: account
      }),
      payload
    ).then((data) => {
      var _a2;
      return parseMarginImpact((_a2 = data.data) == null ? void 0 : _a2.data);
    });
  }
};
function parseSingleMarketMarginModeAndLeverageSettings(data) {
  const leverages = {};
  for (const { marginMode, leverage } of data.leverages) {
    leverages[marginMode] = leverage;
  }
  return {
    leverages,
    preferredMarginMode: data.preferredMarginMode,
    maxLeverage: data.maxLeverage
  };
}
function parsePreferredMarginModesPerMarket(data) {
  const marginModesPerMarket = {};
  for (const { marginMode, market } of data) {
    marginModesPerMarket[market] = marginMode;
  }
  return marginModesPerMarket;
}
const marginSettingsApi = {
  /**
   * Fetches Leverage settings for each Margin Mode and Preferred Margin Mode for market
   *
   * @param {string} market - btcusd-perp
   * @param {'main'|number} account - accountId
   * @returns {Promise<{leverages: Object<string,number>, preferredMarginMode: string}>}
   */
  getMarginModeAndLeverageSettingsForSingleMarket(market, account) {
    const url = URLService.buildUrl("marginSettingsResource", { unique_id: account, market });
    return axiosInstance.get(url).then((data) => {
      var _a2;
      return parseSingleMarketMarginModeAndLeverageSettings((_a2 = data.data) == null ? void 0 : _a2.data);
    });
  },
  /**
   * Fetches ONLY Preferred Margin Modes for all markets that use margin modes
   *
   * @param {'main'|number} account - accountId
   * @returns {Promise<Object.<string,string>>}
   */
  getMarginModeSettingsForAllMarkets(account) {
    const url = URLService.buildUrl("marginSettingsListResource", { unique_id: account });
    return axiosInstance.get(url).then((data) => {
      var _a2;
      return parsePreferredMarginModesPerMarket((_a2 = data.data) == null ? void 0 : _a2.data);
    });
  },
  /**
   * @param {string} marginMode
   * @param {string} market
   * @param {'main'|number} account
   * @param {boolean} [noToastOnError]
   * @returns {Promise<void>}
   */
  updatePreferredMarginModeForSingleMarket(marginMode, market, account, noToastOnError = false) {
    const url = URLService.buildUrl("marginSettingsResource", { unique_id: account, market });
    return axiosInstance.patch(url, { preferredMarginMode: marginMode }, { noToastOnError });
  },
  /**
   * @param {number} leverage
   * @param {string} marginMode
   * @param {string} market
   * @param {'main'|number} account
   * @param {boolean} [noToastOnError]
   * @returns {Promise<void>}
   */
  setLeverage(leverage, marginMode, market, account, noToastOnError = false) {
    const url = URLService.buildUrl("leverageSettingsResource", {
      unique_id: account,
      market,
      margin_mode: marginMode
    });
    return axiosInstance.patch(url, { leverage: `${leverage}` }, { noToastOnError });
  }
};
const storeName$c = "tradeviewMarginSettingsStore";
const useTradeviewMarginSettingsStore = addStoreHooks(
  defineStore(storeName$c, () => {
    const subAccountStore = useSubAccountStore({ caller: storeName$c });
    const activeMarketStore = useActiveMarketStore({ caller: storeName$c });
    const userStateStore = useUserStateStore({ caller: storeName$c });
    const $errorTracking = useErrorTracking();
    const leveragesPerMarginModeForActiveMarket = shallowRef({});
    const preferredMarginModes = shallowRef({});
    const areMarginSettingsAvailable = computed(() => {
      return activeMarginMode.value && activeLeverage.value;
    });
    const activeLeverage = computed(() => {
      return leveragesPerMarginModeForActiveMarket.value[activeMarginMode.value];
    });
    const activeMarginMode = computed(() => {
      return preferredMarginModes.value[activeMarketStore.activeMarketKey];
    });
    const canUseMargin = computed(() => {
      return userStateStore.isLoggedIn && activeMarketStore.isPerpetual && subAccountStore.doesActiveAccountSupportDerivatives;
    });
    async function fetchMarginSettingsForMarket() {
      if (!canUseMargin.value) {
        return;
      }
      try {
        const response = await marginSettingsApi.getMarginModeAndLeverageSettingsForSingleMarket(
          activeMarketStore.activeMarketKey,
          subAccountStore.activeSubAccountId,
          true
        );
        preferredMarginModes.value = {
          ...preferredMarginModes.value ?? {},
          [activeMarketStore.activeMarketKey]: response.preferredMarginMode
        };
        leveragesPerMarginModeForActiveMarket.value = response.leverages;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        leveragesPerMarginModeForActiveMarket.value = {};
      }
    }
    async function fetchPreferredMarginModes() {
      if (!canUseMargin.value) {
        return;
      }
      try {
        preferredMarginModes.value = await marginSettingsApi.getMarginModeSettingsForAllMarkets(
          subAccountStore.activeSubAccountId,
          true
        );
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    async function changePreferredMarginMode(marginMode) {
      if (!canUseMargin.value) {
        return false;
      }
      try {
        const marketKey = activeMarketStore.activeMarketKey;
        const subAccountIdBeforeCall = subAccountStore.activeSubAccountId;
        await marginSettingsApi.updatePreferredMarginModeForSingleMarket(
          marginMode,
          marketKey,
          subAccountStore.activeSubAccountId,
          true
        );
        if (subAccountIdBeforeCall === subAccountStore.activeSubAccountId) {
          preferredMarginModes.value = {
            ...preferredMarginModes.value,
            [marketKey]: marginMode
          };
        }
        return true;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        return false;
      }
    }
    async function setLeverage(leverage, marginMode, market, subAccountId) {
      try {
        await marginSettingsApi.setLeverage(leverage, marginMode, market, subAccountId, true);
        await fetchMarginSettingsForMarket();
        return true;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        return false;
      }
    }
    watchEffect(async () => {
      if (!activeMarketStore.activeMarketKey || !activeMarketStore.isPerpetual) {
        leveragesPerMarginModeForActiveMarket.value = {};
        return;
      }
      await fetchMarginSettingsForMarket();
    });
    return {
      preferredMarginModes,
      activeLeverage,
      activeMarginMode,
      areMarginSettingsAvailable,
      changePreferredMarginMode,
      fetchMarginSettingsForMarket,
      fetchPreferredMarginModes,
      setLeverage
    };
  })
);
const storeName$b = "tradeviewOrderFormStore";
const useTradeviewOrderFormStore = addStoreHooks(
  defineStore(storeName$b, () => {
    const tradeviewTickersStore = useTradeviewTickersStore({ caller: storeName$b });
    const subAccountStore = useSubAccountStore({ caller: storeName$b });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$b }));
    const activeMarketStore = useActiveMarketStore({ caller: storeName$b });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$b }));
    const { isHidden } = storeToRefs(useVisibilityStore({ caller: storeName$b }));
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$b }));
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore({ caller: storeName$b });
    const pollingStore = usePollingStore({ caller: storeName$b });
    const $errorTracking = useErrorTracking();
    const amount = ref(toDecimal("0"));
    const trailingDelta = ref(toDecimal("0"));
    const activationPrice = ref(toDecimal("0"));
    const limitPrice = ref(toDecimal("0"));
    const stopPrice = ref(toDecimal("0"));
    const maxBuyAmount = ref(toDecimal("0"));
    const maxSellAmount = ref(toDecimal("0"));
    const marginImpact = ref(toDecimal("0"));
    let stopPollingFetchMaxBuySellFn = () => {
    };
    const urlParams = new URLSearchParams(window.location.search);
    let urlParamsOrderSide = urlParams.get("side");
    if (![constants$1.ORDER_SIDE.BUY, constants$1.ORDER_SIDE.SELL].includes(urlParamsOrderSide)) {
      urlParamsOrderSide = null;
    }
    const orderFormValueToKeyMap = Object.fromEntries(
      Object.entries(constants$1.ORDER_FORM_TYPE).map((a) => a.reverse())
    );
    const urlParamsOrderFormType = orderFormValueToKeyMap[urlParams.get("type")] ? urlParams.get("type") : null;
    const activeOrderSideLocalStorage = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ORDER_FORM_ACTIVE_ORDER_SIDE,
      urlParamsOrderSide || constants$1.ORDER_SIDE.BUY,
      {
        listenToStorageChanges: false
      }
    );
    const activeOrderSide = ref(urlParamsOrderSide || activeOrderSideLocalStorage.value);
    const activeOrderFormLocalStorage = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ACTIVE_ORDER_FORM_TYPE,
      urlParamsOrderFormType || constants$1.ORDER_FORM_TYPE.LIMIT,
      {
        listenToStorageChanges: false
      }
    );
    const activeOrderFormType = ref(urlParamsOrderFormType || activeOrderFormLocalStorage.value);
    const activeOrderType = ref(null);
    const orderFormLeverages = useLocalStorage(localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ORDER_FORM_LEVERAGE, {});
    const prefill = ref({});
    const isOrderPlacementEnabled = ref(true);
    const activeMarginMode = computed(() => tradeviewMarginSettingsStore.activeMarginMode);
    const activeOrderFormLeverage = computed(() => {
      if (!activeMarketStore.isPerpetual) {
        return 1;
      }
      const key = leverageFormLocalStorageKey(
        activeMarketStore.activeMarketKey,
        activeMarginMode.value,
        subAccountStore.activeSubAccountId
      );
      return orderFormLeverages.value[key] ?? tradeviewMarginSettingsStore.activeLeverage;
    });
    const canFetchDerivativesOrderApis = computed(() => {
      return isLoggedIn.value && !activeMarketStore.isSpot && subAccountStore.doesActiveAccountSupportDerivatives && !isHidden.value && !!activeMarketStore.activeMarket;
    });
    const marginImpactComputed = computed(() => {
      if (isTakeProfitStopLossFormActive.value) {
        return toDecimal(0);
      }
      return marginImpact.value;
    });
    const isTakeProfitStopLossFormActive = computed(() => {
      return activeOrderFormType.value === constants$1.ORDER_FORM_TYPE.TPSL;
    });
    const maxOrderAmount = computed(() => {
      if (activeOrderSide.value === constants$1.ORDER_SIDE.BUY) {
        return maxBuyAmount.value;
      } else {
        return maxSellAmount.value;
      }
    });
    function setActiveOrderSide(side) {
      activeOrderSide.value = side;
      activeOrderSideLocalStorage.value = side;
    }
    function setActiveOrderFormType(type) {
      activeOrderFormType.value = type;
      activeOrderFormLocalStorage.value = type;
    }
    function setActiveOrderType(type) {
      activeOrderType.value = type;
    }
    function setPrefill(newPrefill = {}) {
      prefill.value = newPrefill;
    }
    function setOrderFormLeverage(market, marginMode, subAccountId, leverage) {
      orderFormLeverages.value = {
        ...orderFormLeverages.value,
        [leverageFormLocalStorageKey(market, marginMode, subAccountId)]: leverage
      };
    }
    function setIsOrderPlacementEnabled(newIsOrderPlacementEnabled = {}) {
      isOrderPlacementEnabled.value = newIsOrderPlacementEnabled;
    }
    const fetchMaxBuySell = _.throttle(async () => {
      if (!canFetchDerivativesOrderApis.value || !activeOrderFormLeverage.value || !activeMarginMode.value) {
        maxSellAmount.value = new Decimal(0);
        maxBuyAmount.value = new Decimal(0);
        return;
      }
      const payload = {
        account: subAccountStore.activeSubAccountId,
        market: activeMarketStore.activeMarketKey,
        orderType: activeOrderType.value,
        leverage: activeOrderFormLeverage.value,
        marginMode: activeMarginMode.value
      };
      const currentMarketPrice = tradeviewTickersStore.activeMarketTickerLastValue;
      if (constants$1.ORDER_TYPES_WITH_LIMIT_PRICE.includes(activeOrderType.value)) {
        payload.limitPrice = limitPrice.value.isPositive() ? limitPrice.value : currentMarketPrice;
      } else if (activeOrderType.value === constants$1.ORDER_TYPE.STOP_LOSS || activeOrderType.value === constants$1.ORDER_TYPE.TAKE_PROFIT) {
        payload.stopPrice = stopPrice.value.isPositive() ? stopPrice.value : currentMarketPrice;
      } else if (activeOrderType.value === constants$1.ORDER_TYPE.TRAILING_STOP_LOSS || activeOrderType.value === constants$1.ORDER_TYPE.TRAILING_TAKE_PROFIT) {
        payload.activationPrice = activationPrice.value.isPositive() ? activationPrice.value : currentMarketPrice;
        payload.trailingDelta = trailingDelta.value.isPositive() ? trailingDelta.value : new Decimal(1);
      }
      try {
        const orderTypePreFetch = activeOrderType.value;
        const data = await maxBuySellAPI.getMaxBuySell(payload);
        if (orderTypePreFetch !== activeOrderType.value) {
          return;
        }
        if (activeOrderType.value === constants$1.ORDER_TYPE.INSTANT || activeOrderType.value === constants$1.ORDER_TYPE.CASH) {
          const marketOffer = useOrderbook100Store().activeMarketCurrentOffer;
          if (marketOffer.ask.isZero()) {
            maxBuyAmount.value = new Decimal(0);
          } else {
            maxBuyAmount.value = data.maxBuyAmount.div(marketOffer.ask);
          }
          if (activeOrderType.value === constants$1.ORDER_TYPE.CASH) {
            if (marketOffer.bid.isZero()) {
              maxSellAmount.value = new Decimal(0);
            } else {
              maxSellAmount.value = data.maxSellAmount.div(marketOffer.bid);
            }
          } else {
            maxSellAmount.value = data.maxSellAmount;
          }
        } else {
          maxSellAmount.value = data.maxSellAmount;
          maxBuyAmount.value = data.maxBuyAmount;
        }
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }, timersConstants.THROTTLE_MAX_BUY_SELL);
    async function fetchMarginImpact() {
      const isLimitOrder = activeOrderFormType.value === constants$1.ORDER_FORM_TYPE.LIMIT;
      if (isTakeProfitStopLossFormActive.value || !canFetchDerivativesOrderApis.value || !activeOrderFormLeverage.value || !activeMarginMode.value || !amount.value.isPositive() || isLimitOrder && !limitPrice.value.isPositive()) {
        marginImpact.value = toDecimal("0");
        return;
      }
      try {
        const orderTypePreFetch = activeOrderType.value;
        const newMarginImpact = await marginImpactAPI.getMarginImpact({
          account: subAccountStore.activeSubAccountId,
          market: activeMarketStore.activeMarketKey,
          orderType: constants$1.ORDER_TYPE_CONFIG[activeOrderType.value].enumName,
          // TODO: Consolidate enum value buy/sell to enum name BUY/SELL
          orderSide: activeOrderSide.value.toUpperCase(),
          leverage: activeOrderFormLeverage.value,
          marginMode: activeMarginMode.value,
          amount: amount.value,
          price: isLimitOrder ? limitPrice.value : null
        });
        if (orderTypePreFetch === activeOrderType.value) {
          marginImpact.value = newMarginImpact;
        }
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    function startPollingFetchMaxBuySell() {
      if (!canFetchDerivativesOrderApis.value) {
        return;
      }
      const { stop: stopPollingFetchMaxBuySellFunction } = pollingStore.startPolling({
        interval: timersConstants.POLLING_MAX_BUY_SELL.TIME,
        id: timersConstants.POLLING_MAX_BUY_SELL.ID,
        fn: fetchMaxBuySell
      });
      stopPollingFetchMaxBuySellFn = stopPollingFetchMaxBuySellFunction;
    }
    function stopPollingFetchMaxBuySell() {
      stopPollingFetchMaxBuySellFn();
      stopPollingFetchMaxBuySellFn = () => {
      };
    }
    function setAmount(newValue) {
      amount.value = newValue;
    }
    function setLimitPrice(newValue) {
      limitPrice.value = newValue;
    }
    function setTrailingDelta(newValue) {
      trailingDelta.value = newValue;
    }
    function setStopPrice(newValue) {
      stopPrice.value = newValue;
    }
    function setActivationPrice(newValue) {
      activationPrice.value = newValue;
    }
    function resetFormValues() {
      amount.value = toDecimal("0");
      stopPrice.value = toDecimal("0");
      activationPrice.value = toDecimal("0");
      trailingDelta.value = toDecimal("0");
      limitPrice.value = toDecimal("0");
      maxSellAmount.value = toDecimal("0");
      maxBuyAmount.value = toDecimal("0");
      marginImpact.value = toDecimal("0");
    }
    function _init() {
      return () => {
        stopPollingFetchMaxBuySell();
      };
    }
    watch(activeSubAccountId, () => {
      resetFormValues();
    });
    watch(
      activeMarket,
      (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
          return;
        }
        resetFormValues();
        if (activeMarketStore.isPerpetual && !constants$1.PERP_ORDER_FORM_TYPES.includes(activeOrderFormType.value) || activeMarketStore.isSpot && !constants$1.SPOT_ORDER_FORM_TYPES.includes(activeOrderFormType.value)) {
          setActiveOrderFormType(constants$1.ORDER_FORM_TYPE.LIMIT);
        }
      },
      {
        deep: true
      }
    );
    watch(isHidden, (isNowHidden) => {
      if (isNowHidden) {
        stopPollingFetchMaxBuySell();
      } else {
        startPollingFetchMaxBuySell();
      }
    });
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        resetFormValues();
      }
    });
    watch(canFetchDerivativesOrderApis, (canFetchDerivatives) => {
      if (canFetchDerivatives) {
        startPollingFetchMaxBuySell();
      } else {
        stopPollingFetchMaxBuySell();
      }
    });
    watch(activeOrderType, () => {
      maxBuyAmount.value = toDecimal(0);
      maxSellAmount.value = toDecimal(0);
      fetchMaxBuySell();
    });
    watch([activeOrderFormLeverage, activeMarginMode], fetchMarginImpact);
    return {
      prefill,
      activeOrderFormType,
      activeOrderType,
      activeOrderSide,
      isOrderPlacementEnabled,
      limitPrice,
      maxBuyAmount,
      maxSellAmount,
      activeOrderFormLeverage,
      maxOrderAmount,
      marginImpact: marginImpactComputed,
      fetchMarginImpact,
      setActiveOrderSide,
      setActiveOrderFormType,
      setActiveOrderType,
      setPrefill,
      setIsOrderPlacementEnabled,
      setOrderFormLeverage,
      setAmount,
      setLimitPrice,
      setActivationPrice,
      setTrailingDelta,
      setStopPrice,
      _init
    };
  })
);
function leverageFormLocalStorageKey(market, marginMode, subAccountId) {
  return `${market}_${marginMode}_${subAccountId}`;
}
const _sfc_main$12 = {
  name: "ProceedOrderButton",
  props: {
    side: {
      type: String,
      required: true
    },
    disable: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: ["click"],
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      userStateStore: useUserStateStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore()
    };
  },
  computed: {
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    isDisabled() {
      return this.disable || !this.tradeviewOrderFormStore.isOrderPlacementEnabled || !this.userStateStore.canTrade || !this.$has("trade_orders_create");
    },
    buttonClass() {
      return {
        button: true,
        "button--buy": this.side === constants$1.ORDER_SIDE.BUY,
        "button--sell": this.side === constants$1.ORDER_SIDE.SELL,
        "button--in-progress": !this.tradeviewOrderFormStore.isOrderPlacementEnabled
      };
    },
    actionTitle() {
      if (this.activeMarketStore.isSpot) {
        return this.side === constants$1.ORDER_SIDE.BUY ? `Buy ${this.activeMarket.base}` : `Sell ${this.activeMarket.base}`;
      }
      return this.side === constants$1.ORDER_SIDE.BUY ? "Buy" : "Sell";
    }
  }
};
const _hoisted_1$Y = ["disabled"];
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: normalizeClass($options.buttonClass),
    disabled: $options.isDisabled,
    "data-test": "proceedOrderButton",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
  }, toDisplayString($options.actionTitle), 11, _hoisted_1$Y);
}
const ProceedOrderButton = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$M]]);
const _sfc_main$11 = {
  name: "LoginPlaceholder",
  setup() {
    return {
      activeMarketStore: useActiveMarketStore()
    };
  },
  data() {
    return {
      areUkWarningsActive: this.$constants.showVaspInvestmentRiskWarning ?? false
    };
  },
  computed: {
    registerUrl() {
      return URLService.getPageUrl("register");
    },
    loginUrl() {
      return URLService.getPageUrl(
        "login",
        {},
        true,
        {
          next: URLService.getPageUrl("proTrade", { market: this.activeMarketStore.activeMarket.key })
        }
      );
    }
  }
};
const _hoisted_1$X = {
  key: 0,
  class: "login-placeholder"
};
const _hoisted_2$H = ["href"];
const _hoisted_3$E = ["href"];
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return !$data.areUkWarningsActive ? (openBlock(), createElementBlock("div", _hoisted_1$X, [
    createBaseVNode("span", null, [
      createBaseVNode("a", {
        class: "login-placeholder__link",
        href: $options.loginUrl
      }, "\n        Log in\n      ", 8, _hoisted_2$H),
      _cache[0] || (_cache[0] = createTextVNode("\n      or\n      ")),
      createBaseVNode("a", {
        class: "login-placeholder__link",
        href: $options.registerUrl
      }, "\n        Register\n      ", 8, _hoisted_3$E),
      _cache[1] || (_cache[1] = createTextVNode("\n      to start.\n    "))
    ])
  ])) : createCommentVNode("", true);
}
const LoginPlaceholder = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$L], ["__scopeId", "data-v-c9821d6f"]]);
const storeName$a = "tradeviewOpenPositionsStore";
const useTradeviewOpenPositionsStore = addStoreHooks(
  defineStore(storeName$a, () => {
    const openPositionsStore = useOpenPositionsStore({ caller: storeName$a });
    const { openPositions, formattedOpenPositions } = storeToRefs(useOpenPositionsStore({ caller: storeName$a }));
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$a }));
    const activeMarketStore = useActiveMarketStore({ caller: storeName$a });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$a }));
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore({ caller: storeName$a });
    const $errorTracking = useErrorTracking();
    const pollingStore = usePollingStore({ caller: storeName$a });
    const subAccountStore = useSubAccountStore({ caller: storeName$a });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$a }));
    let stopPollingFn = () => {
    };
    let isPollingEnabled = false;
    let isAggressivePollingEnabled = false;
    const hasOpenPositionsForActiveMarketAndMarginMode = computed(() => {
      if (!activeMarketStore.isPerpetual) {
        return false;
      }
      return openPositionForActiveMarketAndMarginMode.value !== null;
    });
    const openPositionForActiveMarketAndMarginMode = computed(() => {
      return openPositionsStore.openPositions.filter(
        (p) => p.market === activeMarketStore.activeMarketKey && p.marginMode === tradeviewMarginSettingsStore.activeMarginMode
      )[0] ?? null;
    });
    const openPositionsForActiveMarket = computed(() => {
      return openPositionsStore.openPositions.filter((p) => p.market === activeMarketStore.activeMarketKey);
    });
    async function fetchOpenPositions() {
      if (!PAGE_CONTEXT.derivativesEnabled || !isLoggedIn.value || activeMarketStore.isSpot || !subAccountStore.doesActiveAccountSupportDerivatives) {
        return;
      }
      try {
        const positions = await openPositionsStore.fetchOpenPositions(activeSubAccountId.value, true);
        const shouldPollAggressively = positions.length > 0;
        if (shouldPollAggressively !== isAggressivePollingEnabled) {
          startPolling(shouldPollAggressively);
        }
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    function stopPolling() {
      stopPollingFn();
      stopPollingFn = () => {
      };
      isPollingEnabled = false;
    }
    function startPolling(aggressive = false) {
      isPollingEnabled = true;
      isAggressivePollingEnabled = aggressive;
      stopPolling();
      const { stop } = pollingStore.startPolling({
        id: constants$2.TIMERS.POLLING_DERIVATIVES_OPEN_POSITIONS.ID,
        interval: aggressive ? constants$2.TIMERS.POLLING_DERIVATIVES_OPEN_POSITIONS.AGGRESSIVE_TIME : constants$2.TIMERS.POLLING_DERIVATIVES_OPEN_POSITIONS.TIME,
        fn: fetchOpenPositions
      });
      stopPollingFn = stop;
    }
    async function _init() {
      if (!PAGE_CONTEXT.derivativesEnabled || !isLoggedIn.value || !subAccountStore.doesActiveAccountSupportDerivatives) {
        return () => {
          stopPolling();
        };
      }
      if (activeMarketStore.activeMarket && activeMarketStore.isPerpetual) {
        await fetchOpenPositions();
        startPolling(openPositionsStore.openPositions.length > 0);
      }
      return () => {
        stopPolling();
      };
    }
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        stopPolling();
        openPositionsStore.clearOpenPositions();
      }
    });
    watch(
      activeMarket,
      async (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key) || !isLoggedIn.value) {
          return;
        }
        if (activeMarketStore.isSpot) {
          stopPolling();
          return;
        }
        if (isPollingEnabled) {
          return;
        }
        await fetchOpenPositions();
        startPolling(openPositionsStore.openPositions.length > 0);
      },
      {
        deep: true
      }
    );
    watch(activeSubAccountId, async (newId, oldId) => {
      if (newId !== oldId) {
        openPositionsStore.clearOpenPositions();
        stopPolling();
        if (!activeMarketStore.isSpot && subAccountStore.doesActiveAccountSupportDerivatives) {
          await fetchOpenPositions();
          startPolling(openPositionsStore.openPositions.length > 0);
        }
      }
    });
    return {
      openPositions,
      formattedOpenPositions,
      openPositionsForActiveMarket,
      openPositionForActiveMarketAndMarginMode,
      hasOpenPositionsForActiveMarketAndMarginMode,
      _init,
      startPolling,
      fetchOpenPositions
    };
  })
);
const _sfc_main$10 = {
  name: "TradingConditionsContract",
  setup() {
    return {
      currenciesStore: useCurrenciesStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradeviewMarginInfoStore: useTradeviewMarginInfoStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore()
    };
  },
  computed: {
    /** @type {module:positions.OpenPosition|null} */
    isolatedPositionForMarket() {
      return this.tradeviewOpenPositionsStore.openPositionsForActiveMarket.filter((p) => p.marginMode === constants$1.MARGIN_MODE.ISOLATED)[0] ?? null;
    },
    isolatedIMr() {
      if (this.isolatedPositionForMarket === null) {
        return "0.00";
      }
      if (this.isolatedPositionForMarket.initialMarginRatio === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: this.isolatedPositionForMarket.initialMarginRatio.mul(100),
        decimals: 2
      })}%`;
    },
    isolatedMMr() {
      if (this.isolatedPositionForMarket === null) {
        return "0.00";
      }
      if (this.isolatedPositionForMarket.maintenanceMarginRatio === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: this.isolatedPositionForMarket.maintenanceMarginRatio.mul(100),
        decimals: 2
      })}%`;
    },
    accountIMr() {
      var _a2;
      if (this.tradeviewMarginInfoStore.accountImRatio === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: ((_a2 = this.tradeviewMarginInfoStore.accountImRatio) == null ? void 0 : _a2.mul(100)) ?? 0,
        decimals: 2
      })}%`;
    },
    accountMMr() {
      var _a2;
      if (this.tradeviewMarginInfoStore.accountMmRatio === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: ((_a2 = this.tradeviewMarginInfoStore.accountMmRatio) == null ? void 0 : _a2.mul(100)) ?? 0,
        decimals: 2
      })}%`;
    },
    /** @type module:markets.Market */
    market() {
      return this.activeMarketStore.activeMarket;
    },
    fundingPercentage() {
      var _a2;
      const ticker = this.tradeviewTickersStore.activeMarketTicker;
      return ticker ? `${numberFormatter.decimal({
        value: ((_a2 = ticker.fundingRate) == null ? void 0 : _a2.mul(100)) ?? new Decimal(0),
        decimals: 4
      })}% @ ${getNextFundingFormattedDate(this.activeMarketStore.activeMarket.fundingInterval)}` : "/";
    },
    formattedContractSize() {
      return !this.market.contractSize ? "/" : `${numberFormatter.decimal({
        value: this.market.contractSize,
        smartStripTrailingZeros: true
      })} ${this.market.base}`;
    },
    tickSize() {
      return new Decimal(10).pow(-1 * this.market.decimals.counter).toFixed();
    },
    minOrderAmount() {
      return !this.market.minOrderAmount ? "-" : numberFormatter.price({
        value: this.market.minOrderAmount,
        decimals: this.market.decimals.base,
        currencyCode: this.market.base
      });
    },
    maxOrderAmount() {
      return !this.market.maxOrderAmount ? "-" : numberFormatter.price({
        value: this.market.maxOrderAmount,
        decimals: this.market.decimals.base,
        currencyCode: this.market.base
      });
    },
    minOrderValue() {
      return !this.market.minOrderValue ? "-" : numberFormatter.price({
        value: this.market.minOrderValue,
        decimals: this.market.decimals.counter,
        currencyCode: this.market.counter
      });
    },
    maxOrderValue() {
      return !this.market.maxOrderValue ? "-" : numberFormatter.price({
        value: this.market.maxOrderValue,
        decimals: this.market.decimals.counter,
        currencyCode: this.market.counter
      });
    },
    marketData() {
      const ticker = this.tradeviewTickersStore.activeMarketTicker;
      const counterDecimals = this.market.decimals.counter;
      const counterCurrency = this.currenciesStore.getCurrency(this.market.counter);
      return {
        counter: counterCurrency.code,
        indexPrice: ticker.indexPrice ? numberFormatter.price({
          value: ticker.indexPrice,
          decimals: counterDecimals,
          currencyCode: counterCurrency.code,
          currencySymbol: counterCurrency.symbol
        }) : "/",
        markPrice: ticker.markPrice ? numberFormatter.price({
          value: ticker.markPrice,
          decimals: counterDecimals,
          currencyCode: counterCurrency.code,
          currencySymbol: counterCurrency.symbol
        }) : "/"
      };
    }
  }
};
const _hoisted_1$W = { class: "tc" };
const _hoisted_2$G = { class: "tc__row" };
const _hoisted_3$D = { class: "tc__row" };
const _hoisted_4$x = { class: "tc__row" };
const _hoisted_5$r = { class: "tc__row" };
const _hoisted_6$o = { class: "tc__row" };
const _hoisted_7$m = { class: "tc__row" };
const _hoisted_8$m = { class: "tc__row" };
const _hoisted_9$h = { class: "tc__row" };
const _hoisted_10$h = { class: "tc__row" };
const _hoisted_11$g = { class: "tc__row" };
const _hoisted_12$d = { class: "tc__row" };
const _hoisted_13$d = { class: "tc__row" };
const _hoisted_14$c = { class: "tc__row" };
const _hoisted_15$c = { class: "tc__row" };
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$W, [
    _cache[28] || (_cache[28] = createBaseVNode("div", { class: "tc__row tc__row--title" }, [
      createBaseVNode("div", { class: "tc__title" }, "\n        Margin\n      ")
    ], -1)),
    _cache[29] || (_cache[29] = createTextVNode()),
    createBaseVNode("div", _hoisted_2$G, [
      _cache[0] || (_cache[0] = createBaseVNode("label", null, "Isolated initial", -1)),
      _cache[1] || (_cache[1] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.isolatedIMr), 1)
    ]),
    _cache[30] || (_cache[30] = createTextVNode()),
    createBaseVNode("div", _hoisted_3$D, [
      _cache[2] || (_cache[2] = createBaseVNode("label", null, "Isolated maintenance", -1)),
      _cache[3] || (_cache[3] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.isolatedMMr), 1)
    ]),
    _cache[31] || (_cache[31] = createTextVNode()),
    createBaseVNode("div", _hoisted_4$x, [
      _cache[4] || (_cache[4] = createBaseVNode("label", null, "Cross initial", -1)),
      _cache[5] || (_cache[5] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.accountIMr), 1)
    ]),
    _cache[32] || (_cache[32] = createTextVNode()),
    createBaseVNode("div", _hoisted_5$r, [
      _cache[6] || (_cache[6] = createBaseVNode("label", null, "Cross maintenance", -1)),
      _cache[7] || (_cache[7] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.accountMMr), 1)
    ]),
    _cache[33] || (_cache[33] = createTextVNode()),
    _cache[34] || (_cache[34] = createBaseVNode("div", { class: "tc__row tc__row--title" }, [
      createBaseVNode("div", { class: "tc__title" }, "\n        Market\n      ")
    ], -1)),
    _cache[35] || (_cache[35] = createTextVNode()),
    createBaseVNode("div", _hoisted_6$o, [
      _cache[8] || (_cache[8] = createBaseVNode("label", null, "Symbol", -1)),
      _cache[9] || (_cache[9] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.market.name), 1)
    ]),
    _cache[36] || (_cache[36] = createTextVNode()),
    createBaseVNode("div", _hoisted_7$m, [
      _cache[10] || (_cache[10] = createBaseVNode("label", null, "Quote currency", -1)),
      _cache[11] || (_cache[11] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.market.counter), 1)
    ]),
    _cache[37] || (_cache[37] = createStaticVNode(' <div class="tc__row" data-v-ebe5a96e><label data-v-ebe5a96e>Exchange</label> <span data-v-ebe5a96e>Bitstamp</span></div> <div class="tc__row" data-v-ebe5a96e><label data-v-ebe5a96e>Short selling</label> <span data-v-ebe5a96e>Yes</span></div> <div class="tc__row" data-v-ebe5a96e><label data-v-ebe5a96e>Order types</label> <span data-v-ebe5a96e>Market, Limit, Stop Loss, Take Profit</span></div> ', 7)),
    createBaseVNode("div", _hoisted_8$m, [
      _cache[12] || (_cache[12] = createBaseVNode("label", null, "Underlying asset", -1)),
      _cache[13] || (_cache[13] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.market.underlyingAsset), 1)
    ]),
    _cache[38] || (_cache[38] = createTextVNode()),
    createBaseVNode("div", _hoisted_9$h, [
      _cache[14] || (_cache[14] = createBaseVNode("label", null, "Mark price", -1)),
      _cache[15] || (_cache[15] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.marketData.markPrice), 1)
    ]),
    _cache[39] || (_cache[39] = createTextVNode()),
    createBaseVNode("div", _hoisted_10$h, [
      _cache[16] || (_cache[16] = createBaseVNode("label", null, "Index price", -1)),
      _cache[17] || (_cache[17] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.marketData.indexPrice), 1)
    ]),
    _cache[40] || (_cache[40] = createTextVNode()),
    createBaseVNode("div", _hoisted_11$g, [
      _cache[18] || (_cache[18] = createBaseVNode("label", null, "Contract type", -1)),
      _cache[19] || (_cache[19] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.market.payoffType), 1)
    ]),
    _cache[41] || (_cache[41] = createTextVNode()),
    createBaseVNode("div", _hoisted_12$d, [
      _cache[20] || (_cache[20] = createBaseVNode("label", null, "Contract size", -1)),
      _cache[21] || (_cache[21] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.formattedContractSize), 1)
    ]),
    _cache[42] || (_cache[42] = createTextVNode()),
    createBaseVNode("div", _hoisted_13$d, [
      _cache[22] || (_cache[22] = createBaseVNode("label", null, "Tick size", -1)),
      _cache[23] || (_cache[23] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.tickSize) + " " + toDisplayString($options.market.counter), 1)
    ]),
    _cache[43] || (_cache[43] = createTextVNode()),
    createBaseVNode("div", _hoisted_14$c, [
      _cache[24] || (_cache[24] = createBaseVNode("label", null, "Min order size / value", -1)),
      _cache[25] || (_cache[25] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.minOrderAmount) + " / " + toDisplayString($options.minOrderValue), 1)
    ]),
    _cache[44] || (_cache[44] = createTextVNode()),
    createBaseVNode("div", _hoisted_15$c, [
      _cache[26] || (_cache[26] = createBaseVNode("label", null, "Max order size / value", -1)),
      _cache[27] || (_cache[27] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.maxOrderAmount) + " / " + toDisplayString($options.maxOrderValue), 1)
    ]),
    _cache[45] || (_cache[45] = createStaticVNode(' <div class="tc__row" data-v-ebe5a96e><label data-v-ebe5a96e>Funding settlement time</label> <span data-v-ebe5a96e>00:00, 08:00 and 16:00 UTC every day</span></div> <div class="tc__row" data-v-ebe5a96e><label data-v-ebe5a96e>Periodic settlement time</label> <span data-v-ebe5a96e>15min</span></div> <div class="tc__row" data-v-ebe5a96e><label data-v-ebe5a96e>Risk limit</label> <span data-v-ebe5a96e>For details, please refer to the <a href="/faq/" target="_blank" data-v-ebe5a96e>Risk Limit page</a></span></div>', 6))
  ]);
}
const TradingConditionsContract = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$K], ["__scopeId", "data-v-ebe5a96e"]]);
const settlementCurrencyApi = {
  get(counterCurrency, account) {
    const url = URLService.buildUrl("settlementCurrencyResource", {
      unique_id: account,
      counter_currency: counterCurrency.toLowerCase()
    });
    return axiosInstance.get(url).then((data) => {
      var _a2;
      return (_a2 = data.data) == null ? void 0 : _a2.data;
    });
  },
  set(counterCurrency, settlementCurrency, account, noToastOnError = false) {
    const url = URLService.buildUrl("settlementCurrencyResource", {
      unique_id: account,
      counter_currency: counterCurrency.toLowerCase()
    });
    return axiosInstance.patch(url, { settlementCurrency }, { noToastOnError });
  }
};
const storeName$9 = "tradeviewSettlementCurrencyStore";
const useTradeviewSettlementCurrencyStore = addStoreHooks(
  defineStore("tradeviewSettlementCurrencyStore", () => {
    const subAccountStore = useSubAccountStore({ caller: storeName$9 });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$9 }));
    const activeMarketStore = useActiveMarketStore({ caller: storeName$9 });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$9 }));
    const userStateStore = useUserStateStore({ caller: storeName$9 });
    const $errorTracking = useErrorTracking();
    const activeSettlementCurrency = ref(null);
    const availableSettlementCurrencies = shallowRef([]);
    const canFetch = computed(() => {
      return userStateStore.isLoggedIn && activeMarketStore.isPerpetual && subAccountStore.doesActiveAccountSupportDerivatives;
    });
    async function fetch() {
      if (!canFetch.value) {
        return;
      }
      try {
        const { availableCurrencies, settlementCurrency } = await settlementCurrencyApi.get(
          activeMarketStore.activeMarket.counter,
          subAccountStore.activeSubAccountId,
          true
        );
        activeSettlementCurrency.value = settlementCurrency;
        availableSettlementCurrencies.value = [availableCurrencies[0]];
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    async function setSettlementCurrency(counterCurrency, settlementCurrency) {
      try {
        await settlementCurrencyApi.set(counterCurrency, settlementCurrency, subAccountStore.activeSubAccountId, true);
        activeSettlementCurrency.value = settlementCurrency;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        return false;
      }
      return true;
    }
    function _init() {
      fetch();
    }
    function clear() {
      activeSettlementCurrency.value = null;
      availableSettlementCurrencies.value = [];
    }
    watch(activeSubAccountId, () => {
      clear();
      fetch();
    });
    watch(
      activeMarket,
      (newMarket, oldMarket) => {
        if ((newMarket == null ? void 0 : newMarket.key) === (oldMarket == null ? void 0 : oldMarket.key) || (oldMarket == null ? void 0 : oldMarket.type) === marketConstants.MARKET_TYPES.PERPETUAL && (newMarket == null ? void 0 : newMarket.counter) === (oldMarket == null ? void 0 : oldMarket.counter)) {
          return;
        }
        clear();
        fetch();
      },
      {
        deep: true
      }
    );
    return {
      availableSettlementCurrencies,
      activeSettlementCurrency,
      _init,
      fetch,
      setSettlementCurrency
    };
  })
);
const _hoisted_1$V = ["title"];
const _hoisted_2$F = ["for"];
const _hoisted_3$C = ["id", "name", "disabled", "test-id"];
const _hoisted_4$w = ["for"];
const _hoisted_5$q = { class: "actions-and-errors" };
const _hoisted_6$n = {
  key: 0,
  class: "input-actions"
};
const _hoisted_7$l = {
  key: 1,
  class: "input-actions__action input-actions__action--estimate",
  "data-test": "estimate"
};
const _hoisted_8$l = {
  key: 1,
  class: "error",
  "data-test": "validationErrorText"
};
const _sfc_main$$ = {
  __name: "OrderInputWithValidation",
  props: /* @__PURE__ */ mergeModels({
    // input id
    field: {
      type: String,
      required: true
    },
    label: {
      type: String,
      required: false,
      default: void 0
    },
    inlineLabel: {
      type: String,
      required: false,
      default: void 0
    },
    errorLabel: {
      type: String,
      required: false,
      default: void 0
    },
    testId: {
      type: String,
      required: false,
      default: void 0
    },
    showPriceFillButton: {
      type: Boolean,
      required: false,
      default: false
    },
    priceFillButtonText: {
      type: String,
      required: false,
      default: void 0
    },
    titleTooltip: {
      type: String,
      required: false,
      default: void 0
    },
    estimate: {
      type: String,
      required: false,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    // This is a used when we do "validation" outside this component.
    customErrorMessage: {
      type: String,
      required: false,
      default: void 0
    }
  }, {
    "modelValue": { type: String },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:value", "focus", "blur", "input", "priceFillRequested"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const model = useModel(__props, "modelValue");
    const props = __props;
    const labelForErrors = computed(() => {
      return props.errorLabel || props.field;
    });
    const { value, errorMessage, meta, resetField } = useField(() => props.field, null, {
      label: labelForErrors.value
    });
    watch(model, (newValue) => value.value = newValue);
    const displayedErrorMessage = computed(() => {
      return props.customErrorMessage || errorMessage.value;
    });
    watch(value, (newValue) => {
      if (!newValue) {
        if (newValue === void 0 && !meta.dirty) {
          newValue = "";
        }
        emit("input", newValue);
        model.value = newValue;
        return;
      }
      const v = `${newValue}`.replace(",", ".").replace(/[.](?=.*[.])/g, "");
      if (newValue !== v) {
        value.value = v;
      } else {
        emit("input", newValue);
        model.value = newValue;
      }
    });
    function onFocus() {
      emit("focus");
    }
    function onBlur() {
      if (value.value === "") {
        resetField();
      }
      emit("blur");
    }
    function onPriceFill() {
      emit("priceFillRequested");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["order-input", { "order-input--disabled": props.disabled }]),
        title: props.titleTooltip
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["order-input__wrapper", {
            "order-input__wrapper--error": !props.disabled && displayedErrorMessage.value && unref(meta).dirty,
            "order-input__wrapper--disabled": props.disabled
          }])
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            props.label ? (openBlock(), createElementBlock("label", {
              key: 0,
              for: props.field,
              class: "order-input__label order-input__label--dark"
            }, toDisplayString(props.label), 9, _hoisted_2$F)) : createCommentVNode("", true)
          ], true),
          _cache[1] || (_cache[1] = createTextVNode()),
          withDirectives(createBaseVNode("input", {
            id: props.field,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(value) ? value.value = $event : null),
            name: props.field,
            disabled: props.disabled,
            "test-id": props.testId,
            class: normalizeClass([{ "input--disabled": props.disabled }, "input"]),
            type: "text",
            autocomplete: "off",
            "data-test": "textInput",
            onFocus,
            onBlur
          }, null, 42, _hoisted_3$C), [
            [vModelText, unref(value)]
          ]),
          _cache[2] || (_cache[2] = createTextVNode()),
          createBaseVNode("label", {
            for: props.field,
            class: "order-input__label"
          }, toDisplayString(props.inlineLabel), 9, _hoisted_4$w)
        ], 2),
        _cache[4] || (_cache[4] = createTextVNode()),
        createBaseVNode("div", _hoisted_5$q, [
          props.showPriceFillButton || props.estimate ? (openBlock(), createElementBlock("div", _hoisted_6$n, [
            props.showPriceFillButton ? (openBlock(), createElementBlock("div", {
              key: 0,
              title: "Fill price input with best order book offer",
              class: "input-actions__action input-action__action--clickable",
              "data-test": "spotPrice",
              onClick: onPriceFill
            }, toDisplayString(props.priceFillButtonText), 1)) : props.estimate ? (openBlock(), createElementBlock("div", _hoisted_7$l, toDisplayString(props.estimate), 1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          _cache[3] || (_cache[3] = createTextVNode()),
          !props.disabled && displayedErrorMessage.value && unref(meta).dirty ? (openBlock(), createElementBlock("span", _hoisted_8$l, toDisplayString(displayedErrorMessage.value) + ".\n      ", 1)) : createCommentVNode("", true)
        ])
      ], 10, _hoisted_1$V);
    };
  }
};
const OrderInputWithValidation = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__scopeId", "data-v-c1156034"]]);
const _hoisted_1$U = { class: "tc" };
const _hoisted_2$E = { class: "tc__row" };
const _hoisted_3$B = { class: "tc__row" };
const _hoisted_4$v = { class: "tc__row tc__row--title tc__row--no-padding-bottom" };
const _hoisted_5$p = { class: "tc__title text--center" };
const _hoisted_6$m = { class: "cost-table" };
const _hoisted_7$k = { class: "text--right" };
const _hoisted_8$k = { class: "text--right" };
const _hoisted_9$g = { class: "text--right" };
const _hoisted_10$g = { class: "text--right" };
const _hoisted_11$f = { class: "text--right" };
const _hoisted_12$c = { class: "tc__label" };
const _hoisted_13$c = { class: "text--right" };
const _hoisted_14$b = { class: "text--right" };
const _hoisted_15$b = { class: "text--right" };
const _hoisted_16$b = { class: "text--right" };
const _hoisted_17$b = { class: "text--right" };
const _hoisted_18$a = { class: "tc__label" };
const _hoisted_19$8 = { class: "text--right" };
const _hoisted_20$8 = { class: "text--right" };
const _hoisted_21$8 = { class: "text--right" };
const _hoisted_22$8 = { class: "text--right" };
const _hoisted_23$6 = { class: "text--right" };
const _hoisted_24$6 = { class: "text--right" };
const _hoisted_25$5 = {
  key: 0,
  class: "tc__row tc__row--no-border"
};
const _hoisted_26$4 = { class: "tc__details" };
const ONE_DAY = 3;
const _sfc_main$_ = {
  __name: "TradingConditionsCosts",
  setup(__props) {
    const activeMarketStore = useActiveMarketStore();
    const currenciesStore = useCurrenciesStore();
    const orderbook100Store = useOrderbook100Store();
    const tradeviewTickersStore = useTradeviewTickersStore();
    const feeScheduleStore = useFeeScheduleStore();
    const tradeviewSettlementCurrencyStore = useTradeviewSettlementCurrencyStore();
    const amount = ref("1000");
    const settlementCurrency = computed(() => {
      return tradeviewSettlementCurrencyStore.activeSettlementCurrency ?? currenciesConstants.CURRENCY_USD;
    });
    const holdingPeriod = ref(90);
    const HOLDING_PERIOD_OPTIONS = [
      { value: ONE_DAY, text: "1 day" },
      { value: ONE_DAY * 7, text: "1 week" },
      { value: ONE_DAY * 14, text: "2 weeks" },
      { value: ONE_DAY * 30, text: "1 month" },
      { value: ONE_DAY * 30 * 3, text: "3 months" },
      { value: ONE_DAY * 30 * 6, text: "6 months" },
      { value: ONE_DAY * 365, text: "1 year" },
      { value: ONE_DAY * 365 * 3, text: "3 years" },
      { value: ONE_DAY * 365 * 5, text: "5 years" }
    ];
    const validationSchema = computed(() => {
      return {
        amount: {
          required: true,
          decimal: { decimals: activeMarketStore.activeMarket.decimals.counter },
          max_value: 1e10
        }
      };
    });
    const { meta } = useForm({ validationSchema });
    const formattedPrice = computed(() => {
      const price = tradeviewTickersStore.activeMarketTickerLastValue;
      if (!price) {
        return "";
      }
      return numberFormatter.decimal({
        value: price,
        decimals: activeMarketStore.activeMarket.decimals.counter
      });
    });
    const spread = computed(() => {
      const bestAskPrice = orderbook100Store.activeMarketCurrentOffer.ask;
      const bestBidPrice = orderbook100Store.activeMarketCurrentOffer.bid;
      if (!bestAskPrice || !bestBidPrice || bestAskPrice.isZero()) {
        return null;
      }
      return bestAskPrice.sub(bestBidPrice);
    });
    const formattedSpread = computed(() => {
      if (spread.value === null) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: spread.value,
        decimals: activeMarketStore.activeMarket.decimals.counter
      })} ${activeMarketStore.activeMarket.counter}`;
    });
    const longAndShortCalculations = computed(() => {
      var _a2;
      let decimalAmount = toDecimal(amount.value);
      const decimals = ((_a2 = currenciesStore.getCurrency(settlementCurrency.value)) == null ? void 0 : _a2.decimals) ?? 2;
      const price = tradeviewTickersStore.activeMarketTickerLastValue;
      if (!decimalAmount.isPositive()) {
        decimalAmount = toDecimal(1e-8);
      }
      if (!meta.value.valid) {
        decimalAmount = toDecimal(0);
      }
      if (!price || spread.value === null) {
        return [];
      }
      const value = decimalAmount.mul(price);
      const tradingFeeCost = feeScheduleStore.takerRate.mul(value);
      const formattedTradingFeeCost = numberFormatter.decimal({
        value: tradingFeeCost,
        decimals
      });
      const spreadCost = spread.value.mul(decimalAmount).mul(2);
      const formattedSpreadCost = numberFormatter.decimal({
        value: spreadCost,
        decimals
      });
      const totalServiceCost = tradingFeeCost.mul(2).add(spreadCost);
      const spreadCostPercentage = !totalServiceCost.isZero() ? spreadCost.div(totalServiceCost).todp(4).mul(100) : new Decimal(0);
      const formattedTotalServiceCost = numberFormatter.decimal({
        value: totalServiceCost,
        decimals
      });
      const totalServiceCostPercentage = feeScheduleStore.takerFee.mul(2).add(spreadCostPercentage);
      const longFundingRate = new Decimal("0.0001");
      const longFundingCost = value.mul(longFundingRate).mul(holdingPeriod.value);
      const formattedLongFundingCost = numberFormatter.decimal({
        value: longFundingCost,
        decimals
      });
      const longFundingCostPercentage = longFundingRate.mul(holdingPeriod.value).mul(100);
      const formattedLongTotal = numberFormatter.decimal({
        value: totalServiceCost.add(longFundingCost),
        decimals
      });
      const longTotalPercentage = totalServiceCostPercentage.add(longFundingCostPercentage);
      const shortFundingRate = new Decimal("-0.0001");
      const shortFundingCost = value.mul(shortFundingRate).mul(holdingPeriod.value);
      const formattedShortFundingCost = numberFormatter.decimal({
        value: shortFundingCost,
        decimals
      });
      const shortFundingCostPercentage = shortFundingRate.mul(holdingPeriod.value).mul(100);
      const formattedShortTotal = numberFormatter.decimal({
        value: totalServiceCost.add(shortFundingCost),
        decimals
      });
      const shortTotalPercentage = totalServiceCostPercentage.add(shortFundingCostPercentage);
      const calculations = [];
      for (const direction of ["LONG", "SHORT"]) {
        calculations.push({
          direction,
          formattedTradingFeeCost,
          formattedSpreadCost,
          spreadCostPercentage,
          formattedTotalServiceCost,
          totalServiceCostPercentage,
          fundingRate: direction === "LONG" ? longFundingRate.mul(100) : shortFundingRate.mul(100),
          formattedFundingCost: direction === "LONG" ? formattedLongFundingCost : formattedShortFundingCost,
          fundingCostPercentage: direction === "LONG" ? longFundingCostPercentage : shortFundingCostPercentage,
          formattedTotal: direction === "LONG" ? formattedLongTotal : formattedShortTotal,
          totalPercentage: direction === "LONG" ? longTotalPercentage : shortTotalPercentage
        });
      }
      return calculations;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$U, [
        _cache[44] || (_cache[44] = createBaseVNode("div", { class: "tc__row tc__row--no-border" }, [
          createBaseVNode("p", null, "\n        Cost calculator shows the estimated costs for holding a long or short position in the selected market over a\n        specified holding period.\n      ")
        ], -1)),
        _cache[45] || (_cache[45] = createTextVNode()),
        createBaseVNode("div", _hoisted_2$E, [
          _cache[2] || (_cache[2] = createBaseVNode("label", { class: "tc__label" }, "Amount", -1)),
          _cache[3] || (_cache[3] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: amount.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => amount.value = $event),
            "inline-label": unref(activeMarketStore).activeMarket.base,
            field: "amount",
            class: "amount-input"
          }, null, 8, ["modelValue", "inline-label"])
        ]),
        _cache[46] || (_cache[46] = createTextVNode()),
        createBaseVNode("div", _hoisted_3$B, [
          _cache[4] || (_cache[4] = createBaseVNode("label", { class: "tc__label" }, "Holding period", -1)),
          _cache[5] || (_cache[5] = createTextVNode()),
          createVNode(unref(DropdownSelector), {
            value: holdingPeriod.value,
            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => holdingPeriod.value = $event),
            options: HOLDING_PERIOD_OPTIONS,
            class: "period-dropdown"
          }, null, 8, ["value"])
        ]),
        _cache[47] || (_cache[47] = createTextVNode()),
        (openBlock(true), createElementBlock(Fragment, null, renderList(longAndShortCalculations.value, (calc) => {
          return openBlock(), createElementBlock("div", {
            key: calc.direction
          }, [
            createBaseVNode("div", _hoisted_4$v, [
              createBaseVNode("div", _hoisted_5$p, [
                createBaseVNode("strong", null, toDisplayString(calc.direction) + " Positions", 1)
              ])
            ]),
            _cache[43] || (_cache[43] = createTextVNode()),
            createBaseVNode("table", _hoisted_6$m, [
              createBaseVNode("tbody", null, [
                createBaseVNode("tr", null, [
                  _cache[6] || (_cache[6] = createBaseVNode("th", { class: "text--left" }, [
                    createTextVNode("\n              Investment service costs\n              "),
                    createBaseVNode("br"),
                    createTextVNode("Transaction costs\n            ")
                  ], -1)),
                  _cache[7] || (_cache[7] = createTextVNode()),
                  createBaseVNode("th", _hoisted_7$k, "\n              Cost (" + toDisplayString(settlementCurrency.value) + ")\n            ", 1),
                  _cache[8] || (_cache[8] = createTextVNode()),
                  _cache[9] || (_cache[9] = createBaseVNode("th", { class: "text--right" }, "\n              %\n            ", -1))
                ]),
                _cache[35] || (_cache[35] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[10] || (_cache[10] = createBaseVNode("td", null, [
                    createBaseVNode("label", { class: "tc__label" }, "Trading fee (open)"),
                    createTextVNode(),
                    createBaseVNode("br"),
                    createBaseVNode("label", { class: "tc__label" }, "(Taker rate*)")
                  ], -1)),
                  _cache[11] || (_cache[11] = createTextVNode()),
                  createBaseVNode("td", _hoisted_8$k, toDisplayString(calc.formattedTradingFeeCost), 1),
                  _cache[12] || (_cache[12] = createTextVNode()),
                  createBaseVNode("td", _hoisted_9$g, toDisplayString(unref(feeScheduleStore).takerFee) + "%\n            ", 1)
                ]),
                _cache[36] || (_cache[36] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[13] || (_cache[13] = createBaseVNode("td", null, [
                    createBaseVNode("label", { class: "tc__label" }, "Trading fee (close)"),
                    createTextVNode(),
                    createBaseVNode("br"),
                    createBaseVNode("label", { class: "tc__label" }, "(Taker rate*)")
                  ], -1)),
                  _cache[14] || (_cache[14] = createTextVNode()),
                  createBaseVNode("td", _hoisted_10$g, toDisplayString(calc.formattedTradingFeeCost), 1),
                  _cache[15] || (_cache[15] = createTextVNode()),
                  createBaseVNode("td", _hoisted_11$f, toDisplayString(unref(feeScheduleStore).takerFee) + "%\n            ", 1)
                ]),
                _cache[37] || (_cache[37] = createTextVNode()),
                createBaseVNode("tr", null, [
                  createBaseVNode("td", null, [
                    createBaseVNode("label", _hoisted_12$c, "Spread** (" + toDisplayString(formattedSpread.value) + ")", 1)
                  ]),
                  _cache[16] || (_cache[16] = createTextVNode()),
                  createBaseVNode("td", _hoisted_13$c, toDisplayString(calc.formattedSpreadCost), 1),
                  _cache[17] || (_cache[17] = createTextVNode()),
                  createBaseVNode("td", _hoisted_14$b, toDisplayString(calc.spreadCostPercentage) + "%\n            ", 1)
                ]),
                _cache[38] || (_cache[38] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[18] || (_cache[18] = createBaseVNode("td", null, [
                    createBaseVNode("label", { class: "tc__label" }, "Total service cost")
                  ], -1)),
                  _cache[19] || (_cache[19] = createTextVNode()),
                  createBaseVNode("td", _hoisted_15$b, toDisplayString(calc.formattedTotalServiceCost), 1),
                  _cache[20] || (_cache[20] = createTextVNode()),
                  createBaseVNode("td", _hoisted_16$b, toDisplayString(calc.totalServiceCostPercentage) + "%\n            ", 1)
                ]),
                _cache[39] || (_cache[39] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[21] || (_cache[21] = createBaseVNode("th", { class: "text--left" }, [
                    createTextVNode("\n              Financial instrument costs\n              "),
                    createBaseVNode("br"),
                    createTextVNode("Ongoing charges\n            ")
                  ], -1)),
                  _cache[22] || (_cache[22] = createTextVNode()),
                  createBaseVNode("th", _hoisted_17$b, "\n              Cost (" + toDisplayString(settlementCurrency.value) + ")\n            ", 1),
                  _cache[23] || (_cache[23] = createTextVNode()),
                  _cache[24] || (_cache[24] = createBaseVNode("th", { class: "text--right" }, "\n              %\n            ", -1))
                ]),
                _cache[40] || (_cache[40] = createTextVNode()),
                createBaseVNode("tr", null, [
                  createBaseVNode("td", null, [
                    _cache[25] || (_cache[25] = createBaseVNode("label", { class: "tc__label" }, "Funding rate***", -1)),
                    _cache[26] || (_cache[26] = createTextVNode()),
                    _cache[27] || (_cache[27] = createBaseVNode("br", null, null, -1)),
                    createBaseVNode("label", _hoisted_18$a, "(" + toDisplayString(calc.fundingRate) + "% per settlement period, 8h)", 1)
                  ]),
                  _cache[28] || (_cache[28] = createTextVNode()),
                  createBaseVNode("td", _hoisted_19$8, toDisplayString(calc.formattedFundingCost), 1),
                  _cache[29] || (_cache[29] = createTextVNode()),
                  createBaseVNode("td", _hoisted_20$8, toDisplayString(calc.fundingCostPercentage) + "%\n            ", 1)
                ]),
                _cache[41] || (_cache[41] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[30] || (_cache[30] = createBaseVNode("td", null, [
                    createBaseVNode("label", { class: "tc__label" }, "Total financial instrument costs")
                  ], -1)),
                  _cache[31] || (_cache[31] = createTextVNode()),
                  createBaseVNode("td", _hoisted_21$8, toDisplayString(calc.formattedFundingCost), 1),
                  _cache[32] || (_cache[32] = createTextVNode()),
                  createBaseVNode("td", _hoisted_22$8, toDisplayString(calc.fundingCostPercentage) + "%\n            ", 1)
                ]),
                _cache[42] || (_cache[42] = createTextVNode()),
                createBaseVNode("tr", null, [
                  createBaseVNode("td", null, [
                    createBaseVNode("strong", null, "Total (" + toDisplayString(calc.direction) + ")", 1)
                  ]),
                  _cache[33] || (_cache[33] = createTextVNode()),
                  createBaseVNode("td", _hoisted_23$6, toDisplayString(calc.formattedTotal), 1),
                  _cache[34] || (_cache[34] = createTextVNode()),
                  createBaseVNode("td", _hoisted_24$6, toDisplayString(calc.totalPercentage) + "%\n            ", 1)
                ])
              ])
            ])
          ]);
        }), 128)),
        _cache[48] || (_cache[48] = createStaticVNode(' <div class="tc__row tc__row--title" data-v-6cdca436><div class="tc__title" data-v-6cdca436>\n        Assumptions\n      </div></div> <div class="tc__row tc__row--no-border" data-v-6cdca436><p class="tc__details" data-v-6cdca436>\n        Includes both open and close costs\n      </p></div> <div class="tc__row tc__row--no-border" data-v-6cdca436><p class="tc__details" data-v-6cdca436>\n        Open and close price are the same (P/L=0%)\n      </p></div> ', 7)),
        formattedPrice.value ? (openBlock(), createElementBlock("div", _hoisted_25$5, [
          createBaseVNode("p", _hoisted_26$4, "\n        Based on the last trade price of " + toDisplayString(formattedPrice.value) + " " + toDisplayString(unref(activeMarketStore).activeMarket.counter) + ".\n      ", 1)
        ])) : createCommentVNode("", true),
        _cache[49] || (_cache[49] = createStaticVNode(' <div class="tc__row tc__row--no-border" data-v-6cdca436><p class="tc__details" data-v-6cdca436>\n        Extra costs, like potential liquidation fee, are excluded\n      </p></div> <div class="tc__row tc__row--no-border" data-v-6cdca436><p class="tc__details" data-v-6cdca436>\n        * Based on fee for immediately filled orders (Taker). The fee might differ when an order is filled at a later time (Maker).\n      </p></div> <div class="tc__row tc__row--no-border" data-v-6cdca436><p class="tc__details" data-v-6cdca436>\n        ** Implicit cost embedded into the price of the instrument. Not charged to your account.\n      </p></div> <div class="tc__row tc__row--no-border" data-v-6cdca436><p class="tc__details" data-v-6cdca436>\n        *** Based on a 0.01% funding rate.\n        Please note the actual funding rate will fluctuate throughout the holding period.\n        In a stagnant market, the funding rate tends to default to 0%.\n        In a bullish market, the funding rate is typically positive, meaning long positions must pay the funding charge,\n        while short positions receive it.\n        Conversely, in a bearish market, the funding rate tends to be negative, resulting in long positions receiving the funding\n        charge and short positions having to pay it.\n      </p></div>', 8))
      ]);
    };
  }
};
const TradingConditionsCosts = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__scopeId", "data-v-6cdca436"]]);
const _sfc_main$Z = {
  name: "TradingConditionsRates",
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      feeScheduleStore: useFeeScheduleStore(),
      orderBook100Store: useOrderbook100Store()
    };
  },
  computed: {
    fees() {
      return {
        maker: this.feeScheduleStore.makerFee,
        taker: this.feeScheduleStore.takerFee
      };
    },
    formattedSpread() {
      const bestAskPrice = this.orderBook100Store.activeMarketCurrentOffer.ask;
      const bestBidPrice = this.orderBook100Store.activeMarketCurrentOffer.bid;
      if (!bestAskPrice || !bestBidPrice || bestAskPrice.isZero()) {
        return "n/a";
      }
      return `${numberFormatter.decimal({
        value: bestAskPrice.sub(bestBidPrice),
        decimals: this.activeMarketStore.activeMarket.decimals.counter
      })} ${this.activeMarketStore.activeMarket.counter}`;
    },
    fundingPercentage() {
      var _a2;
      const ticker = this.tradeviewTickersStore.activeMarketTicker;
      return ticker ? `${numberFormatter.decimal({
        value: ((_a2 = ticker.fundingRate) == null ? void 0 : _a2.mul(100)) ?? new Decimal(0),
        decimals: 4
      })}% @ ${getNextFundingFormattedDate(this.activeMarketStore.activeMarket.fundingInterval)}` : "/";
    },
    feeScheduleUrl() {
      return URLService.getPageUrl("fee_schedule");
    }
  }
};
const _hoisted_1$T = { class: "tc" };
const _hoisted_2$D = { class: "tc__row" };
const _hoisted_3$A = { class: "tc__row" };
const _hoisted_4$u = { class: "tc__row" };
const _hoisted_5$o = ["href"];
const _hoisted_6$l = { class: "tc__row" };
const _hoisted_7$j = ["href"];
const _hoisted_8$j = { class: "tc__row" };
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$T, [
    _cache[12] || (_cache[12] = createBaseVNode("div", { class: "tc__row tc__row--title" }, [
      createBaseVNode("div", { class: "tc__title" }, "\n        Investment service costs > transaction costs\n      ")
    ], -1)),
    _cache[13] || (_cache[13] = createTextVNode()),
    createBaseVNode("div", _hoisted_2$D, [
      _cache[0] || (_cache[0] = createBaseVNode("label", null, "Commission (maker/taker)", -1)),
      _cache[1] || (_cache[1] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.fees.maker) + "% / " + toDisplayString($options.fees.taker) + "%", 1)
    ]),
    _cache[14] || (_cache[14] = createTextVNode()),
    createBaseVNode("div", _hoisted_3$A, [
      _cache[2] || (_cache[2] = createBaseVNode("label", null, "Spread cost*", -1)),
      _cache[3] || (_cache[3] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.formattedSpread), 1)
    ]),
    _cache[15] || (_cache[15] = createTextVNode()),
    createBaseVNode("div", _hoisted_4$u, [
      _cache[5] || (_cache[5] = createBaseVNode("label", null, "Liquidation fee", -1)),
      _cache[6] || (_cache[6] = createTextVNode()),
      createBaseVNode("span", null, [
        _cache[4] || (_cache[4] = createTextVNode("Please refer to our ")),
        createBaseVNode("a", {
          href: $options.feeScheduleUrl,
          target: "_blank"
        }, "fee schedule", 8, _hoisted_5$o)
      ])
    ]),
    _cache[16] || (_cache[16] = createTextVNode()),
    createBaseVNode("div", _hoisted_6$l, [
      _cache[8] || (_cache[8] = createBaseVNode("label", null, "Close-out fee", -1)),
      _cache[9] || (_cache[9] = createTextVNode()),
      createBaseVNode("span", null, [
        _cache[7] || (_cache[7] = createTextVNode("Please refer to our ")),
        createBaseVNode("a", {
          href: $options.feeScheduleUrl,
          target: "_blank"
        }, "fee schedule", 8, _hoisted_7$j)
      ])
    ]),
    _cache[17] || (_cache[17] = createTextVNode()),
    _cache[18] || (_cache[18] = createBaseVNode("div", { class: "tc__row tc__row--title" }, [
      createBaseVNode("div", { class: "tc__title" }, "\n        Financial instrument costs > ongoing charges\n      ")
    ], -1)),
    _cache[19] || (_cache[19] = createTextVNode()),
    createBaseVNode("div", _hoisted_8$j, [
      _cache[10] || (_cache[10] = createBaseVNode("label", null, "Funding rate**", -1)),
      _cache[11] || (_cache[11] = createTextVNode()),
      createBaseVNode("span", null, toDisplayString($options.fundingPercentage), 1)
    ]),
    _cache[20] || (_cache[20] = createStaticVNode(' <div class="tc__row tc__row--title" data-v-17fb4654><div class="tc__title" data-v-17fb4654>\n        Assumptions\n      </div></div> <div class="tc__row tc__row--no-border" data-v-17fb4654><p class="tc__details" data-v-17fb4654>\n        * Implicit cost embedded into the price of the instrument. Not charged to your account.\n      </p></div> <div class="tc__row tc__row--no-border" data-v-17fb4654><p class="tc__details" data-v-17fb4654>\n        ** Indicates the cost/credit rate for the next settlement period, which occurs every 8 hours. The funding rate may\n        either be credited or debited, depending on market conditions and your position.\n        In a stagnant market, the funding rate tends to default to 0%.\n        In a bullish market, the funding rate is typically positive, meaning long positions must pay the funding charge,\n        while short positions receive it.\n        Conversely, in a bearish market, the funding rate tends to be negative, resulting in long positions receiving the funding\n        charge and short positions having to pay it.\n        Note that the actual funding rate will fluctuate throughout the holding period.\n      </p></div>', 6))
  ]);
}
const TradingConditionsRates = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$J], ["__scopeId", "data-v-17fb4654"]]);
const _sfc_main$Y = {
  name: "TradingConditionsModal",
  components: {
    CurrencyIcon,
    TradingConditionsRates,
    TradingConditionsCosts,
    TradingConditionsContract,
    TabSelector,
    TradeviewModal
  },
  props: {
    isOpen: {
      type: Boolean,
      default: false
    },
    initialTab: {
      type: String,
      default: "contract"
    }
  },
  emits: ["close"],
  setup() {
    return {
      currenciesStore: useCurrenciesStore(),
      activeMarketStore: useActiveMarketStore()
    };
  },
  data() {
    return {
      activeTabId: this.initialTab
    };
  },
  computed: {
    tabs() {
      return [
        { id: "costs", text: "Costs" },
        { id: "rates", text: "Trading rates" },
        { id: "contract", text: "Contract" }
      ];
    }
  },
  methods: {
    onTabChange(tabId) {
      this.activeTabId = tabId;
    },
    closeModal() {
      this.$emit("close", this.activeTabId);
    }
  }
};
const _hoisted_1$S = { class: "market-info" };
const _hoisted_2$C = { class: "flex flex--direction-column" };
const _hoisted_3$z = { class: "tab-selector-wrapper" };
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CurrencyIcon = resolveComponent("CurrencyIcon");
  const _component_TabSelector = resolveComponent("TabSelector");
  const _component_TradingConditionsCosts = resolveComponent("TradingConditionsCosts");
  const _component_TradingConditionsRates = resolveComponent("TradingConditionsRates");
  const _component_TradingConditionsContract = resolveComponent("TradingConditionsContract");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createBlock(_component_TradeviewModal, {
    "is-open": $props.isOpen,
    "cancel-text": "Close",
    "x-scroll-disable": false,
    "onUpdate:isOpen": $options.closeModal,
    onClose: $options.closeModal
  }, {
    title: withCtx(() => _cache[0] || (_cache[0] = [
      createTextVNode("\n      Trading conditions\n    ")
    ])),
    body: withCtx(() => [
      createBaseVNode("div", _hoisted_1$S, [
        createVNode(_component_CurrencyIcon, {
          currency: $setup.activeMarketStore.activeMarket.base,
          size: "24"
        }, null, 8, ["currency"]),
        _cache[2] || (_cache[2] = createTextVNode()),
        createBaseVNode("div", _hoisted_2$C, [
          createTextVNode(toDisplayString($setup.activeMarketStore.activeMarket.name) + " ", 1),
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "market-info__details" }, [
            createBaseVNode("span", { title: "Exchange" }, "Bitstamp"),
            createTextVNode(" / "),
            createBaseVNode("span", { title: "Market type" }, "Perpetual"),
            createTextVNode(" / "),
            createBaseVNode("span", { title: "Quote currency" }, "USD")
          ], -1))
        ])
      ]),
      _cache[5] || (_cache[5] = createTextVNode()),
      createBaseVNode("div", _hoisted_3$z, [
        createVNode(_component_TabSelector, {
          tabs: $options.tabs,
          "active-tab-id": $data.activeTabId,
          onActivatedTab: $options.onTabChange
        }, null, 8, ["tabs", "active-tab-id", "onActivatedTab"])
      ]),
      _cache[6] || (_cache[6] = createTextVNode()),
      $props.isOpen ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        withDirectives(createVNode(_component_TradingConditionsCosts, null, null, 512), [
          [vShow, $data.activeTabId === "costs"]
        ]),
        _cache[3] || (_cache[3] = createTextVNode()),
        withDirectives(createVNode(_component_TradingConditionsRates, null, null, 512), [
          [vShow, $data.activeTabId === "rates"]
        ]),
        _cache[4] || (_cache[4] = createTextVNode()),
        withDirectives(createVNode(_component_TradingConditionsContract, null, null, 512), [
          [vShow, $data.activeTabId === "contract"]
        ])
      ], 64)) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["is-open", "onUpdate:isOpen", "onClose"]);
}
const TradingConditionsModal = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$I], ["__scopeId", "data-v-a5f67feb"]]);
const _sfc_main$X = {
  name: "DerivativesContractDetails",
  components: {
    AccordionGroup,
    AccordionItem,
    TradingConditionsModal
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      currenciesStore: useCurrenciesStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      areContractDetailsExpanded: useLocalStorage(
        localStorageConstants.LOCAL_STORAGE.TRADEVIEW_CONTRACT_DETAILS_EXPANDED,
        true
      ),
      userStateStore: useUserStateStore()
    };
  },
  data() {
    return {
      isContractDetailsModalOpen: false,
      activeTradingConditionsTab: "contract"
    };
  },
  computed: {
    areTriggersVisible() {
      return this.userStateStore.isLoggedIn && this.userStateStore.isVerified;
    },
    /** @type module:markets.Market */
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    tickSize() {
      return new Decimal(10).pow(-1 * this.activeMarket.decimals.counter).toFixed();
    },
    marketData() {
      const ticker = this.tradeviewTickersStore.activeMarketTicker;
      const counterDecimals = this.activeMarket.decimals.counter;
      const counterCurrency = this.currenciesStore.getCurrency(this.activeMarket.counter);
      return {
        counter: counterCurrency.code,
        indexPrice: ticker.indexPrice ? numberFormatter.price({
          value: ticker.indexPrice,
          decimals: counterDecimals,
          currencyCode: counterCurrency.code,
          currencySymbol: counterCurrency.symbol
        }) : "/",
        markPrice: ticker.markPrice ? numberFormatter.price({
          value: ticker.markPrice,
          decimals: counterDecimals,
          currencyCode: counterCurrency.code,
          currencySymbol: counterCurrency.symbol
        }) : "/"
      };
    },
    minOrderAmount() {
      return !this.activeMarket.minOrderAmount ? "/" : numberFormatter.price({
        value: this.activeMarket.minOrderAmount,
        decimals: this.activeMarket.decimals.base,
        currencyCode: this.activeMarket.base
      });
    },
    maxOrderAmount() {
      return !this.activeMarket.maxOrderAmount ? "/" : numberFormatter.price({
        value: this.activeMarket.maxOrderAmount,
        decimals: this.activeMarket.decimals.base,
        currencyCode: this.activeMarket.base
      });
    }
  },
  methods: {
    onModalClose(activeTradingConditionsTab) {
      this.isContractDetailsModalOpen = false;
      this.activeTradingConditionsTab = activeTradingConditionsTab;
    },
    openContractDetailsModal(activeTab) {
      this.activeTradingConditionsTab = activeTab;
      this.isContractDetailsModalOpen = true;
    },
    setContractDetailsExpandedState(activeItemId) {
      this.areContractDetailsExpanded = Boolean(activeItemId);
    }
  }
};
const _hoisted_1$R = { class: "info-section" };
const _hoisted_2$B = { class: "info-section__item" };
const _hoisted_3$y = { "test-id": "contract-details__index-price" };
const _hoisted_4$t = { class: "info-section__item" };
const _hoisted_5$n = { "test-id": "contract-details__mark-price" };
const _hoisted_6$k = { class: "info-section__item" };
const _hoisted_7$i = { "test-id": "contract-details__quote" };
const _hoisted_8$i = { class: "info-section__item" };
const _hoisted_9$f = { "test-id": "contract-details__tick-size" };
const _hoisted_10$f = { class: "info-section__item" };
const _hoisted_11$e = { "test-id": "contract-details__min-order-size" };
const _hoisted_12$b = { class: "info-section__item" };
const _hoisted_13$b = { "test-id": "contract-details__max-order-size" };
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AccordionItem = resolveComponent("AccordionItem");
  const _component_AccordionGroup = resolveComponent("AccordionGroup");
  const _component_TradingConditionsModal = resolveComponent("TradingConditionsModal");
  return openBlock(), createElementBlock("div", null, [
    $options.areTriggersVisible ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "trigger mt4",
      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $options.openContractDetailsModal("rates"), ["stop"]))
    }, "\n      Trading rates\n    ")) : createCommentVNode("", true),
    _cache[20] || (_cache[20] = createTextVNode()),
    createVNode(_component_AccordionGroup, {
      class: "contract-details",
      onActiveItemChange: $options.setContractDetailsExpandedState
    }, {
      default: withCtx(({ activeItem, setActiveItem }) => [
        createVNode(_component_AccordionItem, {
          title: "Contract details",
          "use-right-arrow": "",
          "is-initial-active": $setup.areContractDetailsExpanded,
          "active-item": activeItem,
          "set-active-item": setActiveItem
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$R, [
              createBaseVNode("div", _hoisted_2$B, [
                _cache[2] || (_cache[2] = createBaseVNode("span", { class: "label" }, "Index price", -1)),
                _cache[3] || (_cache[3] = createTextVNode()),
                createBaseVNode("span", _hoisted_3$y, toDisplayString($options.marketData.indexPrice), 1)
              ]),
              _cache[14] || (_cache[14] = createTextVNode()),
              createBaseVNode("div", _hoisted_4$t, [
                _cache[4] || (_cache[4] = createBaseVNode("span", { class: "label" }, "Mark price", -1)),
                _cache[5] || (_cache[5] = createTextVNode()),
                createBaseVNode("span", _hoisted_5$n, toDisplayString($options.marketData.markPrice), 1)
              ]),
              _cache[15] || (_cache[15] = createTextVNode()),
              createBaseVNode("div", _hoisted_6$k, [
                _cache[6] || (_cache[6] = createBaseVNode("span", { class: "label" }, "Quote currency", -1)),
                _cache[7] || (_cache[7] = createTextVNode()),
                createBaseVNode("span", _hoisted_7$i, toDisplayString($options.marketData.counter), 1)
              ]),
              _cache[16] || (_cache[16] = createTextVNode()),
              createBaseVNode("div", _hoisted_8$i, [
                _cache[8] || (_cache[8] = createBaseVNode("span", { class: "label" }, "Tick size", -1)),
                _cache[9] || (_cache[9] = createTextVNode()),
                createBaseVNode("span", _hoisted_9$f, toDisplayString($options.tickSize), 1)
              ]),
              _cache[17] || (_cache[17] = createTextVNode()),
              createBaseVNode("div", _hoisted_10$f, [
                _cache[10] || (_cache[10] = createBaseVNode("span", { class: "label" }, "Min order size", -1)),
                _cache[11] || (_cache[11] = createTextVNode()),
                createBaseVNode("span", _hoisted_11$e, toDisplayString($options.minOrderAmount), 1)
              ]),
              _cache[18] || (_cache[18] = createTextVNode()),
              createBaseVNode("div", _hoisted_12$b, [
                _cache[12] || (_cache[12] = createBaseVNode("span", { class: "label" }, "Max order size", -1)),
                _cache[13] || (_cache[13] = createTextVNode()),
                createBaseVNode("span", _hoisted_13$b, toDisplayString($options.maxOrderAmount), 1)
              ]),
              _cache[19] || (_cache[19] = createTextVNode()),
              $options.areTriggersVisible ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "info-section__item trigger",
                "test-id": "contract-details__open-modal",
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $options.openContractDetailsModal("contract"), ["stop"]))
              }, "\n            See more\n          ")) : createCommentVNode("", true)
            ])
          ]),
          _: 2
        }, 1032, ["is-initial-active", "active-item", "set-active-item"])
      ]),
      _: 1
    }, 8, ["onActiveItemChange"]),
    _cache[21] || (_cache[21] = createTextVNode()),
    (openBlock(), createBlock(_component_TradingConditionsModal, {
      key: $data.activeTradingConditionsTab,
      "is-open": $data.isContractDetailsModalOpen,
      "initial-tab": $data.activeTradingConditionsTab,
      onClose: $options.onModalClose
    }, null, 8, ["is-open", "initial-tab", "onClose"]))
  ]);
}
const DerivativesContractDetails = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$H], ["__scopeId", "data-v-39d16b21"]]);
const getErrorTextFromApiResponseError = (apiResponseError) => {
  var _a2, _b, _c, _d, _e2;
  if ((_c = (_b = (_a2 = apiResponseError.response) == null ? void 0 : _a2.data) == null ? void 0 : _b.errors) == null ? void 0 : _c[0]) {
    return apiResponseError.response.data.errors[0].message;
  }
  return ((_e2 = (_d = apiResponseError.response) == null ? void 0 : _d.data) == null ? void 0 : _e2.message) ?? "Something went wrong.";
};
const storeName$8 = "tradeviewOrderNotificationsStore";
const useTradeviewOrderNotificationsStore = addStoreHooks(
  defineStore(storeName$8, () => {
    const toastStore = useToastStore({ caller: storeName$8 });
    const marketsStore = useMarketsStore({ caller: storeName$8 });
    const tradeviewSoundsStore = useTradeviewSoundsStore({ caller: storeName$8 });
    const tradeviewSettingsStore = useTradeviewSettingsStore({ caller: storeName$8 });
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$8 }));
    const ordersStore = useOrdersStore({ caller: storeName$8 });
    const { openOrders } = storeToRefs(useOrdersStore({ caller: storeName$8 }));
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$8 }));
    const $errorTracking = useErrorTracking();
    const activeOrderFillNotifications = /* @__PURE__ */ new Set();
    const activeOrderDeletedNotifications = /* @__PURE__ */ new Set();
    const pendingOrderFillNotifications = shallowRef([]);
    const pendingOrderDeletedNotifications = shallowRef([]);
    const isFilledManyOrdersNotificationActive = ref(false);
    const isManyOrdersDeletedNotificationActive = ref(false);
    const localOpenOrderHistory = shallowRef({});
    function showOrderFillNotification({ order, trade }) {
      if (!tradeviewSettingsStore.areFillNotificationsEnabled) {
        return;
      }
      const market = marketsStore.getMarket(order.market);
      const orderSide = order.side;
      const capitalizedOrderSide = orderSide.charAt(0).toUpperCase() + orderSide.slice(1);
      const orderType = constants$1.ORDER_TYPE_CONFIG[order.type].display;
      const amount = numberFormatter.formatWithStrippedTrailingZeros(trade.amount, market.decimals.base);
      const price = numberFormatter.amount({
        value: trade.price,
        decimals: market.decimals.counter
      });
      if (activeOrderFillNotifications.size < constants.NOTIFICATIONS.MAX_ORDER_FILLED_NOTIFICATIONS_DISPLAYED) {
        activeOrderFillNotifications.add(trade.id_str);
        toastStore.showToast({
          id: `fill-${trade.id_str}`,
          title: `${capitalizedOrderSide} order filled`,
          text: `Filled ${amount} ${market.name} ${orderType} ${orderSide} @ ${price}.`,
          type: constants$3.NOTIFICATIONS.TYPES.NOTICE
        });
        setTimeout(() => activeOrderFillNotifications.delete(trade.id_str), constants$3.NOTIFICATIONS.DURATIONS.DEFAULT);
      } else if (!isFilledManyOrdersNotificationActive.value) {
        toastStore.showToast({
          title: "Order filled",
          text: "Many recent fills",
          type: constants$3.NOTIFICATIONS.TYPES.NOTICE
        });
        isFilledManyOrdersNotificationActive.value = true;
        setTimeout(() => {
          isFilledManyOrdersNotificationActive.value = false;
        }, constants$3.NOTIFICATIONS.DURATIONS.DEFAULT);
      }
    }
    async function addPendingOrderFillNotification(tradeEvent) {
      pendingOrderFillNotifications.value = [...pendingOrderFillNotifications.value, tradeEvent];
      if (!localOpenOrderHistory.value[tradeEvent.order_id]) {
        try {
          await ordersStore.fetchSingleOrder(tradeEvent.order_id);
        } catch (e) {
          $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        }
      }
      triggerPendingOrderFillNotifications();
    }
    async function addPendingOrderDeletedNotification(orderEvent) {
      if (!tradeviewSettingsStore.areOrderDeletedNotificationsEnabled) {
        return;
      }
      pendingOrderDeletedNotifications.value = [...pendingOrderDeletedNotifications.value, orderEvent];
      try {
        if (pendingOrderDeletedNotifications.value.length <= constants.NOTIFICATIONS.MAX_ORDER_REMOVED_NOTIFICATIONS_DISPLAYED) {
          await ordersStore.fetchSingleOrder(orderEvent.id);
        }
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
      triggerPendingOrderDeletedNotifications();
    }
    function triggerPendingOrderDeletedNotifications() {
      var _a2, _b;
      if (pendingOrderDeletedNotifications.value.length < 1) {
        return;
      }
      if (pendingOrderDeletedNotifications.value.length > constants.NOTIFICATIONS.MAX_ORDER_REMOVED_NOTIFICATIONS_DISPLAYED || activeOrderDeletedNotifications.size > constants.NOTIFICATIONS.MAX_ORDER_REMOVED_NOTIFICATIONS_DISPLAYED) {
        if (document.hidden) {
          return;
        }
        if (isManyOrdersDeletedNotificationActive.value) {
          pendingOrderDeletedNotifications.value = [];
          return;
        }
        isManyOrdersDeletedNotificationActive.value = true;
        setTimeout(() => {
          isManyOrdersDeletedNotificationActive.value = false;
        }, constants$3.NOTIFICATIONS.DURATIONS.DEFAULT);
        const notification = {
          title: "Open orders removed",
          type: constants$3.NOTIFICATIONS.TYPES.NOTICE,
          text: "Multiple open orders removed recently."
        };
        toastStore.showToast(notification);
        pendingOrderDeletedNotifications.value = [];
        return;
      }
      const newPending = [];
      for (const n of pendingOrderDeletedNotifications.value) {
        const order = ordersStore.orderCache[n.id] ?? localOpenOrderHistory.value[n.id];
        if (!order) {
          if (differenceInMinutes(/* @__PURE__ */ new Date(), getDate(n.datetime, true)) < 5) {
            newPending.push(n);
          }
          continue;
        }
        if (order.type === constants$1.ORDER_TYPE.LIMIT || constants$1.TRIGGER_BASED_ORDER_TYPES.includes(order.type)) {
          const typeDisplay = constants$1.ORDER_TYPE_CONFIG[order.type].display;
          const market = marketsStore.getMarket(order.market);
          let priceToDisplay;
          if ((_a2 = order.price) == null ? void 0 : _a2.isPositive()) {
            priceToDisplay = order.price;
          } else if ((_b = order.stopPrice) == null ? void 0 : _b.isPositive()) {
            priceToDisplay = order.stopPrice;
          } else {
            priceToDisplay = order.activationPrice;
          }
          const price = numberFormatter.amount({
            value: priceToDisplay,
            decimals: market.decimals.counter
          });
          const finished = order.status === constants$1.ORDER_STATUS.FINISHED;
          const notification = {
            id: `${order.id}-deleted`,
            title: `Order ${finished ? "finished" : "deleted"}`,
            text: `${market.name} ${typeDisplay} ${order.side} order at ${price} ${finished ? "filled" : "deleted"}.`,
            type: constants$3.NOTIFICATIONS.TYPES.NOTICE
          };
          if (!document.hidden && !isManyOrdersDeletedNotificationActive.value) {
            activeOrderDeletedNotifications.add(order.id);
            setTimeout(
              () => activeOrderDeletedNotifications.delete(order.id),
              constants$3.NOTIFICATIONS.DURATIONS.DEFAULT
            );
            toastStore.showToast(notification);
          }
        }
      }
      pendingOrderDeletedNotifications.value = newPending;
    }
    function triggerPendingOrderFillNotifications() {
      if (pendingOrderFillNotifications.value.length < 1) {
        return;
      }
      const groupedTrades = {};
      for (const trade of [...pendingOrderFillNotifications.value]) {
        const key = `${trade.order_id}-${trade.market}-${trade.side}-${trade.price}`;
        if (!groupedTrades[key]) {
          groupedTrades[key] = { ...trade, amount: new Decimal(trade.amount) };
          continue;
        }
        groupedTrades[key].amount = groupedTrades[key].amount.add(trade.amount);
      }
      const newPending = [];
      for (const trade of Object.values(groupedTrades)) {
        const orderId = trade.order_id;
        const order = ordersStore.orderCache[orderId] ?? localOpenOrderHistory.value[orderId];
        if (order) {
          showOrderFillNotification({ order, trade });
          tradeviewSoundsStore.playUserTradeSound(trade);
        } else if (differenceInMinutes(/* @__PURE__ */ new Date(), getDate(parseInt(trade.microtimestamp) / 1e6, true)) < 1) {
          newPending.push(trade);
          tradeviewSoundsStore.playUserTradeSound(trade);
        }
      }
      if (!tradeviewSettingsStore.areFillNotificationsEnabled || document.hidden) {
        pendingOrderFillNotifications.value = [];
        return;
      }
      pendingOrderFillNotifications.value = newPending;
    }
    watch(openOrders, () => {
      const currentHistoryCount = Object.keys(localOpenOrderHistory.value).length;
      let newLocalOrderHistory = { ...localOpenOrderHistory.value };
      if (currentHistoryCount > 300 && openOrders.value.length < 250) {
        newLocalOrderHistory = {};
      } else if (currentHistoryCount > 1e3) {
        newLocalOrderHistory = {};
      }
      for (const order of openOrders.value) {
        newLocalOrderHistory[order.id] = order;
      }
      localOpenOrderHistory.value = newLocalOrderHistory;
    });
    watch(activeSubAccountId, (newId, oldId) => {
      if (newId !== oldId) {
        pendingOrderFillNotifications.value = [];
        pendingOrderDeletedNotifications.value = [];
        localOpenOrderHistory.value = {};
      }
    });
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        pendingOrderFillNotifications.value = [];
        pendingOrderDeletedNotifications.value = [];
        localOpenOrderHistory.value = {};
      }
    });
    return {
      addPendingOrderFillNotification,
      addPendingOrderDeletedNotification
    };
  })
);
function showNotification(order) {
  var _a2, _b;
  const sideDisplay = order.side === constants$1.ORDER_SIDE.BUY ? "buy" : "sell";
  const typeDisplay = constants$1.ORDER_TYPE_CONFIG[order.type].display.toLowerCase();
  const marketsStore = useMarketsStore();
  const market = marketsStore.getMarket(order.market);
  let notificationText;
  if (constants$1.NO_PRICE_ORDER_TYPES.includes(order.type)) {
    let decimals, currency;
    if (order.type === constants$1.ORDER_TYPE.MARKET) {
      decimals = market.decimals.base;
      currency = market.base;
    } else if (order.type === constants$1.ORDER_TYPE.INSTANT) {
      if (order.side === constants$1.ORDER_SIDE.BUY) {
        decimals = market.decimals.counterInstantOrder;
        currency = market.counter;
      } else {
        decimals = market.decimals.base;
        currency = market.base;
      }
    } else if (order.type === constants$1.ORDER_TYPE.CASH) {
      decimals = market.decimals.counter;
      currency = market.counter;
    } else {
      decimals = market.decimals.base;
      currency = market.base;
      console.error("Invalid order notification type");
    }
    currency = ((_a2 = order._meta) == null ? void 0 : _a2.currency) ?? currency;
    decimals = ((_b = order._meta) == null ? void 0 : _b.decimals) ?? decimals;
    notificationText = `Placed ${typeDisplay} ${sideDisplay} order for ${numberFormatter.decimal({
      value: order.amount,
      decimals,
      rounding: Decimal.ROUND_CEIL,
      smartStripTrailingZeros: true
    })} ${currency}.`;
  } else {
    let connector, amountCurrency, amountDecimals;
    if (order.type === constants$1.ORDER_TYPE.STOP_MARKET && order.side === constants$1.ORDER_SIDE.BUY) {
      connector = "with";
      amountCurrency = market.counter;
      amountDecimals = market.decimals.counter;
    } else {
      connector = "for";
      amountCurrency = market.base;
      amountDecimals = market.decimals.base;
    }
    notificationText = `Placed ${typeDisplay} ${sideDisplay} order ${connector} ${numberFormatter.decimal({
      value: order.amount,
      decimals: amountDecimals,
      rounding: Decimal.ROUND_CEIL,
      smartStripTrailingZeros: true
    })} ${amountCurrency} at ${numberFormatter.decimal({
      value: order.activationPrice ?? order.stopPrice ?? order.price,
      decimals: market.decimals.counter,
      rounding: Decimal.ROUND_CEIL
    })} ${market.counter}.`;
    if (order.type === constants$1.ORDER_TYPE.STOP_LIMIT) {
      notificationText += ` Opens a limit ${sideDisplay} order at ${numberFormatter.decimal({
        value: order.price,
        decimals: market.decimals.counter,
        rounding: Decimal.ROUND_CEIL
      })} ${market.counter} when triggered.`;
    }
  }
  const { showToast } = useToastStore();
  showToast({
    title: "Order submitted",
    text: notificationText,
    type: constants$3.NOTIFICATIONS.TYPES.SUCCESS
  });
}
function useOrderPlacedNotification() {
  return {
    showNotification
  };
}
function parseOrderHistory(orders) {
  return orders.data.map((order) => {
    var _a2;
    return {
      ...order,
      status: ((_a2 = order.status) == null ? void 0 : _a2.toLowerCase()) ?? constants$1.ORDER_STATUS.OPEN,
      amountFilled: new Decimal(order.amountFilled),
      time: getDate(order.timestamp),
      market: order.pair,
      side: order.type,
      type: order.subtype,
      amountAtCreate: new Decimal(order.amountPlaced),
      price: order.price ? new Decimal(order.price) : null,
      stopPrice: order.stopPrice ? new Decimal(order.stopPrice) : null,
      activationPrice: order.activationPrice ? new Decimal(order.activationPrice) : null,
      trailingDelta: order.trailingDelta ? new Decimal(order.trailingDelta) : null,
      totalValue: new Decimal(order.totalValue),
      isLiquidation: order.isLiquidation ?? false
    };
  });
}
const orderHistoryApi = {
  get({
    account = "main",
    page = 1,
    perPage = 20,
    marketKey = "",
    marketType = marketConstants.MARKET_TYPES.SPOT
  } = {}) {
    const params = {
      account,
      page,
      perPage,
      marketType
    };
    if (marketKey) {
      params.market = marketKey;
    }
    const url = buildUrl("orderHistoryListResource", { "user_id": "me" });
    return axiosInstance.get(url, { params }, { noToastOnError: true }).then((data) => {
      return {
        isDisabledDueToTimeout: false,
        orderHistory: parseOrderHistory(data.data)
      };
    }).catch((error) => {
      var _a2;
      trackException(error);
      if (((_a2 = error == null ? void 0 : error.response) == null ? void 0 : _a2.status) === ResponseCodes.HTTP.REQUEST_TIMEOUT) {
        return {
          isDisabledDueToTimeout: true,
          orderHistory: []
        };
      }
      return {
        isDisabledDueToTimeout: false,
        orderHistory: []
      };
    });
  }
};
const storeName$7 = "orderHistoryStore";
const useOrderHistoryStore = addStoreHooks(
  defineStore(storeName$7, () => {
    const activeMarketStore = useActiveMarketStore({ caller: storeName$7 });
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$7 }));
    const subAccountStore = useSubAccountStore({ caller: storeName$7 });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$7 }));
    const $has = useUserPermissions();
    const initialized = ref(false);
    const isDisabledDueToTimeout = ref(false);
    const orderHistory = shallowRef([]);
    const page = ref(1);
    const perPage = ref(20);
    let orderHistoryMarketKey = "";
    const fetchOrderHistory = _.throttle(
      async (marketKey = "") => {
        if (!isLoggedIn.value || !PAGE_CONTEXT.enableOrderHistoryApi || !$has("trade_orders_read") || isDisabledDueToTimeout.value) {
          initialized.value = true;
          return;
        }
        orderHistoryMarketKey = marketKey;
        if (activeMarketStore.isPerpetual && !subAccountStore.doesActiveAccountSupportDerivatives) {
          return;
        }
        const data = await orderHistoryApi.get({
          marketType: activeMarketStore.activeMarket.type,
          marketKey,
          perPage: perPage.value,
          page: page.value,
          account: subAccountStore.activeSubAccountId
        });
        initialized.value = true;
        isDisabledDueToTimeout.value = data.isDisabledDueToTimeout;
        orderHistory.value = data.orderHistory;
      },
      constants$2.TIMERS.THROTTLE_ORDER_HISTORY,
      { leading: false }
    );
    async function setPage(newPage) {
      page.value = newPage;
      await fetchOrderHistory(orderHistoryMarketKey);
    }
    function resetPage() {
      page.value = 1;
    }
    async function _init() {
      fetchOrderHistory(orderHistoryMarketKey);
    }
    watch(activeSubAccountId, (newId, oldId) => {
      if (newId !== oldId) {
        isDisabledDueToTimeout.value = false;
        orderHistory.value = [];
        page.value = 1;
        fetchOrderHistory(orderHistoryMarketKey);
      }
    });
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        page.value = 1;
        isDisabledDueToTimeout.value = false;
        orderHistory.value = [];
      }
    });
    return {
      isDisabledDueToTimeout,
      orderHistory,
      page,
      perPage,
      resetPage,
      fetchOrderHistory,
      setPage,
      _init
    };
  })
);
const storeName$6 = "tradeviewOrderHistoryStore";
const useTradeviewOrderHistoryStore = addStoreHooks(
  defineStore(storeName$6, () => {
    const orderHistoryStore = useOrderHistoryStore({ caller: storeName$6 });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$6 }));
    const { areUserOrdersInAllPairMode } = storeToRefs(useTradeviewSettingsStore({ caller: storeName$6 }));
    function fetchOrderHistory() {
      var _a2;
      orderHistoryStore.fetchOrderHistory(areUserOrdersInAllPairMode.value ? "" : ((_a2 = activeMarket.value) == null ? void 0 : _a2.key) ?? "");
    }
    watch(areUserOrdersInAllPairMode, (newValue, prevValue) => {
      if (newValue === prevValue) {
        return;
      }
      orderHistoryStore.resetPage();
      fetchOrderHistory();
    });
    watch(
      activeMarket,
      async (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
          return;
        }
        orderHistoryStore.resetPage();
        fetchOrderHistory();
      },
      {
        deep: true
      }
    );
    return { fetchOrderHistory };
  })
);
const storeName$5 = "tradeviewPrivateOrdersStore";
const useTradeviewPrivateOrdersStore = addStoreHooks(
  defineStore(storeName$5, () => {
    const activeMarketStore = useActiveMarketStore({ caller: storeName$5 });
    const marketsStore = useMarketsStore({ caller: storeName$5 });
    const { initialized: isMarketsStoreInitialized } = storeToRefs(useMarketsStore({ caller: storeName$5 }));
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$5 }));
    const ordersStore = useOrdersStore({ caller: storeName$5 });
    const subAccountStore = useSubAccountStore({ caller: storeName$5 });
    const websocketStore = useWebsocketStore({ caller: storeName$5 });
    const balancesStore = useBalancesStore({ caller: storeName$5 });
    const toastStore = useToastStore({ caller: storeName$5 });
    const tradeviewMarginInfoStore = useTradeviewMarginInfoStore({ caller: storeName$5 });
    const tradeviewOrderNotificationsStore = useTradeviewOrderNotificationsStore({ caller: storeName$5 });
    const tradeviewOrderHistoryStore = useTradeviewOrderHistoryStore({ caller: storeName$5 });
    const tradeviewOpenPositionsStore = useTradeviewOpenPositionsStore({ caller: storeName$5 });
    const $branch = useBranch();
    const { showNotification: showOrderPlacedNotification } = useOrderPlacedNotification();
    const initialized = computed(() => {
      return ordersStore.initialized;
    });
    const openOrdersForActiveMarket = computed(() => {
      if (!ordersStore.openOrders) {
        return [];
      }
      return ordersStore.openOrders.filter((o) => o.market === activeMarketStore.activeMarket.key);
    });
    const openOrdersForActiveMarketType = computed(() => {
      if (!ordersStore.openOrders) {
        return [];
      }
      return ordersStore.openOrders.filter((o) => {
        const orderMarket = marketsStore.getMarket(o.market);
        return (orderMarket == null ? void 0 : orderMarket.type) === activeMarketStore.activeMarket.type;
      });
    });
    const openOrdersForAllMarkets = computed(() => {
      return ordersStore.openOrders ?? [];
    });
    let disconnectWsFns = [];
    async function connectWs() {
      if (isLoggedIn.value) {
        for (const [key, { type }] of Object.entries(marketsStore.visibleMarkets)) {
          const { disconnect } = await websocketStore.subscribeToChannel({
            channel: websocketStore.getPrivateMyOrdersChannelName(key, type),
            event: WSApi.USER_ORDER_EVENT,
            onEvent: async (event) => {
              if (event.trade_account_id === 0 && subAccountStore.activeSubAccountId === accountConstants.MAIN_ACCOUNT_ID || event.trade_account_id === subAccountStore.activeSubAccountId) {
                ordersStore.fetchOpenOrders();
                balancesStore.fetch();
                tradeviewOrderHistoryStore.fetchOrderHistory();
                if (type === marketConstants.MARKET_TYPES.PERPETUAL) {
                  tradeviewMarginInfoStore.fetchMarginInfo();
                  tradeviewOpenPositionsStore.fetchOpenPositions();
                }
                if (event.event === WSApi.ORDER_DELETED_EVENT) {
                  tradeviewOrderNotificationsStore.addPendingOrderDeletedNotification(event);
                }
              }
            },
            eventGroupKey: "tradeviewPrivateOrdersStore"
          });
          disconnectWsFns.push(disconnect);
        }
      }
    }
    async function cancelOrder(orderId, orderType) {
      try {
        await ordersStore.cancel(orderId, true);
        if (constants$1.LEGACY_STOP_ORDER_TYPES.includes(orderType)) {
          toastStore.showNoticeToast("Order deleted successfully", "Order deleted");
        }
      } catch (e) {
        toastStore.showErrorToast(getErrorTextFromApiResponseError(e), "Could not delete order");
      } finally {
        ordersStore.fetchOpenOrders();
        balancesStore.fetch();
      }
    }
    async function cancelAllOrders(accountId) {
      try {
        await ordersStore.cancelAll(accountId, true);
        toastStore.showSuccessToast("All orders cancelled.");
      } catch (e) {
        toastStore.showErrorToast(getErrorTextFromApiResponseError(e), "Could not cancel all orders");
      } finally {
        ordersStore.fetchOpenOrders();
        balancesStore.fetch();
      }
    }
    async function cancelAllOrdersForMarket(accountId, market) {
      const marketConfig = marketsStore.getMarket(market);
      try {
        await ordersStore.cancelAllForMarket(accountId, market, true);
        toastStore.showSuccessToast(`All ${marketConfig.name} orders cancelled.`);
      } catch (e) {
        toastStore.showErrorToast(
          getErrorTextFromApiResponseError(e),
          `Could not cancel all ${marketConfig.name} orders`
        );
      } finally {
        ordersStore.fetchOpenOrders();
        balancesStore.fetch();
      }
    }
    async function createOrder(order) {
      const orderData = { ...order, account: `${subAccountStore.activeSubAccountId}` };
      delete orderData._meta;
      try {
        const response = await ordersStore.createOrder(orderData);
        const serverOrder = response.data.data;
        showOrderPlacedNotification({ ...order, id: serverOrder.id });
        if (order.side === constants$1.ORDER_SIDE.BUY) {
          $branch.lib.logEvent(branchEvents.buyOrderPlaced.name, branchEvents.buyOrderPlaced.schema);
        } else {
          $branch.lib.logEvent(branchEvents.sellOrderPlaced.name, branchEvents.sellOrderPlaced.schema);
        }
        if (constants$1.LEGACY_STOP_ORDER_TYPES.includes(order.type)) {
          ordersStore.fetchOpenOrders();
          balancesStore.fetch();
        }
      } catch (e) {
        return Promise.reject(e);
      }
    }
    function disconnectWs() {
      disconnectWsFns.forEach((cb) => {
        cb();
      });
      disconnectWsFns = [];
    }
    async function _init() {
      if (marketsStore.initialized) {
        await connectWs();
      }
      return () => {
        disconnectWs();
      };
    }
    watch(isMarketsStoreInitialized, (newValue, prevValue) => {
      if (prevValue && !newValue) {
        return;
      }
      connectWs();
    });
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        disconnectWs();
      }
    });
    return {
      initialized,
      openOrdersForActiveMarket,
      openOrdersForActiveMarketType,
      openOrdersForAllMarkets,
      cancelOrder,
      cancelAllOrders,
      cancelAllOrdersForMarket,
      createOrder,
      fetchOpenOrders: ordersStore.fetchOpenOrders,
      _init
    };
  })
);
const minMaxLeverageAPI = {
  /**
   * Fetch min and max leverage for a market depending on user's current open positions, orders, margin etc.
   *
   * @param {string} market - btcusd-perp
   * @param {'main'|number} account - accountId
   * @param {'CROSS'|'ISOLATED'} marginMode
   * @returns {Promise<{min: number, max: number}>}
   */
  getMinMaxLeverage(market, account, marginMode) {
    const url = URLService.buildUrl("minMaxLeverageResource", {
      unique_id: account,
      market,
      margin_mode: marginMode
    });
    return axiosInstance.get(url).then((data) => data.data.data);
  }
};
const _hoisted_1$Q = { class: "change-leverage" };
const _hoisted_2$A = { class: "change-leverage__text-top" };
const _hoisted_3$x = { class: "flex flex--gap-small" };
const _hoisted_4$s = { class: "change-leverage__market" };
const _hoisted_5$m = { class: "change-leverage__tag" };
const _hoisted_6$j = { class: "change-leverage__group" };
const _hoisted_7$h = {
  key: 1,
  class: "error"
};
const _hoisted_8$h = {
  key: 2,
  class: "error"
};
const _sfc_main$W = {
  __name: "ChangeFormLeverageModal",
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const activeMarketStore = useActiveMarketStore();
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore();
    const subAccountStore = useSubAccountStore();
    const tradeviewPrivateOrdersStore = useTradeviewPrivateOrdersStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const emit = __emit;
    const marginMode = computed(() => {
      return tradeviewMarginSettingsStore.activeMarginMode;
    });
    const hasConflictingOpenOrders = computed(() => {
      return tradeviewPrivateOrdersStore.openOrdersForActiveMarket.filter((o) => o.marginMode === marginMode.value).length > 0;
    });
    const initialized = ref(false);
    const isLeverageAdjustmentUnavailable = ref(false);
    const minLeverage = ref(1);
    const maxLeverage = ref(3);
    const isInputDisabled = computed(() => {
      return !initialized.value || isLeverageAdjustmentUnavailable.value || hasConflictingOpenOrders.value || currentLeverageScaledToRange.value === minLeverage.value && minLeverage.value === maxLeverage.value;
    });
    const currentLeverageScaledToRange = computed(() => {
      return Math.min(
        Math.max(
          tradeviewOrderFormStore.activeOrderFormLeverage,
          minLeverage.value
        ),
        maxLeverage.value
      );
    });
    const marks = computed(() => {
      return {
        [minLeverage.value]: `${minLeverage.value}x`,
        [maxLeverage.value]: `${maxLeverage.value}x`,
        [currentLeverageScaledToRange.value]: {
          label: `${currentLeverageScaledToRange.value}x`,
          labelStyle: {
            color: "var(--bts-tv-text-color-bright)"
          }
        }
      };
    });
    const validationSchema = computed(() => {
      return {
        leverage: {
          required: true,
          decimal: { decimals: 2 },
          max_value: maxLeverage.value,
          min_value: minLeverage.value
        }
      };
    });
    const { meta, defineField, errors } = useForm({ validationSchema });
    const [newLeverage] = defineField("leverage");
    const isConfirmDisabled = computed(() => {
      return isInputDisabled.value || !meta.value.valid;
    });
    function onUpdateFromSlider(newValue) {
      newLeverage.value = `${newValue}`;
    }
    async function fetchMinMaxLeverage() {
      try {
        const { min, max } = await minMaxLeverageAPI.getMinMaxLeverage(
          activeMarketStore.activeMarketKey,
          subAccountStore.activeSubAccountId,
          marginMode.value
        );
        minLeverage.value = min;
        maxLeverage.value = max;
        isLeverageAdjustmentUnavailable.value = false;
      } catch (e) {
        isLeverageAdjustmentUnavailable.value = true;
        trackException(e);
      }
    }
    let pollingInterval = null;
    onBeforeMount(async () => {
      await fetchMinMaxLeverage();
      pollingInterval = setInterval(fetchMinMaxLeverage, 15e3);
      newLeverage.value = `${currentLeverageScaledToRange.value}`;
      initialized.value = true;
    });
    onBeforeUnmount(() => {
      clearInterval(pollingInterval);
    });
    function closeModal() {
      emit("close");
    }
    async function onConfirm() {
      if (`${newLeverage.value}` === `${tradeviewOrderFormStore.activeOrderFormLeverage}`) {
        closeModal();
        return;
      }
      tradeviewOrderFormStore.setOrderFormLeverage(
        activeMarketStore.activeMarketKey,
        marginMode.value,
        subAccountStore.activeSubAccountId,
        toDecimal(newLeverage.value).toNumber()
      );
      closeModal();
    }
    const isSliderHidden = computed(() => {
      return minLeverage.value === maxLeverage.value;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(TradeviewModal), {
        "is-open": "",
        "cancel-text": "Cancel",
        "confirm-text": "Confirm",
        "confirm-disabled": isConfirmDisabled.value,
        onClose: closeModal,
        onConfirm
      }, {
        title: withCtx(() => _cache[1] || (_cache[1] = [
          createTextVNode("\n      Change order from leverage\n    ")
        ])),
        body: withCtx(() => [
          createBaseVNode("div", _hoisted_1$Q, [
            createBaseVNode("div", _hoisted_2$A, [
              createBaseVNode("div", _hoisted_3$x, [
                createVNode(unref(CurrencyIcon), {
                  currency: unref(activeMarketStore).activeMarket.base,
                  size: "18"
                }, null, 8, ["currency"]),
                _cache[2] || (_cache[2] = createTextVNode()),
                createBaseVNode("span", _hoisted_4$s, toDisplayString(unref(activeMarketStore).activeMarket.name), 1),
                _cache[3] || (_cache[3] = createTextVNode()),
                createBaseVNode("div", _hoisted_5$m, toDisplayString(marginMode.value), 1)
              ])
            ]),
            _cache[6] || (_cache[6] = createTextVNode()),
            createBaseVNode("div", _hoisted_6$j, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Leverage", -1)),
              _cache[5] || (_cache[5] = createTextVNode()),
              createVNode(unref(OrderInputWithValidation), {
                modelValue: unref(newLeverage),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(newLeverage) ? newLeverage.value = $event : null),
                "custom-error-message": unref(errors).leverage,
                disabled: isInputDisabled.value,
                class: "value-input",
                field: "newLeverage"
              }, null, 8, ["modelValue", "custom-error-message", "disabled"])
            ]),
            _cache[7] || (_cache[7] = createTextVNode()),
            initialized.value && !isSliderHidden.value ? (openBlock(), createBlock(unref(OrderSlider), {
              key: 0,
              value: unref(newLeverage),
              min: minLeverage.value,
              max: maxLeverage.value,
              "slider-interval": 0.01,
              marks: marks.value,
              "hide-label": false,
              disabled: isInputDisabled.value,
              "pre-change-marker-value": currentLeverageScaledToRange.value,
              "onUpdate:value": onUpdateFromSlider
            }, null, 8, ["value", "min", "max", "marks", "disabled", "pre-change-marker-value"])) : createCommentVNode("", true),
            _cache[8] || (_cache[8] = createTextVNode()),
            isLeverageAdjustmentUnavailable.value ? (openBlock(), createElementBlock("div", _hoisted_7$h, "\n          Unable to adjust leverage at the moment. Please wait or try again later.\n        ")) : hasConflictingOpenOrders.value ? (openBlock(), createElementBlock("div", _hoisted_8$h, "\n          You can not submit orders with a different leverage from the one set on your current open orders.\n        ")) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["confirm-disabled"]);
    };
  }
};
const ChangeFormLeverageModal = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__scopeId", "data-v-c5d2d5fd"]]);
const _sfc_main$V = {
  name: "ChangeMarginModeModal",
  components: {
    GeneralNotification,
    DropdownSelector,
    CurrencyIcon,
    TradeviewModal
  },
  emits: ["close"],
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradeviewMarginSettingsStore: useTradeviewMarginSettingsStore(),
      toastStore: useToastStore()
    };
  },
  data() {
    return {
      selectedMarginMode: this.tradeviewMarginSettingsStore.activeMarginMode,
      initialMarginMode: this.tradeviewMarginSettingsStore.activeMarginMode,
      isProcessing: false,
      MARGIN_MODES: constants$1.MARGIN_MODE
    };
  },
  computed: {
    marginModeOptions() {
      return [
        {
          text: constants$1.MARGIN_MODE_DISPLAY[constants$1.MARGIN_MODE.ISOLATED],
          value: constants$1.MARGIN_MODE.ISOLATED
        },
        {
          text: constants$1.MARGIN_MODE_DISPLAY[constants$1.MARGIN_MODE.CROSS],
          value: constants$1.MARGIN_MODE.CROSS
        }
      ];
    }
  },
  methods: {
    async changeMarginMode() {
      const newMarginMode = this.selectedMarginMode;
      if (this.tradeviewMarginSettingsStore.activeMarginMode === newMarginMode) {
        return;
      }
      this.isProcessing = true;
      const succeeded = await this.tradeviewMarginSettingsStore.changePreferredMarginMode(newMarginMode);
      this.closeModal();
      if (!succeeded) {
        const market = this.activeMarketStore.activeMarket.name;
        this.toastStore.showErrorToast(`Failed to change margin mode for ${market}.`);
      }
    },
    closeModal() {
      this.$emit("close");
    }
  }
};
const _hoisted_1$P = { class: "modal-content" };
const _hoisted_2$z = { class: "setting" };
const _hoisted_3$w = { class: "setting__label" };
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CurrencyIcon = resolveComponent("CurrencyIcon");
  const _component_DropdownSelector = resolveComponent("DropdownSelector");
  const _component_GeneralNotification = resolveComponent("GeneralNotification");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createBlock(_component_TradeviewModal, {
    "is-open": "",
    "cancel-text": "Cancel",
    "confirm-text": "Confirm",
    "confirm-disabled": $data.isProcessing || $data.initialMarginMode === $data.selectedMarginMode,
    onClose: $options.closeModal,
    onConfirm: $options.changeMarginMode
  }, {
    title: withCtx(() => _cache[1] || (_cache[1] = [
      createTextVNode("\n      Change margin mode\n    ")
    ])),
    body: withCtx(() => [
      createBaseVNode("div", _hoisted_1$P, [
        createBaseVNode("div", _hoisted_2$z, [
          createBaseVNode("div", _hoisted_3$w, [
            createVNode(_component_CurrencyIcon, {
              currency: $setup.activeMarketStore.activeMarket.base,
              size: "18"
            }, null, 8, ["currency"]),
            _cache[2] || (_cache[2] = createTextVNode()),
            createBaseVNode("label", null, toDisplayString($setup.activeMarketStore.activeMarket.name) + " margin mode:", 1)
          ]),
          _cache[3] || (_cache[3] = createTextVNode()),
          createVNode(_component_DropdownSelector, {
            value: $data.selectedMarginMode,
            "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $data.selectedMarginMode = $event),
            class: "setting__action",
            options: $options.marginModeOptions,
            disabled: !$data.selectedMarginMode || $data.isProcessing
          }, null, 8, ["value", "options", "disabled"])
        ]),
        _cache[6] || (_cache[6] = createTextVNode()),
        $data.selectedMarginMode === $data.MARGIN_MODES.ISOLATED ? (openBlock(), createBlock(_component_GeneralNotification, {
          key: 0,
          "notification-type": "info"
        }, {
          default: withCtx(() => _cache[4] || (_cache[4] = [
            createBaseVNode("strong", null, "Isolated", -1),
            createTextVNode(" margin trading allows you to precisely manage risk by allowing you to assign\n          collateral amounts to individual positions.\n        ")
          ])),
          _: 1
        })) : $data.selectedMarginMode === $data.MARGIN_MODES.CROSS ? (openBlock(), createBlock(_component_GeneralNotification, {
          key: 1,
          "notification-type": "info"
        }, {
          default: withCtx(() => _cache[5] || (_cache[5] = [
            createBaseVNode("strong", null, "Cross", -1),
            createTextVNode(" margin uses all available funds in your account as collateral for your trades.\n          If one position moves against you, but another position is in profit, the profit can be used to cover the loss.\n        ")
          ])),
          _: 1
        })) : createCommentVNode("", true)
      ])
    ]),
    _: 1
  }, 8, ["confirm-disabled", "onClose", "onConfirm"]);
}
const ChangeMarginModeModal = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$G], ["__scopeId", "data-v-ebacab16"]]);
const _sfc_main$U = {
  name: "DerivativesMarginSettings",
  components: {
    GeneralNotification,
    ChangeMarginModeModal,
    ChangeFormLeverageModal
  },
  props: {
    isOrderFormDirty: {
      type: Boolean,
      required: true
    }
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradeviewMarginSettingsStore: useTradeviewMarginSettingsStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore()
    };
  },
  data() {
    return {
      isLeverageModalOpen: false,
      isChangeMarginModeModalOpen: false,
      warningNotificationType: constants$3.NOTIFICATIONS.TYPES.WARNING
    };
  },
  computed: {
    isLeverageWarningDisplayed() {
      const hasOpenOrders = this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket.filter((o) => o.marginMode === this.activeMarginMode).length > 0;
      if (hasOpenOrders || !this.isOrderFormDirty) {
        return false;
      }
      const hasOpenPosition = this.tradeviewOpenPositionsStore.hasOpenPositionsForActiveMarketAndMarginMode;
      return hasOpenPosition && this.tradeviewMarginSettingsStore.activeLeverage !== this.tradeviewOrderFormStore.activeOrderFormLeverage;
    },
    activeMarginMode() {
      return this.tradeviewMarginSettingsStore.activeMarginMode;
    },
    activeMarginModeDisplay() {
      return constants$1.MARGIN_MODE_DISPLAY[this.activeMarginMode];
    }
  },
  methods: {
    openChangeMarginModeModal() {
      this.isChangeMarginModeModalOpen = true;
    },
    openChangeLeverageModal() {
      this.isLeverageModalOpen = true;
    }
  }
};
const _hoisted_1$O = { class: "margin-settings" };
const _hoisted_2$y = ["title"];
const _hoisted_3$v = ["title"];
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GeneralNotification = resolveComponent("GeneralNotification");
  const _component_ChangeFormLeverageModal = resolveComponent("ChangeFormLeverageModal");
  const _component_ChangeMarginModeModal = resolveComponent("ChangeMarginModeModal");
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("div", _hoisted_1$O, [
      createBaseVNode("div", {
        class: "setting",
        title: `Margin mode for ${$setup.activeMarketStore.activeMarket.name} orders.`
      }, [
        createBaseVNode("button", {
          class: "setting__action",
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.openChangeMarginModeModal && $options.openChangeMarginModeModal(...args), ["stop"]))
        }, toDisplayString($options.activeMarginModeDisplay), 1)
      ], 8, _hoisted_2$y),
      _cache[4] || (_cache[4] = createTextVNode()),
      createBaseVNode("div", {
        class: "setting",
        title: `Leverage for ${$options.activeMarginMode} ${$setup.activeMarketStore.activeMarket.name} orders.`
      }, [
        createBaseVNode("button", {
          class: "setting__action",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.openChangeLeverageModal && $options.openChangeLeverageModal(...args), ["stop"]))
        }, toDisplayString($setup.tradeviewOrderFormStore.activeOrderFormLeverage) + "x\n        ", 1)
      ], 8, _hoisted_3$v)
    ]),
    _cache[5] || (_cache[5] = createTextVNode()),
    $options.isLeverageWarningDisplayed ? (openBlock(), createBlock(_component_GeneralNotification, {
      key: 0,
      class: "leverage-warning",
      pro: "",
      "notification-type": $data.warningNotificationType
    }, {
      default: withCtx(() => [
        createTextVNode("\n      Submitting an order at " + toDisplayString($setup.tradeviewOrderFormStore.activeOrderFormLeverage) + "x leverage will change the\n      leverage of your open " + toDisplayString($options.activeMarginModeDisplay) + " " + toDisplayString($setup.activeMarketStore.activeMarket.name) + " position.\n    ", 1)
      ]),
      _: 1
    }, 8, ["notification-type"])) : createCommentVNode("", true),
    _cache[6] || (_cache[6] = createTextVNode()),
    $data.isLeverageModalOpen ? (openBlock(), createBlock(_component_ChangeFormLeverageModal, {
      key: 1,
      onClose: _cache[2] || (_cache[2] = ($event) => $data.isLeverageModalOpen = false)
    })) : createCommentVNode("", true),
    _cache[7] || (_cache[7] = createTextVNode()),
    $data.isChangeMarginModeModalOpen ? (openBlock(), createBlock(_component_ChangeMarginModeModal, {
      key: 2,
      onClose: _cache[3] || (_cache[3] = ($event) => $data.isChangeMarginModeModalOpen = false)
    })) : createCommentVNode("", true)
  ]);
}
const DerivativesMarginSettings = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$F], ["__scopeId", "data-v-4425fe83"]]);
const _sfc_main$T = {
  name: "DerivativesOrderMarginInfo",
  components: {
    TradeviewModal,
    DropdownSelector,
    AppTooltip
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      currenciesStore: useCurrenciesStore(),
      toastStore: useToastStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      tradeviewMarginInfoStore: useTradeviewMarginInfoStore(),
      tradeviewSettlementCurrencyStore: useTradeviewSettlementCurrencyStore(),
      tradeviewMarginSettingsStore: useTradeviewMarginSettingsStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore()
    };
  },
  data() {
    return {
      inFlightSettlementCurrency: null,
      isSettlementCurrencyDropdownDisabled: false,
      isErrorModalOpen: false,
      errorModalText: "",
      errorModalTitle: "",
      MODAL_STYLE_ERROR: TradeviewModal.STYLE_ERROR
    };
  },
  computed: {
    /** @type {module:openPositionsStore.FormattedOpenPosition} */
    openPositionForActiveMarketAndMargin() {
      return this.tradeviewOpenPositionsStore.formattedOpenPositions.filter(
        (p) => p.market === this.activeMarketStore.activeMarketKey && p.marginMode === this.tradeviewMarginSettingsStore.activeMarginMode
      )[0];
    },
    netPositionAmountAndAvgPrice() {
      if (!this.openPositionForActiveMarketAndMargin) {
        return null;
      }
      const pos = this.openPositionForActiveMarketAndMargin;
      return {
        price: pos.avgEntryPrice,
        amount: pos.amount,
        amountAsDecimal: pos.amountAsDecimal.abs()
      };
    },
    isCurrentPositionAmountClickable() {
      if (!this.openPositionForActiveMarketAndMargin) {
        return false;
      }
      const orderSide = this.tradeviewOrderFormStore.activeOrderSide;
      const isLong = this.openPositionForActiveMarketAndMargin.isLong;
      return orderSide === constants$1.ORDER_SIDE.SELL && isLong || orderSide === constants$1.ORDER_SIDE.BUY && !isLong;
    },
    hasOpenOrdersOrPositionsForActiveMarket() {
      return this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket.length > 0 || this.tradeviewOpenPositionsStore.openPositions.filter(
        (p) => p.market === this.activeMarketStore.activeMarketKey
      ).length > 0;
    },
    activeMarginMode() {
      return this.tradeviewMarginSettingsStore.activeMarginMode;
    },
    marginImpact() {
      const currencyCode = this.activeMarginMode === constants$1.MARGIN_MODE.ISOLATED ? this.tradeviewSettlementCurrencyStore.activeSettlementCurrency : this.tradeviewMarginInfoStore.accountMarginCurrency;
      if (!currencyCode) {
        return "/";
      }
      const currency = this.currenciesStore.getCurrency(currencyCode);
      return numberFormatter.price({
        value: this.tradeviewOrderFormStore.marginImpact,
        currencySymbol: currency.symbol,
        currencyCode: currency.code,
        decimals: currency.decimals
      });
    },
    marginAvailable() {
      var _a2, _b;
      let currency, value;
      if (this.activeMarginMode === constants$1.MARGIN_MODE.ISOLATED) {
        currency = this.currenciesStore.getCurrency(this.tradeviewSettlementCurrencyStore.activeSettlementCurrency);
        value = (_b = (_a2 = this.tradeviewMarginInfoStore.marginPerCurrency) == null ? void 0 : _a2[currency == null ? void 0 : currency.code]) == null ? void 0 : _b.available;
      } else {
        if (!this.tradeviewMarginInfoStore.isAccountMarginDataAvailable) {
          return "/";
        }
        currency = this.currenciesStore.getCurrency(this.tradeviewMarginInfoStore.accountMarginCurrency);
        value = this.tradeviewMarginInfoStore.accountMarginAvailable;
      }
      if (!currency || !value) {
        return "/";
      }
      return numberFormatter.price({
        value,
        decimals: currency.decimals,
        currencyCode: currency.code,
        currencySymbol: currency.symbol
      });
    },
    settlementCurrencyOptions() {
      return this.tradeviewSettlementCurrencyStore.availableSettlementCurrencies.map((currency) => ({
        text: currency,
        value: currency
      }));
    },
    isIsolatedMode() {
      return this.tradeviewMarginSettingsStore.activeMarginMode === constants$1.MARGIN_MODE.ISOLATED;
    },
    marginRequiredLabel() {
      if (this.isIsolatedMode) {
        return "Collateral required";
      }
      return "Margin required";
    },
    marginRequiredTooltip() {
      if (this.isIsolatedMode) {
        return "Collateral required to submit the order.";
      }
      return "Margin required to submit the order. For cross margin mode, the displayed value is an approximate in USD.";
    },
    marginAvailableLabel() {
      if (this.isIsolatedMode) {
        return "Collateral available";
      }
      return "Margin available";
    },
    marginAvailableTooltip() {
      if (this.isIsolatedMode) {
        return "Remaining collateral available for placing new risk-increasing orders.";
      }
      return "Remaining margin available for placing new risk-increasing orders. For cross margin mode, the displayed value is an approximate value in USD.";
    }
  },
  methods: {
    onPositionAmountClick() {
      if (!this.isCurrentPositionAmountClickable) {
        return;
      }
      this.tradeviewTriggerValueStore.setAmountSetByTrigger(this.netPositionAmountAndAvgPrice.amountAsDecimal);
    },
    openErrorModal(title, text) {
      this.errorModalTitle = title;
      this.errorModalText = text;
      this.isErrorModalOpen = true;
    },
    async changeSettlementCurrency(newSettlementCurrency) {
      if (this.tradeviewSettlementCurrencyStore.activeSettlementCurrency === newSettlementCurrency) {
        return;
      }
      const counter = this.activeMarketStore.activeMarket.counter;
      const errorTitle = "Could not change settlement currency";
      const errorText = `You need to close all of your positions and cancel all open orders on ${counter} quoted derivatives markets before continuing.`;
      if (this.hasOpenOrdersOrPositionsForActiveMarket) {
        this.openErrorModal(errorTitle, errorText);
        return;
      }
      this.inFlightSettlementCurrency = newSettlementCurrency;
      this.isSettlementCurrencyDropdownDisabled = true;
      const succeeded = await this.tradeviewSettlementCurrencyStore.setSettlementCurrency(
        counter,
        newSettlementCurrency
      );
      this.inFlightSettlementCurrency = null;
      this.isSettlementCurrencyDropdownDisabled = false;
      if (succeeded) {
        this.toastStore.showSuccessToast(
          `Settlement currency for derivatives ${counter} quoted markets changed to ${newSettlementCurrency}.`
        );
      } else {
        this.openErrorModal(errorTitle, errorText);
      }
    }
  }
};
const _hoisted_1$N = { class: "info-section" };
const _hoisted_2$x = { class: "info-section__item" };
const _hoisted_3$u = { key: 1 };
const _hoisted_4$r = { class: "info-section__item" };
const _hoisted_5$l = { class: "tooltip-indicator" };
const _hoisted_6$i = { "data-test": "marginAvailable" };
const _hoisted_7$g = { class: "info-section__item" };
const _hoisted_8$g = { class: "tooltip-indicator" };
const _hoisted_9$e = { "data-test": "marginImpact" };
const _hoisted_10$e = { class: "info-section__item" };
const _hoisted_11$d = { class: "info-section__net-position-value" };
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_DropdownSelector = resolveComponent("DropdownSelector");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("div", _hoisted_1$N, [
      createBaseVNode("div", _hoisted_2$x, [
        createVNode(_component_AppTooltip, { delay: { show: 750, hide: 100 } }, {
          trigger: withCtx(() => _cache[2] || (_cache[2] = [
            createBaseVNode("label", { class: "tooltip-indicator" }, "Settlement currency", -1)
          ])),
          default: withCtx(() => [
            _cache[3] || (_cache[3] = createTextVNode()),
            _cache[4] || (_cache[4] = createBaseVNode("span", null, "Settlement currency", -1))
          ]),
          _: 1
        }),
        _cache[5] || (_cache[5] = createTextVNode()),
        $options.settlementCurrencyOptions.length > 1 ? (openBlock(), createBlock(_component_DropdownSelector, {
          key: 0,
          value: $setup.tradeviewSettlementCurrencyStore.activeSettlementCurrency,
          options: $options.settlementCurrencyOptions,
          disabled: $data.isSettlementCurrencyDropdownDisabled,
          "active-option-text-override": $data.inFlightSettlementCurrency,
          class: "settlement-currency-selector",
          "onUpdate:value": $options.changeSettlementCurrency
        }, null, 8, ["value", "options", "disabled", "active-option-text-override", "onUpdate:value"])) : (openBlock(), createElementBlock("span", _hoisted_3$u, toDisplayString($setup.tradeviewSettlementCurrencyStore.activeSettlementCurrency), 1))
      ]),
      _cache[15] || (_cache[15] = createTextVNode()),
      createBaseVNode("div", _hoisted_4$r, [
        createVNode(_component_AppTooltip, { delay: { show: 750, hide: 100 } }, {
          trigger: withCtx(() => [
            createBaseVNode("label", _hoisted_5$l, toDisplayString($options.marginAvailableLabel), 1)
          ]),
          default: withCtx(() => [
            _cache[6] || (_cache[6] = createTextVNode()),
            createBaseVNode("span", null, toDisplayString($options.marginAvailableTooltip), 1)
          ]),
          _: 1
        }),
        _cache[7] || (_cache[7] = createTextVNode()),
        createBaseVNode("span", _hoisted_6$i, toDisplayString($options.marginAvailable), 1)
      ]),
      _cache[16] || (_cache[16] = createTextVNode()),
      createBaseVNode("div", _hoisted_7$g, [
        createVNode(_component_AppTooltip, { delay: { show: 750, hide: 100 } }, {
          trigger: withCtx(() => [
            createBaseVNode("label", _hoisted_8$g, toDisplayString($options.marginRequiredLabel), 1)
          ]),
          default: withCtx(() => [
            _cache[8] || (_cache[8] = createTextVNode()),
            createBaseVNode("span", null, toDisplayString($options.marginRequiredTooltip), 1)
          ]),
          _: 1
        }),
        _cache[9] || (_cache[9] = createTextVNode()),
        createBaseVNode("span", _hoisted_9$e, toDisplayString($options.marginImpact), 1)
      ]),
      _cache[17] || (_cache[17] = createTextVNode()),
      createBaseVNode("div", _hoisted_10$e, [
        createVNode(_component_AppTooltip, { delay: { show: 750, hide: 100 } }, {
          trigger: withCtx(() => _cache[10] || (_cache[10] = [
            createBaseVNode("label", { class: "tooltip-indicator" }, "Current position", -1)
          ])),
          default: withCtx(() => [
            _cache[11] || (_cache[11] = createTextVNode()),
            _cache[12] || (_cache[12] = createBaseVNode("span", null, "\n            Displays the total amount and average entry price of your existing open position in the selected market\n            for the chosen margin mode.\n          ", -1))
          ]),
          _: 1
        }),
        _cache[14] || (_cache[14] = createTextVNode()),
        createBaseVNode("div", _hoisted_11$d, [
          $options.netPositionAmountAndAvgPrice ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("span", {
              "data-test": "netPosition",
              class: normalizeClass({ "info-section__trigger": $options.isCurrentPositionAmountClickable }),
              onClick: _cache[0] || (_cache[0] = (...args) => $options.onPositionAmountClick && $options.onPositionAmountClick(...args))
            }, toDisplayString($options.netPositionAmountAndAvgPrice.amount) + " " + toDisplayString($setup.activeMarketStore.activeMarket.base), 3),
            _cache[13] || (_cache[13] = createTextVNode()),
            createBaseVNode("span", null, "@" + toDisplayString($options.netPositionAmountAndAvgPrice.price) + " " + toDisplayString($setup.activeMarketStore.activeMarket.counter), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode("\n            /\n          ")
          ], 64))
        ])
      ])
    ]),
    _cache[18] || (_cache[18] = createTextVNode()),
    createVNode(_component_TradeviewModal, {
      "is-open": $data.isErrorModalOpen,
      "onUpdate:isOpen": _cache[1] || (_cache[1] = ($event) => $data.isErrorModalOpen = $event),
      "modal-style": $data.MODAL_STYLE_ERROR,
      title: $data.errorModalTitle,
      "cancel-text": "Close"
    }, {
      body: withCtx(() => [
        createTextVNode(toDisplayString($data.errorModalText), 1)
      ]),
      _: 1
    }, 8, ["is-open", "modal-style", "title"])
  ]);
}
const DerivativesOrderMarginInfo = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$E], ["__scopeId", "data-v-a88805a2"]]);
const _sfc_main$S = {
  name: "OrderFormBalances",
  components: {
    AppIcon
  },
  props: {
    side: {
      type: String,
      required: true
    }
  },
  emits: ["fill"],
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      balancesStore: useBalancesStore(),
      currenciesStore: useCurrenciesStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      subAccountStore: useSubAccountStore(),
      tradeviewSettlementCurrencyStore: useTradeviewSettlementCurrencyStore()
    };
  },
  computed: {
    prefilledSubAccountTransferAsset() {
      if (this.activeMarketStore.isPerpetual) {
        return this.tradeviewSettlementCurrencyStore.activeSettlementCurrency;
      }
      if (this.side === constants$1.ORDER_SIDE.BUY) {
        return this.activeMarketStore.activeMarket.counter;
      }
      return this.activeMarketStore.activeMarket.base;
    },
    available() {
      if (this.activeMarketStore.isSpot) {
        const baseOrCounter = this.side === constants$1.ORDER_SIDE.BUY ? "counter" : "base";
        return this.balancesStore.activeMarketAccountAvailableBalance[baseOrCounter];
      } else if (this.activeMarketStore.isPerpetual) {
        return this.tradeviewOrderFormStore.maxOrderAmount ?? new Decimal(0);
      }
      return new Decimal(0);
    },
    formattedAmount() {
      var _a2, _b, _c;
      if (this.activeMarketStore.isSpot) {
        const baseOrCounter = this.side === constants$1.ORDER_SIDE.BUY ? "counter" : "base";
        const currency = this.currenciesStore.getCurrency(this.activeMarketStore.activeMarket[baseOrCounter]);
        if (this.available.isZero()) {
          return `0 ${currency.code}`;
        }
        return `${numberFormatter.decimal({
          value: this.available,
          decimals: currency.decimals,
          smartStripTrailingZeros: true
        })} ${currency.code}`;
      } else if (this.activeMarketStore.isPerpetual) {
        if (!this.tradeviewOrderFormStore.maxOrderAmount) {
          return "/";
        }
        if (this.tradeviewOrderFormStore.maxOrderAmount.isZero()) {
          return `0 ${(_a2 = this.activeMarketStore.activeMarket) == null ? void 0 : _a2.base}`;
        }
        return `${numberFormatter.decimal({
          value: this.tradeviewOrderFormStore.maxOrderAmount,
          decimals: ((_b = this.activeMarketStore.activeMarket) == null ? void 0 : _b.decimals.base) ?? 8,
          smartStripTrailingZeros: true
        })} ${((_c = this.activeMarketStore.activeMarket) == null ? void 0 : _c.base) ?? ""}`;
      }
      return "";
    },
    label() {
      if (this.activeMarketStore.isSpot) {
        return "Available:";
      } else if (this.activeMarketStore.isPerpetual) {
        return `Max ${this.side === constants$1.ORDER_SIDE.BUY ? "buy" : "sell"}:`;
      }
      return "";
    },
    tooltip() {
      if (this.activeMarketStore.isSpot) {
        return "Fill form with all available balance";
      } else if (this.activeMarketStore.isPerpetual) {
        return "Fill form using all available margin";
      }
      return "";
    }
  }
};
const _hoisted_1$M = { class: "balances" };
const _hoisted_2$w = {
  class: "balances__amount",
  "data-test": "balanceText"
};
const _hoisted_3$t = ["title"];
const _hoisted_4$q = { key: 1 };
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppIcon = resolveComponent("AppIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$M, [
    createBaseVNode("div", _hoisted_2$w, [
      createBaseVNode("strong", null, toDisplayString($options.label), 1),
      _cache[2] || (_cache[2] = createTextVNode()),
      $options.available.isPositive() ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "balances__link",
        title: $options.tooltip,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fill"))
      }, toDisplayString($options.formattedAmount), 9, _hoisted_3$t)) : (openBlock(), createElementBlock("div", _hoisted_4$q, toDisplayString($options.formattedAmount), 1))
    ]),
    _cache[4] || (_cache[4] = createTextVNode()),
    $setup.subAccountStore.hasSubAccounts && _ctx.$has("sub_accounts_transfer") ? (openBlock(), createElementBlock("div", {
      key: 0,
      title: "Transfer between sub accounts",
      class: "balances__link transfer",
      onClick: _cache[1] || (_cache[1] = ($event) => $setup.subAccountStore.openTransferFundsModal($options.prefilledSubAccountTransferAsset))
    }, [
      createVNode(_component_AppIcon, {
        icon: "monochrome/arrows-up-down.svg",
        class: "transfer__icon",
        size: 12
      }),
      _cache[3] || (_cache[3] = createTextVNode("\n      Transfer\n    "))
    ])) : createCommentVNode("", true)
  ]);
}
const OrderFormBalances = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$D], ["__scopeId", "data-v-cb63cd40"]]);
const _sfc_main$R = {
  name: "ProductRiskModal",
  components: {
    TradeviewModal
  },
  setup() {
    return {
      acceptedAt: useLocalStorage(
        localStorageConstants.LOCAL_STORAGE.TV_PERP_RISK_WARNING_ACCEPTED_AT,
        null
      )
    };
  },
  data() {
    return {
      isOpen: false,
      accepted: false
    };
  },
  created() {
    if (!PAGE_CONTEXT.doesUserRequirePerpRiskWarning) {
      return;
    }
    const oneDay = 24 * 3600 * 1e3;
    if (!this.acceptedAt || (/* @__PURE__ */ new Date()).getTime() - this.acceptedAt > oneDay) {
      this.isOpen = true;
    }
  },
  methods: {
    onConfirm() {
      var _a2;
      this.accepted = true;
      this.acceptedAt = (/* @__PURE__ */ new Date()).getTime();
      this.isOpen = false;
      try {
        axiosInstance.post(URLService.buildUrl("derivativesAppropriatenessDisclaimerAckResource", { user_id: "own" }));
      } catch (e) {
        (_a2 = this.$errorTracking) == null ? void 0 : _a2.trackException(e);
      }
    },
    onClose() {
      if (!this.accepted) {
        window.location = URLService.getPageUrl("dashboardRouter");
      }
    }
  }
};
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createBlock(_component_TradeviewModal, {
    "is-open": $data.isOpen,
    title: "Risk warning",
    "confirm-text": "Accept",
    "cancel-text": "Cancel",
    onClose: $options.onClose,
    onConfirm: $options.onConfirm
  }, {
    body: withCtx(() => _cache[0] || (_cache[0] = [
      createBaseVNode("p", null, [
        createTextVNode("\n        Based on your answers to the Appropriateness Test, you may not have the necessary experience and knowledge to\n        understand the risks associated with "),
        createBaseVNode("strong", null, "Perpetual Swaps"),
        createTextVNode(".\n        Therefore, they "),
        createBaseVNode("strong", null, "are NOT deemed appropriate for you as a retail client.")
      ], -1),
      createTextVNode(),
      createBaseVNode("p", { class: "mt8" }, "\n        You can still trade these products at your own risk, but be aware that you may be incurring risks that you\n        do not fully understand.\n      ", -1),
      createTextVNode(),
      createBaseVNode("p", { class: "mt8" }, "\n        This classification/appropriateness is based on the information we have about you.\n      ", -1)
    ])),
    _: 1
  }, 8, ["is-open", "onClose", "onConfirm"]);
}
const ProductRiskModal = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$C]]);
const _sfc_main$Q = {
  name: "OrderForm",
  components: {
    ProductRiskModal,
    OrderFormBalances,
    DerivativesOrderMarginInfo,
    PastPerformanceDisclaimer,
    DerivativesMarginSettings,
    DerivativesContractDetails,
    ProceedOrderButton,
    LoginPlaceholder,
    AppTooltip
  },
  props: {
    side: {
      type: String,
      required: true
    },
    orderData: {
      type: Object,
      required: true
    },
    feeEstimate: {
      type: Object,
      required: false,
      default: null
    },
    takerOnlyFeeEstimate: {
      type: Boolean,
      required: false,
      default: false
    },
    requiresMatching: {
      type: Boolean,
      required: false,
      default: false
    },
    requiresUpdateIfBonusFee: {
      type: Boolean,
      required: false,
      default: false
    },
    orderTypeDisabled: {
      type: Boolean,
      required: false,
      default: false
    },
    valid: {
      type: Boolean,
      required: false,
      default: false
    },
    dirty: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: ["clear", "fill"],
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      feeScheduleStore: useFeeScheduleStore(),
      userStateStore: useUserStateStore(),
      subAccountStore: useSubAccountStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore(),
      tradeviewMarginSettingsStore: useTradeviewMarginSettingsStore(),
      tradeviewSettlementCurrencyStore: useTradeviewSettlementCurrencyStore()
    };
  },
  data() {
    var _a2;
    return {
      REVERSAL_DISCLAIMER,
      areUkWarningsActive: ((_a2 = this.$constants) == null ? void 0 : _a2.showVaspInvestmentRiskWarning) ?? false
    };
  },
  computed: {
    feeCurrency() {
      return this.activeMarketStore.isPerpetual ? this.tradeviewSettlementCurrencyStore.activeSettlementCurrency : this.activeMarket.counter;
    },
    canNotSubmitNewLeverageOrderDueToOpenOrders() {
      if (!this.isPerpetual) {
        return false;
      }
      const hasOpenOrders = this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket.filter((o) => o.marginMode === this.tradeviewMarginSettingsStore.activeMarginMode).length > 0;
      const hasOpenPosition = this.tradeviewOpenPositionsStore.hasOpenPositionsForActiveMarketAndMarginMode;
      return hasOpenOrders && hasOpenPosition && this.tradeviewMarginSettingsStore.activeLeverage !== this.tradeviewOrderFormStore.activeOrderFormLeverage;
    },
    /** @type module:markets.Market */
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    isPerpetual() {
      return this.activeMarketStore.isPerpetual;
    },
    isPositionInLiquidation() {
      const position = this.tradeviewOpenPositionsStore.openPositionForActiveMarketAndMarginMode;
      return (position == null ? void 0 : position.status) === constants$1.POSITION_STATUS.LIQUIDATING;
    },
    shouldDisplayReversalDisclaimer() {
      var _a2, _b;
      return ((_b = (_a2 = this.$endpointsPreloadedData) == null ? void 0 : _a2.userResource) == null ? void 0 : _b.state) === "US-NY";
    },
    feeScheduleUrl() {
      return URLService.getPageUrl("fee_schedule");
    },
    feeEstimateLabel() {
      if (this.takerOnlyFeeEstimate) {
        return "Taker";
      }
      return "Maker / Taker";
    },
    formattedFeeEstimate() {
      var _a2, _b, _c, _d;
      const conditionalSlash = ((_a2 = this.feeEstimate) == null ? void 0 : _a2.taker) && ((_b = this.feeEstimate) == null ? void 0 : _b.maker) || !this.feeEstimate ? " / " : "";
      const maker = ((_c = this.feeEstimate) == null ? void 0 : _c.maker) ? this.formatFeeEstimate("maker") : "";
      const taker = ((_d = this.feeEstimate) == null ? void 0 : _d.taker) ? this.formatFeeEstimate("taker") : "";
      const currencyCode = maker || taker ? this.feeCurrency : "";
      return `${maker}${conditionalSlash}${taker} ${currencyCode}`;
    },
    fees() {
      var _a2, _b;
      return {
        maker: (_a2 = this.feeScheduleStore) == null ? void 0 : _a2.makerFee,
        taker: (_b = this.feeScheduleStore) == null ? void 0 : _b.takerFee
      };
    },
    volumeContributionRate() {
      return this.feeScheduleStore.volumeContributionRate ?? new Decimal(1);
    },
    formattedUserVolume() {
      var _a2;
      if (this.activeMarketStore.isPerpetual) {
        return false;
      }
      const value = (_a2 = this.feeScheduleStore) == null ? void 0 : _a2.unifiedVolume;
      if (!value) {
        return "";
      }
      return numberFormatter.price({ value, currencySymbol: "$" });
    },
    matchingDisabled() {
      return this.requiresMatching && this.activeMarketStore.isMatchingDisabled;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    },
    userVolumeTypeText() {
      if (PAGE_CONTEXT.derivativesEnabled) {
        if (this.isPerpetual) {
          return "derivatives";
        }
        return "spot";
      }
      return "";
    }
  },
  watch: {
    "activeMarketStore.activeMarket.key": {
      handler(newKey, oldKey) {
        if (oldKey === newKey) {
          return;
        }
        this.clear();
      },
      immediate: false,
      deep: true
    },
    "subAccountStore.activeSubAccountId": {
      handler(newId, oldId) {
        if (newId === oldId) {
          return;
        }
        this.clear();
      },
      immediate: false
    }
  },
  methods: {
    formatFeeEstimate(makerOrTaker) {
      var _a2, _b;
      if (!((_a2 = this.feeEstimate) == null ? void 0 : _a2[makerOrTaker])) {
        return null;
      }
      return numberFormatter.decimal({
        value: this.feeEstimate[makerOrTaker],
        decimals: ((_b = CURRENCIES[this.feeCurrency]) == null ? void 0 : _b.decimals) ?? 8,
        rounding: Decimal.ROUND_UP,
        smartStripTrailingZeros: true
      });
    },
    onSubmit() {
      const orderData = { ...this.orderData };
      if (orderData.expireTime) {
        orderData.expireTime = (/* @__PURE__ */ new Date()).getTime() + orderData.expireTime * 60 * 1e3;
      }
      this.tradeviewOrderFormStore.setIsOrderPlacementEnabled(false);
      this.tradeviewPrivateOrdersStore.createOrder(orderData).then(() => {
        this.clear();
        if (this.userStateStore.bonusFee.greaterThan(0) && this.requiresUpdateIfBonusFee) {
          this.userStateStore.fetch();
        }
        this.tradeviewMarginSettingsStore.fetchMarginSettingsForMarket();
      }).catch(() => {
        this.clear();
      }).finally(() => {
        this.tradeviewOrderFormStore.setIsOrderPlacementEnabled(true);
      });
    },
    clear() {
      this.$emit("clear");
    }
  }
};
const _hoisted_1$L = {
  key: 0,
  class: "error"
};
const _hoisted_2$v = {
  key: 1,
  class: "error"
};
const _hoisted_3$s = {
  key: 2,
  class: "error"
};
const _hoisted_4$p = {
  key: 3,
  class: "error"
};
const _hoisted_5$k = {
  key: 4,
  class: "error"
};
const _hoisted_6$h = {
  key: 2,
  class: "trading-disclaimer"
};
const _hoisted_7$f = {
  key: 4,
  class: "info-section"
};
const _hoisted_8$f = {
  key: 0,
  class: "info-section__item info-section__item--reversal-notice"
};
const _hoisted_9$d = { class: "info-section__item-title" };
const _hoisted_10$d = { key: 0 };
const _hoisted_11$c = { key: 1 };
const _hoisted_12$a = { key: 2 };
const _hoisted_13$a = { key: 3 };
const _hoisted_14$a = ["href"];
const _hoisted_15$a = { class: "info-section__item" };
const _hoisted_16$a = { class: "info-section__label" };
const _hoisted_17$a = { "data-test": "feeEstimate" };
const _hoisted_18$9 = { class: "info-section__item" };
const _hoisted_19$7 = { "data-test": "feeRate" };
const _hoisted_20$7 = {
  key: 0,
  class: "info-section__item"
};
const _hoisted_21$7 = { "data-test": "userVolume" };
const _hoisted_22$7 = {
  key: 1,
  class: "info-section__item"
};
const _hoisted_23$5 = { class: "info-section__label" };
const _hoisted_24$5 = { "data-test": "volumeContributionRate" };
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_OrderFormBalances = resolveComponent("OrderFormBalances");
  const _component_DerivativesMarginSettings = resolveComponent("DerivativesMarginSettings");
  const _component_ProceedOrderButton = resolveComponent("ProceedOrderButton");
  const _component_DerivativesOrderMarginInfo = resolveComponent("DerivativesOrderMarginInfo");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_LoginPlaceholder = resolveComponent("LoginPlaceholder");
  const _component_PastPerformanceDisclaimer = resolveComponent("PastPerformanceDisclaimer");
  const _component_DerivativesContractDetails = resolveComponent("DerivativesContractDetails");
  const _component_ProductRiskModal = resolveComponent("ProductRiskModal");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_OrderFormBalances, {
      side: $props.side,
      onFill: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fill"))
    }, null, 8, ["side"]),
    _cache[31] || (_cache[31] = createTextVNode()),
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    _cache[32] || (_cache[32] = createTextVNode()),
    $options.isAuthenticated && $options.isPerpetual ? (openBlock(), createBlock(_component_DerivativesMarginSettings, {
      key: 0,
      "is-order-form-dirty": $props.dirty
    }, null, 8, ["is-order-form-dirty"])) : createCommentVNode("", true),
    _cache[33] || (_cache[33] = createTextVNode()),
    $options.isAuthenticated ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      !$setup.userStateStore.state.canTrade ? (openBlock(), createElementBlock("p", _hoisted_1$L, _cache[1] || (_cache[1] = [
        createTextVNode("\n        You cannot place orders just yet."),
        createBaseVNode("br", null, null, -1),
        createTextVNode("\n        Please make sure you are verified and have 2FA enabled.\n      ")
      ]))) : $setup.userStateStore.state.isTradingBlocked ? (openBlock(), createElementBlock("p", _hoisted_2$v, "\n        Trading is currently unavailable for your account.\n      ")) : createCommentVNode("", true),
      _cache[2] || (_cache[2] = createTextVNode()),
      $options.matchingDisabled ? (openBlock(), createElementBlock("p", _hoisted_3$s, "\n        Only Limit orders are currently available for this market.\n      ")) : createCommentVNode("", true),
      _cache[3] || (_cache[3] = createTextVNode()),
      $options.canNotSubmitNewLeverageOrderDueToOpenOrders ? (openBlock(), createElementBlock("p", _hoisted_4$p, "\n        You can not submit orders with a different leverage than your open position, while you have open orders.\n      ")) : createCommentVNode("", true),
      _cache[4] || (_cache[4] = createTextVNode()),
      $options.isPositionInLiquidation ? (openBlock(), createElementBlock("p", _hoisted_5$k, "\n        You can not submit orders while your position is being liquidated.\n      ")) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _cache[34] || (_cache[34] = createTextVNode()),
    $options.activeMarket.tradingDisclaimer ? (openBlock(), createElementBlock("div", _hoisted_6$h, toDisplayString($options.activeMarket.tradingDisclaimer), 1)) : createCommentVNode("", true),
    _cache[35] || (_cache[35] = createTextVNode()),
    createVNode(_component_ProceedOrderButton, {
      side: $props.side,
      disable: !$options.isAuthenticated || !$props.valid || $options.matchingDisabled || $options.canNotSubmitNewLeverageOrderDueToOpenOrders || $props.orderTypeDisabled || $options.isPositionInLiquidation,
      "data-test": "submitOrderButton",
      onClick: $options.onSubmit
    }, null, 8, ["side", "disable", "onClick"]),
    _cache[36] || (_cache[36] = createTextVNode()),
    $options.isAuthenticated && $options.isPerpetual ? (openBlock(), createBlock(_component_DerivativesOrderMarginInfo, { key: 3 })) : createCommentVNode("", true),
    _cache[37] || (_cache[37] = createTextVNode()),
    $options.isAuthenticated ? (openBlock(), createElementBlock("div", _hoisted_7$f, [
      $options.shouldDisplayReversalDisclaimer ? (openBlock(), createElementBlock("div", _hoisted_8$f, toDisplayString($data.REVERSAL_DISCLAIMER) + " By continuing, you agree that you have reviewed and acknowledged this disclosure.\n      ", 1)) : createCommentVNode("", true),
      _cache[30] || (_cache[30] = createTextVNode()),
      ((_a2 = $setup.feeScheduleStore) == null ? void 0 : _a2.initialized) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", _hoisted_9$d, [
          createVNode(_component_AppTooltip, null, {
            trigger: withCtx(() => _cache[5] || (_cache[5] = [
              createBaseVNode("span", { class: "info-section__item-title-tooltip-indicator" }, "\n                Estimated Fee\n              ", -1)
            ])),
            default: withCtx(() => [
              _cache[10] || (_cache[10] = createTextVNode()),
              _cache[11] || (_cache[11] = createBaseVNode("p", null, [
                createBaseVNode("strong", null, "Fee rates")
              ], -1)),
              _cache[12] || (_cache[12] = createTextVNode()),
              !$setup.activeMarketStore.isPerpetual ? (openBlock(), createElementBlock("p", _hoisted_10$d, "\n              Applicable fee rates are based on your 30-day " + toDisplayString($options.userVolumeTypeText) + " trading volume,\n              calculated at trade execution.\n            ", 1)) : createCommentVNode("", true),
              _cache[13] || (_cache[13] = createTextVNode()),
              _cache[14] || (_cache[14] = createBaseVNode("p", null, "\n              The fee might differ when an order is filled immediately (Taker) or at a later time (Maker).\n            ", -1)),
              _cache[15] || (_cache[15] = createTextVNode()),
              !$setup.activeMarketStore.isPerpetual ? (openBlock(), createElementBlock("p", _hoisted_11$c, _cache[6] || (_cache[6] = [
                createBaseVNode("strong", null, "30-day trading volume", -1)
              ]))) : createCommentVNode("", true),
              _cache[16] || (_cache[16] = createTextVNode()),
              $options.userVolumeTypeText ? (openBlock(), createElementBlock("p", _hoisted_12$a, "\n              Spot and Derivatives markets accumulate trading volumes separately.\n            ")) : createCommentVNode("", true),
              _cache[17] || (_cache[17] = createTextVNode()),
              !$setup.activeMarketStore.isPerpetual ? (openBlock(), createElementBlock("p", _hoisted_13$a, "\n              Note that your 30-day " + toDisplayString($options.userVolumeTypeText) + " trading volume might take a few minutes to update after a\n              trade is processed.\n            ", 1)) : createCommentVNode("", true),
              _cache[18] || (_cache[18] = createTextVNode()),
              !$options.volumeContributionRate.eq(1) ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
                _cache[8] || (_cache[8] = createBaseVNode("p", null, [
                  createBaseVNode("strong", null, "Volume contribution rate")
                ], -1)),
                _cache[9] || (_cache[9] = createTextVNode()),
                createBaseVNode("p", null, [
                  createTextVNode("\n                This market has a custom 30-day " + toDisplayString($options.userVolumeTypeText) + " trading volume contribution rate of\n                " + toDisplayString($options.volumeContributionRate.mul(100).toFixed()) + "%.\n                ", 1),
                  _cache[7] || (_cache[7] = createBaseVNode("br", null, null, -1)),
                  createTextVNode("This means a $1000 value trade will contribute $" + toDisplayString($options.volumeContributionRate.mul(1e3).toFixed()) + "\n                to your 30-day " + toDisplayString($options.userVolumeTypeText) + " trading volume.\n              ", 1)
                ])
              ], 64)) : createCommentVNode("", true),
              _cache[19] || (_cache[19] = createTextVNode()),
              createBaseVNode("a", {
                href: $options.feeScheduleUrl,
                target: "_blank",
                class: "link"
              }, "\n              Learn more.\n            ", 8, _hoisted_14$a)
            ]),
            _: 1
          })
        ]),
        _cache[26] || (_cache[26] = createTextVNode()),
        createBaseVNode("div", _hoisted_15$a, [
          createBaseVNode("span", _hoisted_16$a, toDisplayString($options.feeEstimateLabel), 1),
          _cache[20] || (_cache[20] = createTextVNode()),
          createBaseVNode("span", _hoisted_17$a, toDisplayString($options.formattedFeeEstimate), 1)
        ]),
        _cache[27] || (_cache[27] = createTextVNode()),
        createBaseVNode("div", _hoisted_18$9, [
          _cache[21] || (_cache[21] = createBaseVNode("span", { class: "info-section__label" }, "Maker / Taker rate", -1)),
          _cache[22] || (_cache[22] = createTextVNode()),
          createBaseVNode("span", _hoisted_19$7, toDisplayString($options.fees.maker) + "% / " + toDisplayString($options.fees.taker) + "%", 1)
        ]),
        _cache[28] || (_cache[28] = createTextVNode()),
        $options.formattedUserVolume ? (openBlock(), createElementBlock("div", _hoisted_20$7, [
          _cache[23] || (_cache[23] = createBaseVNode("span", { class: "info-section__label" }, "30-day trading volume", -1)),
          _cache[24] || (_cache[24] = createTextVNode()),
          createBaseVNode("span", _hoisted_21$7, toDisplayString($options.formattedUserVolume), 1)
        ])) : createCommentVNode("", true),
        _cache[29] || (_cache[29] = createTextVNode()),
        !$options.volumeContributionRate.eq(1) ? (openBlock(), createElementBlock("div", _hoisted_22$7, [
          createBaseVNode("span", _hoisted_23$5, toDisplayString($options.activeMarket.name) + " volume contribution", 1),
          _cache[25] || (_cache[25] = createTextVNode()),
          createBaseVNode("span", _hoisted_24$5, toDisplayString($options.volumeContributionRate.mul(100).toFixed()) + "%", 1)
        ])) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    _cache[38] || (_cache[38] = createTextVNode()),
    !$options.isAuthenticated ? (openBlock(), createBlock(_component_LoginPlaceholder, {
      key: 5,
      class: "mt8"
    })) : createCommentVNode("", true),
    _cache[39] || (_cache[39] = createTextVNode()),
    _ctx.$isExtraLarge ? (openBlock(), createBlock(_component_PastPerformanceDisclaimer, {
      key: 6,
      class: "past-performance-disclaimer",
      pro: ""
    })) : createCommentVNode("", true),
    _cache[40] || (_cache[40] = createTextVNode()),
    $options.isPerpetual ? (openBlock(), createBlock(_component_DerivativesContractDetails, { key: 7 })) : createCommentVNode("", true),
    _cache[41] || (_cache[41] = createTextVNode()),
    $options.isPerpetual ? (openBlock(), createBlock(_component_ProductRiskModal, { key: 8 })) : createCommentVNode("", true)
  ]);
}
const OrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$B], ["__scopeId", "data-v-1a121c53"]]);
const maxAmountMessage = ({ side, availableBalances }) => {
  const activeMarket = useActiveMarketStore().activeMarket;
  const zeroBalanceHandler = (currency) => `You have no ${currency} available`;
  let formattedAvailableBalance;
  if (side === constants$1.ORDER_SIDE.BUY) {
    if (availableBalances.counter.isZero()) {
      return zeroBalanceHandler(activeMarket.counter);
    }
    formattedAvailableBalance = numberFormatter.amount({
      value: availableBalances.counter,
      decimals: useCurrenciesStore().getCurrency(activeMarket.counter).decimals,
      currencyCode: activeMarket.counter
    });
  } else {
    if (availableBalances.base.isZero()) {
      return zeroBalanceHandler(activeMarket.base);
    }
    formattedAvailableBalance = numberFormatter.amount({
      value: availableBalances.base,
      decimals: useCurrenciesStore().getCurrency(activeMarket.base).decimals,
      currencyCode: activeMarket.base
    });
  }
  return `You only have ${formattedAvailableBalance} available`;
};
const minOrderValueMessage = () => {
  const activeMarket = useActiveMarketStore().activeMarket;
  const value = numberFormatter.amount({
    value: activeMarket.minOrderValue,
    decimals: activeMarket.decimals.counter,
    currencyCode: activeMarket.counter
  });
  return `Minimum order value is ${value}`;
};
const maxOrderValueMessage = () => {
  return `Ensure this value is less than or equal to ${constants$1.ORDER_VALIDATION.MAX_NUMBER}`;
};
const maxNumber = {
  message: maxOrderValueMessage,
  validate(value) {
    if (!value) {
      return true;
    }
    try {
      value = new Decimal(value);
    } catch (e) {
      return true;
    }
    return value.lessThanOrEqualTo(constants$1.ORDER_VALIDATION.MAX_NUMBER);
  }
};
const minCounterQuantity = {
  message: minOrderValueMessage,
  validate(counterQty) {
    return toDecimal(counterQty).greaterThanOrEqualTo(useActiveMarketStore().activeMarket.minOrderValue);
  }
};
const minBaseQuantity = {
  message: minOrderValueMessage,
  validate(baseQty, { side, activeMarketCurrentOffer }) {
    const activeMarket = useActiveMarketStore().activeMarket;
    const bestOffer = side === constants$1.ORDER_SIDE.BUY ? activeMarketCurrentOffer.ask : activeMarketCurrentOffer.bid;
    return toDecimal(baseQty).mul(bestOffer).greaterThanOrEqualTo(activeMarket.minOrderValue);
  }
};
const GROSS = 0;
const NET = 1;
const REQUESTED_VOLUME = 2;
const CONVERSION_ERROR = "conversion-error";
const calculateFeeForOrderVolume = (orderVolume, currency, currencyFeePrecision, feeBrackets, userVolume, volumeContributionRate, type, isMaker, conversionPath, tickers) => {
  let usdConversionRate = new Decimal(1);
  if (currency !== constants.CURRENCIES.CURRENCY_USD) {
    const [responseRate, error] = conversionPathToPrice(conversionPath, tickers);
    usdConversionRate = responseRate;
    if (!usdConversionRate) {
      throw new Error(`Failed to convert from ${currency} to USD. Reason: ${error}`, { cause: CONVERSION_ERROR });
    }
  }
  let orderVolumeToApplyFeeTo = orderVolume.mul(usdConversionRate);
  if (!orderVolumeToApplyFeeTo.isPositive() || ((feeBrackets == null ? void 0 : feeBrackets.length) ?? 0) < 1) {
    return new Decimal(0);
  }
  let newUserVolume = userVolume;
  let fee = new Decimal(0);
  let currentIndex = -1;
  while (orderVolumeToApplyFeeTo.isPositive()) {
    currentIndex++;
    let freeVolumeInBracket = feeBrackets[currentIndex].volume.sub(newUserVolume);
    if (!freeVolumeInBracket.isPositive()) {
      if (!feeBrackets[currentIndex + 1]) {
        freeVolumeInBracket = orderVolumeToApplyFeeTo;
      } else {
        continue;
      }
    }
    const makerOrTaker = isMaker ? "maker" : "taker";
    const bracketDelta = _calculateFeeDeltasAtBracket(
      makerOrTaker,
      feeBrackets[currentIndex],
      feeBrackets[currentIndex + 1],
      freeVolumeInBracket,
      orderVolumeToApplyFeeTo,
      volumeContributionRate,
      type
    );
    fee = fee.add(bracketDelta.fee);
    orderVolumeToApplyFeeTo = orderVolumeToApplyFeeTo.sub(bracketDelta.orderVolumeDelta);
    newUserVolume = newUserVolume.add(bracketDelta.userVolumeDelta);
  }
  return fee.div(usdConversionRate).toDecimalPlaces(currencyFeePrecision, Decimal.ROUND_HALF_UP);
};
const _calculateFeeDeltasAtBracket = (makerOrTaker, currenBracket, nextBracket, freeVolumeInBracket, orderVolume, volumeContributionRate, type) => {
  switch (type) {
    case NET:
      return _calculateNetFeeDeltasAtBracket(
        makerOrTaker,
        currenBracket,
        nextBracket,
        freeVolumeInBracket,
        orderVolume,
        volumeContributionRate
      );
    case GROSS:
      return _calculateGrossFeeDeltasAtBracket(
        makerOrTaker,
        currenBracket,
        nextBracket,
        freeVolumeInBracket,
        orderVolume,
        volumeContributionRate
      );
    case REQUESTED_VOLUME:
      return _calculateRequestedVolumeFeeDeltasAtBracket(
        makerOrTaker,
        currenBracket,
        nextBracket,
        freeVolumeInBracket,
        orderVolume,
        volumeContributionRate
      );
  }
};
const _calculateNetFeeDeltasAtBracket = (makerOrTaker, currenBracket, nextBracket, freeVolumeInBracket, orderVolume, volumeContributionRate) => {
  freeVolumeInBracket = freeVolumeInBracket.div(volumeContributionRate);
  let volumeToUseInBracket = freeVolumeInBracket;
  if (freeVolumeInBracket.gte(orderVolume) || !nextBracket || currenBracket[makerOrTaker].gte(nextBracket[makerOrTaker])) {
    volumeToUseInBracket = orderVolume;
  }
  return {
    fee: volumeToUseInBracket.mul(currenBracket[makerOrTaker]),
    orderVolumeDelta: volumeToUseInBracket,
    userVolumeDelta: volumeToUseInBracket.mul(volumeContributionRate)
  };
};
const _calculateGrossFeeDeltasAtBracket = (makerOrTaker, currenBracket, nextBracket, freeVolumeInBracket, orderVolume, volumeContributionRate) => {
  const feeForFinalBracket = orderVolume.sub(orderVolume.div(currenBracket[makerOrTaker].add(1)));
  const netOrderValue = orderVolume.sub(feeForFinalBracket);
  freeVolumeInBracket = freeVolumeInBracket.div(volumeContributionRate);
  if (freeVolumeInBracket.gte(netOrderValue) || !nextBracket || currenBracket[makerOrTaker].gte(nextBracket[makerOrTaker])) {
    return {
      fee: feeForFinalBracket,
      orderVolumeDelta: orderVolume,
      userVolumeDelta: netOrderValue.mul(volumeContributionRate)
    };
  }
  const bracketFee = freeVolumeInBracket.mul(currenBracket[makerOrTaker]);
  return {
    fee: bracketFee,
    orderVolumeDelta: freeVolumeInBracket.add(bracketFee),
    userVolumeDelta: freeVolumeInBracket.mul(volumeContributionRate)
  };
};
const _calculateRequestedVolumeFeeDeltasAtBracket = (makerOrTaker, currenBracket, nextBracket, freeVolumeInBracket, requestedOrderVolume, volumeContributionRate) => {
  const feeForFinalBracket = currenBracket[makerOrTaker].mul(requestedOrderVolume).div(new Decimal(1).sub(currenBracket[makerOrTaker]));
  const netOrderValue = requestedOrderVolume.add(feeForFinalBracket);
  freeVolumeInBracket = freeVolumeInBracket.div(volumeContributionRate);
  if (freeVolumeInBracket.gte(netOrderValue) || !nextBracket || currenBracket[makerOrTaker].gte(nextBracket[makerOrTaker])) {
    return {
      fee: feeForFinalBracket,
      orderVolumeDelta: requestedOrderVolume,
      userVolumeDelta: netOrderValue.mul(volumeContributionRate)
    };
  }
  const bracketFee = freeVolumeInBracket.mul(currenBracket[makerOrTaker]);
  return {
    fee: bracketFee,
    orderVolumeDelta: freeVolumeInBracket.sub(bracketFee),
    userVolumeDelta: freeVolumeInBracket.mul(volumeContributionRate)
  };
};
const calculateLimitOrderPercentage = (price, amount, isBuyOrder, counterDecimals, getTradeviewFeeCalculators, getBalancesStore) => {
  if (!price || amount === "") {
    return 0;
  }
  const decimalPrice = toDecimal(price);
  const decimalAmount = toDecimal(amount);
  if (!decimalPrice.isPositive() || !decimalAmount.isPositive()) {
    return 0;
  }
  const availableBalances = getBalancesStore().activeMarketAccountAvailableBalance;
  if (isBuyOrder) {
    if (!availableBalances.counter.isPositive()) {
      return 0;
    }
    let orderValue = decimalAmount.mul(decimalPrice);
    const fee = getTradeviewFeeCalculators().calculateNetVolumeFeeForActiveMarketNoBonus(orderValue);
    orderValue = orderValue.add(fee).toDecimalPlaces(counterDecimals, Decimal.ROUND_UP);
    const fraction = orderValue.div(availableBalances.counter);
    return Math.min(100, Number.parseInt(fraction.mul(100).toFixed(0)));
  }
  if (!availableBalances.base.isPositive()) {
    return 0;
  } else {
    return Math.min(100, Number.parseInt(decimalAmount.div(availableBalances.base).mul(100).toFixed(0)));
  }
};
const calculateLimitOrderAmountFromPercentage = (percent, price, isBuyOrder, baseDecimals, counterDecimals, getTradeviewFeeCalculators, getBalancesStore) => {
  const fraction = new Decimal(percent).div(100);
  const decimalPrice = toDecimal(price);
  const availableBalances = getBalancesStore().activeMarketAccountAvailableBalance;
  let maxAmount2 = availableBalances.base;
  if (isBuyOrder) {
    if (decimalPrice.lessThanOrEqualTo(0)) {
      return "";
    }
    const availableCounter = availableBalances.counter.toDecimalPlaces(counterDecimals, Decimal.ROUND_DOWN);
    const fee = getTradeviewFeeCalculators().calculateGrossVolumeFeeForActiveMarketNoBonus(availableCounter);
    const balanceToSpend = availableCounter.sub(fee).toDecimalPlaces(counterDecimals, Decimal.ROUND_DOWN);
    maxAmount2 = balanceToSpend.div(decimalPrice).toDecimalPlaces(baseDecimals, Decimal.ROUND_DOWN);
  }
  return numberFormatter.formatWithStrippedTrailingZeros(
    maxAmount2.mul(fraction).toDecimalPlaces(baseDecimals, Decimal.ROUND_DOWN),
    baseDecimals
  );
};
const calcAmountAndValueBasedOnPrice = (price, amount, value, baseDecimals, counterDecimals) => {
  const decimalAmount = toDecimal(amount);
  const priceAsDecimal = toDecimal(price);
  let formattedAmount = amount;
  let formattedValue = value;
  if (!decimalAmount.isZero()) {
    formattedValue = numberFormatter.formatWithStrippedTrailingZeros(
      decimalAmount.mul(priceAsDecimal).toDecimalPlaces(counterDecimals, Decimal.ROUND_UP),
      counterDecimals
    );
  }
  if (amount === "" && value !== "" && !priceAsDecimal.isZero()) {
    formattedAmount = numberFormatter.formatWithStrippedTrailingZeros(
      toDecimal(value).div(priceAsDecimal).toDecimalPlaces(baseDecimals, Decimal.ROUND_DOWN),
      baseDecimals
    );
  }
  return {
    amount: formattedAmount,
    value: formattedValue
  };
};
const orderUtils = {
  NET,
  GROSS,
  REQUESTED_VOLUME,
  CONVERSION_ERROR,
  calculateFeeForOrderVolume,
  calculateLimitOrderPercentage,
  calculateLimitOrderAmountFromPercentage,
  calcAmountAndValueBasedOnPrice
};
function useTradeviewFeeCalculators() {
  const activeMarketStore = useActiveMarketStore();
  const feeScheduleStore = useFeeScheduleStore();
  const tradeviewTickersStore = useTradeviewTickersStore();
  const currenciesStore = useCurrenciesStore();
  const conversionPathStore = useConversionPathStore();
  const userStateStore = useUserStateStore();
  const $errorTracking = useErrorTracking();
  function _calculateFeeForActiveMarket(orderVolume, feeType, useBonusFee, isMaker) {
    if (useBonusFee && userStateStore.bonusFee.isPositive()) {
      return toDecimal(0);
    }
    const activeCounter = activeMarketStore.activeMarket.counter;
    const currencyFeePrecision = currenciesStore.getCurrency(activeCounter).tradingFeeDecimals ?? 8;
    try {
      return orderUtils.calculateFeeForOrderVolume(
        orderVolume,
        activeCounter,
        currencyFeePrecision,
        feeScheduleStore.feeBrackets,
        feeScheduleStore.unifiedVolume,
        feeScheduleStore.volumeContributionRate,
        feeType,
        isMaker,
        conversionPathStore.getUsdConversionPath(activeCounter),
        tradeviewTickersStore.tickers
      );
    } catch (e) {
      if (e.cause === orderUtils.CONVERSION_ERROR) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        return toDecimal(0);
      } else {
        throw e;
      }
    }
  }
  function calculateGrossVolumeFeeForActiveMarket(orderVolume, isMaker = false) {
    return _calculateFeeForActiveMarket(orderVolume, orderUtils.GROSS, true, isMaker);
  }
  function calculateNetVolumeFeeForActiveMarket(orderVolume, isMaker = false) {
    return _calculateFeeForActiveMarket(orderVolume, orderUtils.NET, true, isMaker);
  }
  function calculateGrossVolumeFeeForActiveMarketNoBonus(orderVolume, isMaker = false) {
    return _calculateFeeForActiveMarket(orderVolume, orderUtils.GROSS, false, isMaker);
  }
  function calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, isMaker = false) {
    return _calculateFeeForActiveMarket(orderVolume, orderUtils.NET, false, isMaker);
  }
  return {
    calculateGrossVolumeFeeForActiveMarket,
    calculateNetVolumeFeeForActiveMarket,
    calculateGrossVolumeFeeForActiveMarketNoBonus,
    calculateNetVolumeFeeForActiveMarketNoBonus
  };
}
const maxCounterQuantity = {
  message({ maxBalancePercentage, side, availableBalances }) {
    const activeMarket = useActiveMarketStore().activeMarket;
    const zeroBalanceHandler = (currency2) => `You have no ${currency2} available`;
    if (side === constants$1.ORDER_SIDE.SELL) {
      if (availableBalances.base.isZero()) {
        return zeroBalanceHandler(activeMarket.base);
      }
      return `You can only use ${maxBalancePercentage}% of your balance for a single order when using Total. Use Amount as input for larger orders`;
    }
    if (availableBalances.counter.isZero()) {
      return zeroBalanceHandler(activeMarket.counter);
    }
    const currency = useCurrenciesStore().getCurrency(activeMarket.counter);
    const formattedAvailableBalance = numberFormatter.amount({
      value: availableBalances.counter,
      decimals: currency.decimals,
      currencyCode: activeMarket.counter
    });
    return `You only have ${formattedAvailableBalance} available`;
  },
  validate(counterQty, { maxBalancePercentage, side, availableBalances, activeMarketCurrentOffer }) {
    if (useSubAccountStore().doesActiveAccountAllowNegativeBalances) {
      return true;
    }
    counterQty = toDecimal(counterQty);
    if (side === constants$1.ORDER_SIDE.BUY) {
      return availableBalances.counter.greaterThanOrEqualTo(counterQty);
    } else {
      const bestOffer = activeMarketCurrentOffer.bid;
      if (bestOffer.isZero()) {
        return true;
      }
      const fee = useTradeviewFeeCalculators().calculateNetVolumeFeeForActiveMarket(counterQty);
      const decimals = useActiveMarketStore().activeMarket.decimals.counter;
      const value = counterQty.plus(fee).toDecimalPlaces(decimals, Decimal.ROUND_DOWN);
      const availableBalanceFraction = new Decimal(maxBalancePercentage).div(100).mul(availableBalances.base);
      return availableBalanceFraction.greaterThanOrEqualTo(value.div(bestOffer));
    }
  }
};
const maxBaseQuantity = {
  message({ maxBalancePercentage, side, availableBalances }) {
    const activeMarket = useActiveMarketStore().activeMarket;
    const zeroBalanceHandler = (currency2) => `You have no ${currency2} available`;
    if (side === constants$1.ORDER_SIDE.BUY) {
      if (availableBalances.counter.isZero()) {
        return zeroBalanceHandler(activeMarket.counter);
      }
      return `You can only use ${maxBalancePercentage}% of your balance for a single order when using Amount. Use Total as input for larger orders`;
    }
    if (availableBalances.base.isZero()) {
      return zeroBalanceHandler(activeMarket.base);
    }
    const currency = useCurrenciesStore().getCurrency(activeMarket.base);
    const available = numberFormatter.amount({
      value: availableBalances.base,
      decimals: currency.decimals,
      currencyCode: activeMarket.base
    });
    return `You only have ${available} available`;
  },
  validate(amount, { maxBalancePercentage, side, availableBalances, activeMarketCurrentOffer }) {
    if (useSubAccountStore().doesActiveAccountAllowNegativeBalances) {
      return true;
    }
    if (side === constants$1.ORDER_SIDE.BUY) {
      try {
        const bestOffer = activeMarketCurrentOffer.ask;
        const decimals = useActiveMarketStore().activeMarket.decimals.counter;
        let orderValue = new Decimal(amount).mul(bestOffer);
        const fee = useTradeviewFeeCalculators().calculateNetVolumeFeeForActiveMarket(orderValue);
        orderValue = orderValue.add(fee).toDecimalPlaces(decimals, Decimal.ROUND_UP);
        const availableBalanceFraction = new Decimal(maxBalancePercentage).div(100).mul(availableBalances.counter);
        return orderValue.lessThanOrEqualTo(availableBalanceFraction);
      } catch (e) {
        return false;
      }
    } else {
      return availableBalances.base.greaterThanOrEqualTo(toDecimal(amount));
    }
  }
};
defineRule("marketOrder_maxBaseQuantity", wrapper(maxBaseQuantity));
defineRule("marketOrder_minBaseQuantity", wrapper(minBaseQuantity));
defineRule("marketOrder_maxNumber", wrapper(maxNumber));
defineRule("marketOrder_maxCounterQuantity", wrapper(maxCounterQuantity));
defineRule("marketOrder_minCounterQuantity", wrapper(minCounterQuantity));
function useMarketOrder() {
  const orderbook100Store = useOrderbook100Store();
  const tradeviewTickersStore = useTradeviewTickersStore();
  function getCounterValueFromOrderBook(baseToConvert, side) {
    var _a2;
    const orderbook = ((_a2 = orderbook100Store.orderbook) == null ? void 0 : _a2[side]) ?? [];
    let netCounterValue = new Decimal(0);
    let lastPrice = tradeviewTickersStore.activeMarketTickerLastValue;
    for (const { amount, price } of orderbook) {
      if (!baseToConvert.isPositive()) {
        break;
      }
      const qty = baseToConvert.lessThan(amount) ? baseToConvert : new Decimal(amount);
      netCounterValue = netCounterValue.add(qty.mul(price));
      lastPrice = new Decimal(price);
      baseToConvert = baseToConvert.sub(qty);
    }
    if (baseToConvert.greaterThan(0) && lastPrice.greaterThan(0)) {
      const value = baseToConvert.mul(lastPrice);
      netCounterValue = netCounterValue.add(value);
    }
    return netCounterValue;
  }
  function getBaseValueFromOrderBook(counterToConvert, side) {
    var _a2;
    const orderbook = ((_a2 = orderbook100Store.orderbook) == null ? void 0 : _a2[side]) ?? [];
    let baseValue = new Decimal(0);
    let lastPrice = tradeviewTickersStore.activeMarketTickerLastValue;
    for (const { price, value } of orderbook) {
      if (!counterToConvert.isPositive() || price === 0) {
        break;
      }
      const counterQty = counterToConvert.lessThan(value) ? counterToConvert : new Decimal(value);
      baseValue = baseValue.add(counterQty.div(price));
      lastPrice = new Decimal(price);
      counterToConvert = counterToConvert.sub(counterQty);
    }
    if (counterToConvert.greaterThan(0) && lastPrice.greaterThan(0)) {
      const value = counterToConvert.div(lastPrice);
      baseValue = baseValue.add(value);
    }
    return baseValue;
  }
  return {
    getCounterValueFromOrderBook,
    getBaseValueFromOrderBook
  };
}
const _hoisted_1$K = {
  key: 0,
  class: "buy-sell-text"
};
const MARKET_BUY$1 = 0;
const MARKET_SELL$1 = 1;
const INSTANT_BUY$1 = 2;
const CASH_SELL$1 = 3;
const CAPPED_BALANCE_PERCENTAGE = 90;
const _sfc_main$P = {
  __name: "MarketOrderForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const marketOrderUtils = useMarketOrder();
    const getBaseValueFromOrderBook = marketOrderUtils.getBaseValueFromOrderBook;
    const getCounterValueFromOrderBook = marketOrderUtils.getCounterValueFromOrderBook;
    const tradeviewFeeCalculators = useTradeviewFeeCalculators();
    const tradeviewSettingsStore = useTradeviewSettingsStore();
    const activeMarketStore = useActiveMarketStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const orderbook100Store = useOrderbook100Store();
    const balancesStore = useBalancesStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const percentage = ref(0);
    const amount = ref("");
    const total = ref("");
    const throttledEstimateUpdater = _.throttle(updateEstimate, 1e3);
    const throttledForceRevalidate = _.throttle(
      function() {
        if (amount.value || total.value) {
          validate();
        }
      },
      1e3
    );
    const activeMarket = computed(() => activeMarketStore.activeMarket);
    const isTotalInputInCalcMode = computed(() => {
      return tradeviewSettingsStore.marketOrderFormInputType === constants.MARKET_ORDER_FORM_INPUT.AMOUNT;
    });
    const orderInterface = computed(() => {
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        if (isTotalInputInCalcMode.value) {
          return MARKET_BUY$1;
        }
        return INSTANT_BUY$1;
      }
      if (isTotalInputInCalcMode.value) {
        return MARKET_SELL$1;
      }
      return CASH_SELL$1;
    });
    const maxOrderSliderValue = computed(() => {
      if (orderInterface.value === CASH_SELL$1 || orderInterface.value === MARKET_BUY$1) {
        return CAPPED_BALANCE_PERCENTAGE;
      }
      return 100;
    });
    const marks = computed(() => {
      if (orderInterface.value === CASH_SELL$1 || orderInterface.value === MARKET_BUY$1) {
        return (v) => v % 25 === 0 || v % CAPPED_BALANCE_PERCENTAGE === 0;
      }
      return (v) => v % 25 === 0;
    });
    const disabledSectionLabelInput = computed(() => {
      return props.side === constants$1.ORDER_SIDE.BUY ? "Total" : "Amount";
    });
    const disabledSectionSize = computed(() => {
      if (orderInterface.value === CASH_SELL$1 || orderInterface.value === MARKET_BUY$1) {
        return CAPPED_BALANCE_PERCENTAGE;
      }
      return void 0;
    });
    const isSliderDisabled = computed(() => {
      const balances = balancesStore.activeMarketAccountAvailableBalance;
      const side = props.side === constants$1.ORDER_SIDE.BUY ? "counter" : "base";
      return !balances[side].isPositive();
    });
    const orderData = computed(() => {
      let orderType, orderAmount;
      switch (orderInterface.value) {
        case MARKET_BUY$1:
        case MARKET_SELL$1:
          orderType = constants$1.ORDER_TYPE.MARKET;
          orderAmount = amount.value;
          break;
        case INSTANT_BUY$1:
        case CASH_SELL$1:
          orderType = constants$1.ORDER_TYPE.INSTANT;
          orderAmount = total.value;
      }
      return {
        side: props.side,
        type: orderType,
        amount: orderAmount,
        market: activeMarket.value.key,
        // Yes, we only set this for CASH_SELL, but not for INSTANT_BUY as one might intuit :)
        amountInCounter: orderInterface.value === CASH_SELL$1,
        _meta: {
          currency: isTotalInputInCalcMode.value ? activeMarket.value.base : activeMarket.value.counter,
          decimals: isTotalInputInCalcMode.value ? activeMarket.value.decimals.base : activeMarket.value.decimals.counter
        }
      };
    });
    const labels = computed(() => {
      return {
        amount: {
          external: "Amount",
          inline: activeMarket.value.base
        },
        total: {
          external: "Total",
          inline: activeMarket.value.counter
        }
      };
    });
    const validationSchema = computed(() => {
      if (isTotalInputInCalcMode.value) {
        return {
          amount: {
            required: true,
            decimal: {
              decimals: activeMarket.value.decimals.base
            },
            "marketOrder_maxBaseQuantity": {
              maxBalancePercentage: CAPPED_BALANCE_PERCENTAGE,
              side: props.side,
              availableBalances: balancesStore.activeMarketAccountAvailableBalance,
              activeMarketCurrentOffer: orderbook100Store.activeMarketCurrentOffer
            },
            "marketOrder_minBaseQuantity": {
              side: props.side,
              activeMarketCurrentOffer: orderbook100Store.activeMarketCurrentOffer
            },
            "marketOrder_maxNumber": true
          },
          total: {}
        };
      } else {
        return {
          amount: {},
          total: {
            required: true,
            decimal: {
              decimals: activeMarket.value.decimals.counter
            },
            "marketOrder_maxCounterQuantity": {
              maxBalancePercentage: CAPPED_BALANCE_PERCENTAGE,
              side: props.side,
              availableBalances: balancesStore.activeMarketAccountAvailableBalance,
              activeMarketCurrentOffer: orderbook100Store.activeMarketCurrentOffer
            },
            "marketOrder_minCounterQuantity": true,
            "marketOrder_maxNumber": true
          }
        };
      }
    });
    const currentOffer = computed(() => {
      const offer = orderbook100Store.activeMarketCurrentOffer;
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        return offer.ask;
      }
      return offer.bid;
    });
    const orderDescription = computed(() => {
      if (amount.value === "" || total.value === "") {
        return "";
      }
      let amountDecimal, totalDecimal;
      try {
        amountDecimal = new Decimal(amount.value);
        totalDecimal = new Decimal(total.value);
      } catch (e) {
        return "";
      }
      const orderSide = props.side === constants$1.ORDER_SIDE.BUY ? "Buying" : "Selling";
      const orderExchange = props.side === constants$1.ORDER_SIDE.BUY ? "using" : "for";
      const formattedAmount = numberFormatter.decimal({
        value: amountDecimal,
        decimals: activeMarket.value.decimals.base,
        currencyCode: activeMarket.value.base,
        smartStripTrailingZeros: true
      });
      const formattedTotal = numberFormatter.decimal({
        value: totalDecimal,
        decimals: activeMarket.value.decimals.counter,
        currencyCode: activeMarket.value.counter,
        smartStripTrailingZeros: true
      });
      if (isTotalInputInCalcMode.value) {
        if (!amountDecimal.isPositive()) {
          return "";
        }
        return `${orderSide} ${formattedAmount} ${activeMarket.value.base} ${orderExchange} ${activeMarket.value.counter}`;
      } else {
        if (!totalDecimal.isPositive()) {
          return "";
        }
        return `${orderSide} ${activeMarket.value.base} ${orderExchange} ${formattedTotal} ${activeMarket.value.counter}`;
      }
    });
    const estimate = computed(() => {
      if (amount.value === "" || total.value === "") {
        return "";
      }
      if (isTotalInputInCalcMode.value) {
        return `≈ ${total.value}`;
      } else {
        return `≈ ${amount.value}`;
      }
    });
    const feeEstimate = computed(() => {
      const orderVolume = toDecimal(total.value);
      if (!orderVolume.isPositive()) {
        return null;
      }
      if (orderInterface.value === INSTANT_BUY$1) {
        return {
          taker: tradeviewFeeCalculators.calculateGrossVolumeFeeForActiveMarket(orderVolume, false)
        };
      }
      return {
        taker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarket(orderVolume, false)
      };
    });
    const { meta, validate, resetForm } = useForm({ validationSchema });
    function clear() {
      amount.value = "";
      total.value = "";
      percentage.value = 0;
      nextTick(resetForm);
    }
    function updatePercentage(quantity) {
      if (!quantity) {
        return;
      }
      if (!toDecimal(quantity).isPositive()) {
        percentage.value = 0;
        return;
      }
      switch (orderInterface.value) {
        case MARKET_BUY$1:
          percentage.value = getPercentageForMarketBuy(quantity);
          return;
        case MARKET_SELL$1:
          percentage.value = getPercentageForMarketSell(quantity);
          return;
        case INSTANT_BUY$1:
          percentage.value = getPercentageForInstantBuy(quantity);
          return;
        case CASH_SELL$1:
          percentage.value = getPercentageForCashSell(quantity);
      }
    }
    function getPercentageForInstantBuy(counterTotal) {
      counterTotal = toDecimal(counterTotal);
      const availableCounterBalance = balancesStore.activeMarketAccountAvailableBalance.counter;
      if (!availableCounterBalance.isPositive() || !counterTotal.isPositive()) {
        return 0;
      }
      const p = counterTotal.div(availableCounterBalance).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(100, Number.parseInt(p.toFixed(0)));
    }
    function getPercentageForMarketBuy(baseQty) {
      baseQty = toDecimal(baseQty);
      const bestOffer = currentOffer.value;
      const availableCounterBalance = balancesStore.activeMarketAccountAvailableBalance.counter;
      if (!availableCounterBalance.isPositive() || !baseQty.isPositive() || bestOffer.isZero()) {
        return 0;
      }
      let counterQty = baseQty.mul(bestOffer);
      const fee = tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarket(counterQty);
      counterQty = counterQty.add(fee).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
      const p = counterQty.div(availableCounterBalance).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(CAPPED_BALANCE_PERCENTAGE, Number.parseInt(p.toFixed(0)));
    }
    function getPercentageForMarketSell(baseQty) {
      baseQty = toDecimal(baseQty);
      const availableBaseBalance = balancesStore.activeMarketAccountAvailableBalance.base;
      if (!availableBaseBalance.isPositive() || !baseQty.isPositive()) {
        return 0;
      }
      const p = baseQty.div(availableBaseBalance).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(100, Number.parseInt(p.toFixed(0)));
    }
    function getPercentageForCashSell(counterQty) {
      counterQty = toDecimal(counterQty);
      const bestOffer = currentOffer.value;
      const availableBaseBalance = balancesStore.activeMarketAccountAvailableBalance.base;
      if (!availableBaseBalance.isPositive() || !counterQty.isPositive() || bestOffer.isZero()) {
        return 0;
      }
      const fee = tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarket(counterQty);
      const baseAmount = counterQty.plus(fee).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN).div(bestOffer);
      const p = baseAmount.div(availableBaseBalance).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(CAPPED_BALANCE_PERCENTAGE, Number.parseInt(p.toFixed(0)));
    }
    function onPercentage(newPercentage = 1) {
      const fraction = toDecimal(newPercentage).div(100);
      const availableBalances = balancesStore.activeMarketAccountAvailableBalance;
      const price = currentOffer.value;
      if (price.isZero()) {
        return;
      }
      let newAmount = null;
      let newTotal = null;
      switch (orderInterface.value) {
        case MARKET_BUY$1: {
          if (!availableBalances.counter.isPositive()) {
            newAmount = new Decimal(0);
            break;
          }
          let counterToSpend = availableBalances.counter.mul(fraction).toDecimalPlaces(
            activeMarket.value.decimals.counter,
            Decimal.ROUND_DOWN
          );
          const fee = tradeviewFeeCalculators.calculateGrossVolumeFeeForActiveMarket(counterToSpend);
          counterToSpend = counterToSpend.sub(fee).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
          newAmount = counterToSpend.div(price).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN);
          break;
        }
        case MARKET_SELL$1: {
          if (!availableBalances.base.isPositive()) {
            newAmount = new Decimal(0);
            break;
          }
          newAmount = availableBalances.base.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN);
          break;
        }
        case INSTANT_BUY$1: {
          if (!availableBalances.counter.isPositive()) {
            newTotal = new Decimal(0);
            break;
          }
          newTotal = availableBalances.counter.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
          break;
        }
        case CASH_SELL$1: {
          if (!availableBalances.base.isPositive()) {
            newTotal = new Decimal(0);
            break;
          }
          const baseAvailable = availableBalances.base.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN);
          const counterValue = baseAvailable.mul(price);
          const fee = tradeviewFeeCalculators.calculateGrossVolumeFeeForActiveMarket(counterValue);
          newTotal = counterValue.minus(fee).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
          break;
        }
      }
      if (newTotal !== null) {
        if (newTotal.isNegative()) {
          total.value = "0";
        } else {
          total.value = numberFormatter.formatWithStrippedTrailingZeros(newTotal, activeMarket.value.decimals.counter);
        }
      } else if (newAmount !== null) {
        if (newAmount.isNegative()) {
          amount.value = "0";
        } else {
          amount.value = numberFormatter.formatWithStrippedTrailingZeros(newAmount, activeMarket.value.decimals.base);
        }
      }
    }
    function updateEstimate() {
      switch (orderInterface.value) {
        case MARKET_BUY$1: {
          total.value = numberFormatter.formatWithStrippedTrailingZeros(
            getCounterValueFromOrderBook(toDecimal(amount.value), constants.ORDERBOOK.SIDES.ASKS),
            activeMarket.value.decimals.counter
          );
          return;
        }
        case MARKET_SELL$1: {
          total.value = numberFormatter.formatWithStrippedTrailingZeros(
            getCounterValueFromOrderBook(toDecimal(amount.value), constants.ORDERBOOK.SIDES.BIDS),
            activeMarket.value.decimals.counter
          );
          return;
        }
        case INSTANT_BUY$1: {
          const fee = tradeviewFeeCalculators.calculateGrossVolumeFeeForActiveMarket(toDecimal(total.value));
          const counterNet = toDecimal(total.value).sub(fee);
          amount.value = numberFormatter.formatWithStrippedTrailingZeros(
            getBaseValueFromOrderBook(counterNet, constants.ORDERBOOK.SIDES.ASKS),
            activeMarket.value.decimals.base
          );
          return;
        }
        case CASH_SELL$1: {
          amount.value = numberFormatter.formatWithStrippedTrailingZeros(
            getBaseValueFromOrderBook(toDecimal(total.value), constants.ORDERBOOK.SIDES.BIDS),
            activeMarket.value.decimals.base
          );
        }
      }
    }
    function onAmountInput(newAmount) {
      if (newAmount === "") {
        clear();
        return;
      }
      if (!isTotalInputInCalcMode.value) {
        return;
      }
      amount.value = newAmount;
      updateEstimate();
      updatePercentage(newAmount);
    }
    function onTotalInput(newTotal) {
      if (newTotal === "") {
        clear();
        return;
      }
      if (isTotalInputInCalcMode.value) {
        return;
      }
      total.value = newTotal;
      updateEstimate();
      updatePercentage(newTotal);
    }
    function onAmountInputFocus() {
      tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.AMOUNT);
    }
    function onTotalInputFocus() {
      tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.TOTAL);
    }
    function fillAvailableBalance() {
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.TOTAL);
      } else {
        tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.AMOUNT);
      }
      onPercentage(100);
    }
    watch(activeMarket, () => {
      percentage.value = 0;
    });
    watch(
      orderInterface,
      (newValue) => {
        switch (newValue) {
          case CASH_SELL$1:
            tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.CASH);
            break;
          case INSTANT_BUY$1:
            tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.INSTANT);
            break;
          default:
            tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.MARKET);
        }
      },
      { immediate: true }
    );
    watch(() => props.side, () => {
      if (isTotalInputInCalcMode.value) {
        updatePercentage(amount.value);
      } else {
        updatePercentage(total.value);
      }
      updateEstimate();
      validate();
    });
    watch(currentOffer, () => {
      if (amount.value || total.value) {
        throttledEstimateUpdater();
        throttledForceRevalidate();
      }
    });
    watch(() => tradeviewTriggerValueStore.amountSetByTrigger, (amountSetByTrigger) => {
      if (!amountSetByTrigger) {
        return;
      }
      const currentAmount = toDecimal(amount.value);
      if (currentAmount.equals(amountSetByTrigger)) {
        return;
      }
      tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.AMOUNT);
      amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        class: "market-form",
        "order-data": orderData.value,
        side: props.side,
        "fee-estimate": feeEstimate.value,
        valid: unref(meta).valid,
        "taker-only-fee-estimate": "",
        "requires-matching": "",
        "requires-update-if-bonus-fee": "",
        onClear: clear,
        onFill: fillAvailableBalance
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(unref(OrderInputWithValidation), {
            key: `amount-${activeMarket.value.key}`,
            "model-value": isTotalInputInCalcMode.value ? amount.value : estimate.value,
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: normalizeClass([{
              "input-field--estimate": !isTotalInputInCalcMode.value,
              "input-field--selected": isTotalInputInCalcMode.value
            }, "amount-input"]),
            field: "amount",
            onFocus: onAmountInputFocus,
            onInput: onAmountInput
          }, null, 8, ["model-value", "label", "inline-label", "class"])),
          _cache[4] || (_cache[4] = createTextVNode()),
          (openBlock(), createBlock(unref(OrderSlider), {
            key: props.side,
            modelValue: percentage.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => percentage.value = $event),
            class: "market-order__slider",
            min: 0,
            max: maxOrderSliderValue.value,
            "tooltip-formatter": (v) => `${v}%`,
            marks: marks.value,
            disabled: isSliderDisabled.value,
            "disabled-section-size": disabledSectionSize.value,
            silent: "",
            "onUpdate:value": onPercentage
          }, {
            "disabled-section-label": withCtx(() => [
              createBaseVNode("p", null, "You can only use " + toDisplayString(CAPPED_BALANCE_PERCENTAGE) + "% of your balance for a single order of this type."),
              _cache[1] || (_cache[1] = createTextVNode()),
              _cache[2] || (_cache[2] = createBaseVNode("p", null, null, -1)),
              _cache[3] || (_cache[3] = createTextVNode()),
              createBaseVNode("p", null, "Use " + toDisplayString(disabledSectionLabelInput.value) + " as input for larger orders.", 1)
            ]),
            _: 1
          }, 8, ["modelValue", "max", "tooltip-formatter", "marks", "disabled", "disabled-section-size"])),
          _cache[5] || (_cache[5] = createTextVNode()),
          (openBlock(), createBlock(unref(OrderInputWithValidation), {
            key: `total-${activeMarket.value.key}`,
            "model-value": isTotalInputInCalcMode.value ? estimate.value : total.value,
            label: labels.value.total.external,
            "inline-label": labels.value.total.inline,
            class: normalizeClass([{
              "input-field--estimate": isTotalInputInCalcMode.value,
              "input-field--selected": !isTotalInputInCalcMode.value,
              "total-input--description-active": orderDescription.value
            }, "total-input"]),
            field: "total",
            onFocus: onTotalInputFocus,
            onInput: onTotalInput
          }, null, 8, ["model-value", "label", "inline-label", "class"])),
          _cache[6] || (_cache[6] = createTextVNode()),
          orderDescription.value ? (openBlock(), createElementBlock("div", _hoisted_1$K, toDisplayString(orderDescription.value), 1)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["order-data", "side", "fee-estimate", "valid"]);
    };
  }
};
const MarketOrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["__scopeId", "data-v-7cdf353c"]]);
const maxAmount$2 = {
  message: ({ maxOrderAmount }) => {
    const activeMarket = useActiveMarketStore().activeMarket;
    const formattedMaxOrderAmount = numberFormatter.amount({
      value: maxOrderAmount,
      decimals: useCurrenciesStore().getCurrency(activeMarket.base).decimals,
      currencyCode: activeMarket.base
    });
    return `You have exceeded the maximum order amount of ${formattedMaxOrderAmount}`;
  },
  validate(amount, { maxOrderAmount }) {
    if (maxOrderAmount.isZero()) {
      return true;
    }
    return maxOrderAmount.greaterThanOrEqualTo(toDecimal(amount));
  }
};
const minAmount = {
  message: () => {
    const activeMarket = useActiveMarketStore().activeMarket;
    const formattedAmount = numberFormatter.amount({
      value: activeMarket.minOrderAmount,
      decimals: activeMarket.decimals.base,
      currencyCode: activeMarket.base
    });
    return `Minimum order amount is ${formattedAmount}`;
  },
  validate(amount) {
    return toDecimal(amount).greaterThanOrEqualTo(useActiveMarketStore().activeMarket.minOrderAmount);
  }
};
const minValueOfAmount = {
  message: () => {
    const activeMarket = useActiveMarketStore().activeMarket;
    const formattedValue = numberFormatter.amount({
      value: activeMarket.minOrderValue,
      decimals: activeMarket.decimals.counter,
      currencyCode: activeMarket.counter
    });
    return `Minimum order value is ${formattedValue}`;
  },
  validate(amount, { currentPrice }) {
    if (!amount && !toDecimal(amount).isZero() || !currentPrice || currentPrice.isZero()) {
      return true;
    }
    return toDecimal(amount).mul(currentPrice).greaterThanOrEqualTo(useActiveMarketStore().activeMarket.minOrderValue);
  }
};
const maxValue = {
  message: ({ maxValue: maxValueAsDecimal }) => {
    const activeMarket = useActiveMarketStore().activeMarket;
    const formattedMaxOrderValue = numberFormatter.amount({
      value: maxValueAsDecimal ?? toDecimal(0),
      decimals: useCurrenciesStore().getCurrency(activeMarket.counter).decimals,
      currencyCode: activeMarket.counter
    });
    return `You have exceeded the maximum order value of ${formattedMaxOrderValue}`;
  },
  validate(value, { maxValue: maxValueAsDecimal }) {
    if (maxValueAsDecimal == null ? void 0 : maxValueAsDecimal.isZero()) {
      return true;
    }
    return (maxValueAsDecimal == null ? void 0 : maxValueAsDecimal.gte(toDecimal(value))) ?? false;
  }
};
const maxAmount$1 = {
  message: ({ maxOrderAmount }) => {
    const activeMarket = useActiveMarketStore().activeMarket;
    const formattedMaxOrderAmount = numberFormatter.amount({
      value: maxOrderAmount,
      decimals: useCurrenciesStore().getCurrency(activeMarket.base).decimals,
      currencyCode: activeMarket.base
    });
    return `You have exceeded the maximum order amount of ${formattedMaxOrderAmount}`;
  },
  validate(amount, { maxOrderAmount }) {
    if (maxOrderAmount.isZero()) {
      return true;
    }
    return maxOrderAmount.gte(toDecimal(amount));
  }
};
defineRule("derivativesMarketOrder_maxNumber", wrapper(maxNumber));
defineRule("derivativesMarketOrder_minValue", wrapper(minCounterQuantity));
defineRule("derivativesMarketOrder_maxValue", wrapper(maxValue));
defineRule("derivativesMarketOrder_minValueOfAmount", wrapper(minValueOfAmount));
defineRule("derivativesMarketOrder_minAmount", wrapper(minAmount));
defineRule("derivativesMarketOrder_maxAmount", wrapper(maxAmount$1));
const _sfc_main$O = {
  name: "ReduceOnlySwitch",
  components: {
    LabeledSwitch,
    AppTooltip
  },
  props: {
    value: {
      type: Boolean,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:value"],
  data() {
    return {
      reduceOnly: this.value,
      areReduceOnlyOrdersEnabled: PAGE_CONTEXT.areReduceOnlyOrdersEnabled ?? true
    };
  },
  watch: {
    reduceOnly(newValue) {
      this.$emit("update:value", newValue);
    },
    value(newValue) {
      this.reduceOnly = newValue;
    }
  },
  methods: {
    onToggle() {
      if (this.disabled) {
        return false;
      }
      this.reduceOnly = !this.reduceOnly;
    }
  }
};
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_LabeledSwitch = resolveComponent("LabeledSwitch");
  return $data.areReduceOnlyOrdersEnabled ? (openBlock(), createBlock(_component_LabeledSwitch, {
    key: 0,
    value: $data.reduceOnly,
    "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $data.reduceOnly = $event),
    class: "reduce-only",
    "test-id": "reduce-only-switch",
    "label-placement": "right",
    disabled: $props.disabled,
    compact: ""
  }, {
    label: withCtx(() => [
      createVNode(_component_AppTooltip, {
        distance: 8,
        delay: { show: 750, hide: 100 }
      }, {
        trigger: withCtx(() => [
          createBaseVNode("label", {
            class: normalizeClass(["reduce-only__label", { "reduce-only__label--disabled": $props.disabled }]),
            onClick: _cache[0] || (_cache[0] = (...args) => $options.onToggle && $options.onToggle(...args))
          }, "\n            Reduce only\n          ", 2)
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "tooltip", {}, () => [
            _cache[2] || (_cache[2] = createBaseVNode("p", null, "\n            Reduce only orders can only decrease your existing position size.\n          ", -1))
          ], true),
          _cache[3] || (_cache[3] = createTextVNode())
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 8, ["value", "disabled"])) : createCommentVNode("", true);
}
const ReduceOnlySwitch = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$A], ["__scopeId", "data-v-33508b81"]]);
const _sfc_main$N = {
  name: "ReduceOnlyValidation",
  props: {
    orderSide: {
      type: String,
      required: true
    },
    reduceOnly: {
      type: Boolean,
      required: true
    }
  },
  emits: ["change"],
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewMarginSettingsStore: useTradeviewMarginSettingsStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore()
    };
  },
  computed: {
    errorMessage() {
      if (!this.reduceOnly) {
        return null;
      }
      const marginMode = this.tradeviewMarginSettingsStore.activeMarginMode;
      if (!this.tradeviewOpenPositionsStore.hasOpenPositionsForActiveMarketAndMarginMode) {
        return `Can't place a reduce-only order without an open ${marginMode} position.`;
      }
      const position = this.tradeviewOpenPositionsStore.openPositionForActiveMarketAndMarginMode;
      if (position.isLong && this.orderSide === constants$1.ORDER_SIDE.BUY || !position.isLong && this.orderSide === constants$1.ORDER_SIDE.SELL) {
        return `Can't place a reduce-only ${this.orderSide} order for current ${this.activeMarketStore.activeMarket.name} ${marginMode} position.`;
      }
      return null;
    }
  },
  watch: {
    errorMessage: {
      handler(newValue) {
        this.$emit("change", newValue !== null);
      },
      immediate: true
    }
  }
};
const _hoisted_1$J = {
  key: 0,
  class: "error"
};
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.errorMessage ? (openBlock(), createElementBlock("div", _hoisted_1$J, toDisplayString($options.errorMessage), 1)) : createCommentVNode("", true);
}
const ReduceOnlyValidation = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$z], ["__scopeId", "data-v-87a1ea18"]]);
const _sfc_main$M = {
  name: "ReduceOnlyRequiredNotification",
  components: { GeneralNotification },
  setup() {
    return {
      featureStatusStore: useFeatureStatusStore()
    };
  },
  computed: {
    isUserOnlyAllowedToPlaceReduceOnlyOrders() {
      return this.featureStatusStore.isTradeDerivativesReduceOnlyEnabled;
    }
  }
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GeneralNotification = resolveComponent("GeneralNotification");
  return $options.isUserOnlyAllowedToPlaceReduceOnlyOrders ? (openBlock(), createBlock(_component_GeneralNotification, {
    key: 0,
    pro: "",
    "notification-type": "warning",
    class: "reduce-only-warning"
  }, {
    default: withCtx(() => _cache[0] || (_cache[0] = [
      createBaseVNode("p", null, "\n      You are only allowed to place orders that reduce your position size and must use the reduce only option.\n    ", -1)
    ])),
    _: 1
  })) : createCommentVNode("", true);
}
const ReduceOnlyRequiredNotification = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$y], ["__scopeId", "data-v-02ce1d5b"]]);
const MARKET_BUY = 0;
const MARKET_SELL = 1;
const INSTANT_BUY = 2;
const CASH_SELL = 3;
const _sfc_main$L = {
  __name: "DerivativesMarketOrderForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const marketOrderUtils = useMarketOrder();
    const getBaseValueFromOrderBook = marketOrderUtils.getBaseValueFromOrderBook;
    const getCounterValueFromOrderBook = marketOrderUtils.getCounterValueFromOrderBook;
    const tradeviewFeeCalculators = useTradeviewFeeCalculators();
    const orderbook100Store = useOrderbook100Store();
    const tradeviewSettingsStore = useTradeviewSettingsStore();
    const activeMarketStore = useActiveMarketStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const featureStatusStore = useFeatureStatusStore();
    const tradeviewTickersStore = useTradeviewTickersStore();
    const visibilityStore = useVisibilityStore();
    const throttledEstimateUpdater = _.throttle(updateEstimate, 1e3);
    const throttledForceRevalidate = _.throttle(
      function() {
        if (amount.value || total.value) {
          validate();
        }
      },
      1e3
    );
    const throttledFetchMarginImpact = _.throttle(tradeviewOrderFormStore.fetchMarginImpact, timersConstants.THROTTLE_MARGIN_IMPACT);
    const reduceOnly = ref(false);
    const percentage = ref(0);
    const amount = ref("");
    const total = ref("");
    const isSubmitDisabledDueToReduceOnlyValidation = ref(false);
    const isTotalInputInCalcMode = computed(() => {
      return tradeviewSettingsStore.marketOrderFormInputType === constants.MARKET_ORDER_FORM_INPUT.AMOUNT;
    });
    const maxOrderValue = computed(() => {
      if (tradeviewOrderFormStore.maxOrderAmount.isZero() || currentOffer.value.isZero()) {
        return toDecimal("0");
      }
      return tradeviewOrderFormStore.maxOrderAmount.mul(currentOffer.value).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
    });
    const isUserOnlyAllowedToPlaceReduceOnlyOrders = computed(() => {
      return featureStatusStore.isTradeDerivativesReduceOnlyEnabled;
    });
    const activeMarket = computed(() => {
      return activeMarketStore.activeMarket;
    });
    const marks = computed(() => {
      return (v) => v % 25 === 0;
    });
    const isSliderDisabled = computed(() => {
      return !tradeviewOrderFormStore.maxOrderAmount || !tradeviewOrderFormStore.maxOrderAmount.isPositive();
    });
    const orderInterface = computed(() => {
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        if (isTotalInputInCalcMode.value) {
          return MARKET_BUY;
        }
        return INSTANT_BUY;
      }
      if (isTotalInputInCalcMode.value) {
        return MARKET_SELL;
      }
      return CASH_SELL;
    });
    const orderData = computed(() => {
      let orderType, orderAmount;
      switch (orderInterface.value) {
        case MARKET_BUY:
        case MARKET_SELL:
          orderType = constants$1.ORDER_TYPE.MARKET;
          orderAmount = amount.value;
          break;
        case INSTANT_BUY:
          orderType = constants$1.ORDER_TYPE.INSTANT;
          orderAmount = total.value;
          break;
        case CASH_SELL:
          orderType = constants$1.ORDER_TYPE.CASH;
          orderAmount = total.value;
      }
      return {
        side: props.side,
        type: orderType,
        amount: orderAmount,
        market: activeMarket.value.key,
        // Yes, we only set this for CASH_SELL, but not for INSTANT_BUY as one might intuit :)
        amountInCounter: orderInterface.value === CASH_SELL,
        reduceOnly: reduceOnly.value,
        _meta: {
          currency: isTotalInputInCalcMode.value ? activeMarket.value.base : activeMarket.value.counter,
          decimals: isTotalInputInCalcMode.value ? activeMarket.value.decimals.base : activeMarket.value.decimals.counter
        },
        leverage: tradeviewOrderFormStore.activeOrderFormLeverage,
        marginMode: tradeviewMarginSettingsStore.activeMarginMode
      };
    });
    const labels = computed(() => {
      return {
        amount: {
          external: "Amount",
          inline: activeMarket.value.base
        },
        total: {
          external: "Total",
          inline: activeMarket.value.counter
        }
      };
    });
    const validationSchema = computed(() => {
      if (isTotalInputInCalcMode.value) {
        return {
          amount: {
            required: true,
            decimal: {
              decimals: activeMarket.value.decimals.base
            },
            "derivativesMarketOrder_minValueOfAmount": { currentPrice: tradeviewTickersStore.activeMarketTickerLastValue },
            "derivativesMarketOrder_minAmount": true,
            "derivativesMarketOrder_maxAmount": { maxOrderAmount: tradeviewOrderFormStore.maxOrderAmount },
            "derivativesMarketOrder_maxNumber": true
          },
          total: {}
        };
      } else {
        return {
          amount: {},
          total: {
            required: true,
            decimal: {
              decimals: activeMarket.value.decimals.counter
            },
            "derivativesMarketOrder_minValue": true,
            "derivativesMarketOrder_maxValue": { maxValue: maxOrderValue.value ?? new Decimal(0) },
            "derivativesMarketOrder_maxNumber": true
          }
        };
      }
    });
    const currentOffer = computed(() => {
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        return orderbook100Store.activeMarketCurrentOffer.ask;
      }
      return orderbook100Store.activeMarketCurrentOffer.bid;
    });
    const estimate = computed(() => {
      if (amount.value === "" || total.value === "") {
        return "";
      }
      if (isTotalInputInCalcMode.value) {
        return `≈ ${total.value}`;
      } else {
        return `≈ ${amount.value}`;
      }
    });
    const feeEstimate = computed(() => {
      const orderVolume = toDecimal(total.value);
      if (!orderVolume.isPositive()) {
        return null;
      }
      if (orderInterface.value === INSTANT_BUY) {
        return {
          taker: tradeviewFeeCalculators.calculateGrossVolumeFeeForActiveMarket(orderVolume, false)
        };
      }
      return {
        taker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarket(orderVolume, false)
      };
    });
    const { meta, validate, resetForm } = useForm({ validationSchema });
    function onReduceOnlyValidationChange(isInvalid) {
      isSubmitDisabledDueToReduceOnlyValidation.value = isInvalid;
    }
    function clear() {
      amount.value = "";
      total.value = "";
      percentage.value = 0;
      nextTick(resetForm);
    }
    function updatePercentage(quantity) {
      if (!quantity) {
        return;
      }
      if (!toDecimal(quantity).isPositive()) {
        percentage.value = 0;
        return;
      }
      switch (orderInterface.value) {
        case MARKET_BUY:
          percentage.value = getPercentageForMarketBuy(quantity);
          return;
        case MARKET_SELL:
          percentage.value = getPercentageForMarketSell(quantity);
          return;
        case INSTANT_BUY:
          percentage.value = getPercentageForInstantBuy(quantity);
          return;
        case CASH_SELL:
          percentage.value = getPercentageForCashSell(quantity);
      }
    }
    function getPercentageForInstantBuy(counterTotal) {
      counterTotal = toDecimal(counterTotal);
      if (!maxOrderValue.value.isPositive() || !counterTotal.isPositive()) {
        return 0;
      }
      const percentage2 = counterTotal.div(maxOrderValue.value).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(100, Number.parseInt(percentage2.toFixed(0)));
    }
    function getPercentageForMarketBuy(baseQty) {
      baseQty = toDecimal(baseQty);
      const bestOffer = currentOffer.value;
      if (!maxOrderValue.value.isPositive() || !baseQty.isPositive() || bestOffer.isZero()) {
        return 0;
      }
      const counterQty = baseQty.mul(bestOffer);
      const newPercentage = counterQty.div(maxOrderValue.value).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(100, Number.parseInt(newPercentage.toFixed(0)));
    }
    function getPercentageForMarketSell(baseQty) {
      baseQty = toDecimal(baseQty);
      const maxOrderAmount = tradeviewOrderFormStore.maxOrderAmount;
      if (!maxOrderAmount.isPositive() || !baseQty.isPositive()) {
        return 0;
      }
      const newPercentage = baseQty.div(maxOrderAmount).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(100, Number.parseInt(newPercentage.toFixed(0)));
    }
    function getPercentageForCashSell(counterQty) {
      counterQty = toDecimal(counterQty);
      const bestOffer = currentOffer.value;
      const maxOrderAmount = tradeviewOrderFormStore.maxOrderAmount;
      if (!maxOrderAmount.isPositive() || !counterQty.isPositive() || bestOffer.isZero()) {
        return 0;
      }
      const baseAmount = counterQty.toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN).div(bestOffer);
      const newPercentage = baseAmount.div(maxOrderAmount).mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      return Math.min(100, Number.parseInt(newPercentage.toFixed(0)));
    }
    function onPercentage(newPercentage = 1) {
      const fraction = toDecimal(newPercentage).div(100);
      const maxOrderAmount = tradeviewOrderFormStore.maxOrderAmount;
      const price = currentOffer.value;
      if (price.isZero()) {
        return;
      }
      let amountDecimal = null;
      let totalDecimal = null;
      switch (orderInterface.value) {
        case MARKET_BUY: {
          if (!maxOrderValue.value.isPositive()) {
            amountDecimal = new Decimal(0);
            break;
          }
          const counterToSpend = maxOrderValue.value.mul(fraction).toDecimalPlaces(
            activeMarket.value.decimals.counter,
            Decimal.ROUND_DOWN
          );
          amountDecimal = counterToSpend.div(price).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN);
          break;
        }
        case MARKET_SELL: {
          if (!maxOrderAmount.isPositive()) {
            amountDecimal = new Decimal(0);
            break;
          }
          amountDecimal = maxOrderAmount.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN);
          break;
        }
        case INSTANT_BUY: {
          if (!maxOrderValue.value.isPositive()) {
            totalDecimal = new Decimal(0);
            break;
          }
          totalDecimal = maxOrderValue.value.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
          break;
        }
        case CASH_SELL: {
          if (!maxOrderAmount.isPositive()) {
            totalDecimal = new Decimal(0);
            break;
          }
          const baseAvailable = maxOrderAmount.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN);
          const counterValue = baseAvailable.mul(price);
          totalDecimal = counterValue.toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN);
          break;
        }
      }
      if (totalDecimal !== null) {
        if (totalDecimal.isNegative()) {
          total.value = "0";
        } else {
          total.value = numberFormatter.formatWithStrippedTrailingZeros(totalDecimal, activeMarket.value.decimals.counter);
        }
      } else if (amountDecimal !== null) {
        if (amountDecimal.isNegative()) {
          amount.value = "0";
        } else {
          amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountDecimal, activeMarket.value.decimals.base);
        }
      }
      forceValidation();
    }
    function updateEstimate() {
      switch (orderInterface.value) {
        case MARKET_BUY: {
          const value = getCounterValueFromOrderBook(toDecimal(amount.value), constants.ORDERBOOK.SIDES.ASKS);
          total.value = numberFormatter.formatWithStrippedTrailingZeros(
            value.lessThan(maxOrderValue.value) || maxOrderValue.value.isZero() ? value : maxOrderValue.value,
            activeMarket.value.decimals.counter
          );
          return;
        }
        case MARKET_SELL: {
          const value = getCounterValueFromOrderBook(toDecimal(amount.value), constants.ORDERBOOK.SIDES.BIDS);
          total.value = numberFormatter.formatWithStrippedTrailingZeros(
            value.lessThan(maxOrderValue.value) || maxOrderValue.value.isZero() ? value : maxOrderValue.value,
            activeMarket.value.decimals.counter
          );
          return;
        }
        case INSTANT_BUY: {
          const newAmount = getBaseValueFromOrderBook(toDecimal(total.value), constants.ORDERBOOK.SIDES.ASKS);
          amount.value = numberFormatter.formatWithStrippedTrailingZeros(
            newAmount.lt(tradeviewOrderFormStore.maxOrderAmount) || tradeviewOrderFormStore.maxOrderAmount.isZero() ? newAmount : tradeviewOrderFormStore.maxOrderAmount,
            activeMarket.value.decimals.base
          );
          return;
        }
        case CASH_SELL: {
          const newAmount = getBaseValueFromOrderBook(toDecimal(total.value), constants.ORDERBOOK.SIDES.BIDS);
          amount.value = numberFormatter.formatWithStrippedTrailingZeros(
            newAmount.lt(tradeviewOrderFormStore.maxOrderAmount) || tradeviewOrderFormStore.maxOrderAmount.isZero() ? newAmount : tradeviewOrderFormStore.maxOrderAmount,
            activeMarket.value.decimals.base
          );
        }
      }
    }
    function onAmountInput(newAmount) {
      if (newAmount === "") {
        clear();
        return;
      }
      if (!isTotalInputInCalcMode.value) {
        return;
      }
      amount.value = newAmount;
      updateEstimate();
      updatePercentage(newAmount);
    }
    function onTotalInput(newTotal) {
      if (newTotal === "") {
        clear();
        return;
      }
      if (isTotalInputInCalcMode.value) {
        return;
      }
      total.value = newTotal;
      updateEstimate();
      updatePercentage(newTotal);
    }
    function onAmountInputFocus() {
      tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.AMOUNT);
    }
    function onTotalInputFocus() {
      tradeviewSettingsStore.setMarketOrderFormInputType(constants.MARKET_ORDER_FORM_INPUT.TOTAL);
    }
    function forceValidation() {
      nextTick(() => {
        if (amount.value !== "" || total.value !== "") {
          validate();
        }
      });
    }
    function fillAvailableBalance() {
      onPercentage(100);
    }
    watch(maxOrderValue, () => {
      if (isTotalInputInCalcMode.value) {
        updatePercentage(amount.value);
      } else {
        updatePercentage(total.value);
      }
    });
    watch(
      orderInterface,
      (newValue) => {
        switch (newValue) {
          case CASH_SELL:
            tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.CASH);
            tradeviewOrderFormStore.setAmount(toDecimal(total.value));
            break;
          case INSTANT_BUY:
            tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.INSTANT);
            tradeviewOrderFormStore.setAmount(toDecimal(total.value));
            break;
          default:
            tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.MARKET);
            tradeviewOrderFormStore.setAmount(toDecimal(amount.value));
        }
        throttledFetchMarginImpact();
      },
      { immediate: true }
    );
    watch(activeMarket, () => {
      percentage.value = 0;
    });
    watch(() => props.side, () => {
      if (isTotalInputInCalcMode.value) {
        updatePercentage(amount.value);
      } else {
        updatePercentage(total.value);
      }
      updateEstimate();
      forceValidation();
      throttledFetchMarginImpact();
    });
    watch(
      currentOffer,
      (newOffer, oldOffer) => {
        if (newOffer && oldOffer && newOffer.eq(oldOffer)) {
          return;
        }
        if (amount.value || total.value) {
          throttledEstimateUpdater();
          throttledForceRevalidate();
          if (!visibilityStore.isHidden) {
            throttledFetchMarginImpact();
          }
        }
      },
      { immediate: true }
    );
    watch(
      amount,
      (newAmount) => {
        if (isTotalInputInCalcMode.value) {
          tradeviewOrderFormStore.setAmount(toDecimal(newAmount));
          throttledFetchMarginImpact();
        }
      },
      { immediate: true }
    );
    watch(
      total,
      (newTotal) => {
        if (!isTotalInputInCalcMode.value) {
          tradeviewOrderFormStore.setAmount(toDecimal(newTotal));
          throttledFetchMarginImpact();
        }
      },
      { immediate: true }
    );
    watch(
      () => tradeviewTriggerValueStore.amountSetByTrigger,
      /** @param {Decimal|null} amountSetByTrigger */
      (amountSetByTrigger) => {
        if (!amountSetByTrigger) {
          return;
        }
        const currentAmount = toDecimal(amount.value);
        if (currentAmount.equals(amountSetByTrigger)) {
          return;
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
        onAmountInputFocus();
      }
    );
    watch(
      isUserOnlyAllowedToPlaceReduceOnlyOrders,
      (onlyAllowReduceOnlyOrders) => {
        if (onlyAllowReduceOnlyOrders) {
          reduceOnly.value = true;
        }
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        "order-data": orderData.value,
        side: props.side,
        "fee-estimate": feeEstimate.value,
        valid: unref(meta).valid,
        dirty: unref(meta).dirty,
        "order-type-disabled": unref(tradeviewOrderFormStore).maxOrderAmount.isZero() || isSubmitDisabledDueToReduceOnlyValidation.value,
        "requires-matching": "",
        "requires-update-if-bonus-fee": "",
        "taker-only-fee-estimate": "",
        onClear: clear,
        onFill: fillAvailableBalance
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(unref(OrderInputWithValidation), {
            key: `amount-${activeMarket.value.key}`,
            "model-value": isTotalInputInCalcMode.value ? amount.value : estimate.value,
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: normalizeClass([{
              "input-field--estimate": !isTotalInputInCalcMode.value,
              "input-field--selected": isTotalInputInCalcMode.value
            }, "amount-input"]),
            field: "amount",
            "data-test": "amountInput",
            onFocus: onAmountInputFocus,
            onInput: onAmountInput
          }, null, 8, ["model-value", "label", "inline-label", "class"])),
          _cache[2] || (_cache[2] = createTextVNode()),
          (openBlock(), createBlock(unref(OrderSlider), {
            key: __props.side,
            value: percentage.value,
            "onUpdate:value": [
              _cache[0] || (_cache[0] = ($event) => percentage.value = $event),
              onPercentage
            ],
            class: "market-order__slider",
            min: 0,
            max: 100,
            "tooltip-formatter": (v) => `${v}%`,
            marks: marks.value,
            disabled: isSliderDisabled.value,
            silent: ""
          }, null, 8, ["value", "tooltip-formatter", "marks", "disabled"])),
          _cache[3] || (_cache[3] = createTextVNode()),
          (openBlock(), createBlock(unref(OrderInputWithValidation), {
            key: `total-${activeMarket.value.key}`,
            "model-value": isTotalInputInCalcMode.value ? estimate.value : total.value,
            label: labels.value.total.external,
            "inline-label": labels.value.total.inline,
            class: normalizeClass([{
              "input-field--estimate": isTotalInputInCalcMode.value,
              "input-field--selected": !isTotalInputInCalcMode.value
            }, "total-input"]),
            field: "total",
            "data-test": "totalInput",
            onFocus: onTotalInputFocus,
            onInput: onTotalInput
          }, null, 8, ["model-value", "label", "inline-label", "class"])),
          _cache[4] || (_cache[4] = createTextVNode()),
          createVNode(unref(ReduceOnlySwitch), {
            value: reduceOnly.value,
            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => reduceOnly.value = $event),
            disabled: isUserOnlyAllowedToPlaceReduceOnlyOrders.value,
            class: "reduce-only"
          }, null, 8, ["value", "disabled"]),
          _cache[5] || (_cache[5] = createTextVNode()),
          createVNode(unref(ReduceOnlyValidation), {
            "reduce-only": reduceOnly.value,
            "order-side": __props.side,
            onChange: onReduceOnlyValidationChange
          }, null, 8, ["reduce-only", "order-side"]),
          _cache[6] || (_cache[6] = createTextVNode()),
          createVNode(unref(ReduceOnlyRequiredNotification))
        ]),
        _: 1
      }, 8, ["order-data", "side", "fee-estimate", "valid", "dirty", "order-type-disabled"]);
    };
  }
};
const DerivativesMarketOrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__scopeId", "data-v-b5ccf103"]]);
const marketRange20 = {
  message({ side, orderbook }) {
    var _a2, _b;
    const highestBid = (_a2 = orderbook.bids[0]) == null ? void 0 : _a2.price;
    const lowestAsk = (_b = orderbook.asks[0]) == null ? void 0 : _b.price;
    if (side === constants$1.ORDER_SIDE.BUY) {
      if (!highestBid) {
        return "Price must be below lowest ask while no other bids are placed";
      }
      return "Price should not be higher than 20% above market price";
    } else {
      if (!lowestAsk) {
        return "Price must be above highest bid while no other asks are placed";
      }
      return "Price should not be lower than 20% below market price";
    }
  },
  validate(value, { side, orderbook }) {
    var _a2, _b;
    const highestBid = (_a2 = orderbook.bids[0]) == null ? void 0 : _a2.price;
    const lowestAsk = (_b = orderbook.asks[0]) == null ? void 0 : _b.price;
    if (!highestBid && !lowestAsk) {
      return true;
    }
    if (side === constants$1.ORDER_SIDE.BUY) {
      if (!lowestAsk || toDecimal(value).lt(lowestAsk)) {
        return true;
      }
      if (!highestBid) {
        return false;
      }
      return toDecimal(value).lte(toDecimal(highestBid).mul("1.2"));
    } else {
      if (!highestBid || toDecimal(value).gt(highestBid)) {
        return true;
      }
      if (!lowestAsk) {
        return false;
      }
      return toDecimal(value).gte(toDecimal(lowestAsk).mul("0.8"));
    }
  }
};
const minOrderValue = {
  message: minOrderValueMessage,
  validate(amount, params, ctx) {
    const userEnteredPrice = ctx.form["price"];
    if (!userEnteredPrice) {
      return true;
    }
    try {
      const activeMarket = useActiveMarketStore().activeMarket;
      const decimals = activeMarket.decimals.counter;
      const orderValue = new Decimal(userEnteredPrice).mul(amount).toDecimalPlaces(decimals, Decimal.ROUND_UP);
      return orderValue.greaterThanOrEqualTo(activeMarket.minOrderValue);
    } catch (e) {
      return false;
    }
  }
};
defineRule("derivativesLimitOrder_marketRange20", wrapper(marketRange20));
defineRule("derivativesLimitOrder_minAmount", wrapper(minAmount));
defineRule("derivativesLimitOrder_maxAmount", wrapper(maxAmount$2));
defineRule("derivativesLimitOrder_minOrderValue", wrapper(minOrderValue));
defineRule("derivativesLimitOrder_maxNumber", wrapper(maxNumber));
const _hoisted_1$I = { class: "advanced-option-group" };
const _hoisted_2$u = { class: "advanced-option" };
const _hoisted_3$r = {
  key: 0,
  class: "advanced-option-group"
};
const _hoisted_4$o = { class: "advanced-option advanced-option--gtd" };
const _sfc_main$K = {
  __name: "DerivativesLimitOrderForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const tradeviewFeeCalculators = useTradeviewFeeCalculators();
    const activeMarketStore = useActiveMarketStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const featureStatusStore = useFeatureStatusStore();
    const tradeviewSettingsStore = useTradeviewSettingsStore();
    const orderbook100Store = useOrderbook100Store();
    const GTD = constants$1.TIF.GTD;
    const areReduceOnlyOrdersEnabled = PAGE_CONTEXT.areReduceOnlyOrdersEnabled ?? true;
    const gtdOptions = [
      { text: "1 min", value: 1 },
      { text: "1 hour", value: 60 },
      { text: "1 day", value: 1440 }
    ];
    const throttledFetchMarginImpact = _.throttle(
      tradeviewOrderFormStore.fetchMarginImpact,
      timersConstants.THROTTLE_MARGIN_IMPACT
    );
    const reduceOnly = ref(false);
    const amount = ref("");
    const value = ref("");
    const price = ref("");
    const isValueInputInCalcMode = ref(true);
    const percentage = ref(0);
    const postOnly = ref(tradeviewSettingsStore.isPostOnlyOnAsDefaultEnabled);
    const tif = useLocalStorage(localStorageConstants.LOCAL_STORAGE.TV_LAST_TIF_PERP_LIMIT, constants$1.TIF.GTC);
    const cancelAfter = useLocalStorage(localStorageConstants.LOCAL_STORAGE.TV_LAST_GTD_PERP_LIMIT, 1);
    const isReduceOnlyPossible = computed(() => {
      return tif.value === constants$1.TIF.IOC || tif.value === constants$1.TIF.FOK;
    });
    const maxOrderAmount = computed(() => {
      return tradeviewOrderFormStore.maxOrderAmount;
    });
    const isUserOnlyAllowedToPlaceReduceOnlyOrders = computed(() => {
      return featureStatusStore.isTradeDerivativesReduceOnlyEnabled;
    });
    const activeMarket = computed(() => {
      return activeMarketStore.activeMarket;
    });
    const isPostOnlySettingOn = computed(() => {
      return tradeviewSettingsStore.isPostOnlyOnAsDefaultEnabled;
    });
    const tifOptions = computed(() => {
      return [
        { text: "GTC", value: constants$1.TIF.GTC, notAllowed: reduceOnly.value },
        { text: "FOK", value: constants$1.TIF.FOK, notAllowed: postOnly.value },
        { text: "IOC", value: constants$1.TIF.IOC, notAllowed: postOnly.value },
        {
          text: "GTD",
          value: constants$1.TIF.GTD,
          notAllowed: postOnly.value || reduceOnly.value
        },
        {
          text: "Daily",
          value: constants$1.TIF.DAILY,
          notAllowed: postOnly.value || reduceOnly.value
        }
      ];
    });
    const isSliderDisabled = computed(() => {
      return !maxOrderAmount.value || !maxOrderAmount.value.isPositive();
    });
    const orderData = computed(() => {
      const order = {
        type: constants$1.ORDER_TYPE.LIMIT,
        side: props.side,
        amount: amount.value,
        price: price.value,
        market: activeMarket.value.key,
        reduceOnly: reduceOnly.value,
        leverage: tradeviewOrderFormStore.activeOrderFormLeverage,
        marginMode: tradeviewMarginSettingsStore.activeMarginMode
      };
      if (postOnly.value) {
        order.timeInForce = constants$1.TIF.MOC;
      } else if (tif.value !== constants$1.TIF.GTC) {
        order.timeInForce = tif.value;
      }
      if (tif.value === constants$1.TIF.GTD) {
        order.expireTime = cancelAfter.value;
      }
      return order;
    });
    const isBuyOrder = computed(() => {
      return props.side === constants$1.ORDER_SIDE.BUY;
    });
    const labels = computed(() => {
      return {
        amount: {
          external: "Amount",
          inline: activeMarket.value.base
        },
        value: {
          external: "Value",
          inline: activeMarket.value.counter
        },
        price: {
          external: "Price",
          inline: activeMarket.value.counter
        },
        limit: {
          external: "Price",
          inline: activeMarket.value.counter
        }
      };
    });
    const validationSchema = computed(() => {
      return {
        amount: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.base },
          "derivativesLimitOrder_minAmount": true,
          "derivativesLimitOrder_maxAmount": { maxOrderAmount: tradeviewOrderFormStore.maxOrderAmount },
          "derivativesLimitOrder_minOrderValue": true,
          "derivativesLimitOrder_maxNumber": true
        },
        value: {},
        price: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.counter },
          "derivativesLimitOrder_marketRange20": {
            side: props.side,
            orderbook: orderbook100Store.orderbook
          },
          "derivativesLimitOrder_maxNumber": true
        }
      };
    });
    const feeEstimate = computed(() => {
      const orderVolume = toDecimal(value.value);
      if (!orderVolume.isPositive()) {
        return null;
      }
      return {
        maker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, true),
        taker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, false)
      };
    });
    const { meta, validate, resetForm } = useForm({ validationSchema });
    function setIsValueInputInCalcMode(newMode) {
      isValueInputInCalcMode.value = newMode;
    }
    const isSubmitDisabledDueToReduceOnlyValidation = ref(false);
    function onReduceOnlyValidationChange(isInvalid) {
      isSubmitDisabledDueToReduceOnlyValidation.value = isInvalid;
    }
    function prefill() {
      const {
        amount: prefillAmount = "",
        price: prefillPrice = "",
        tif: prefillTif = ""
      } = tradeviewOrderFormStore.prefill;
      if (!prefillPrice && !prefillAmount) {
        return;
      }
      amount.value = prefillAmount;
      price.value = prefillPrice;
      if (prefillTif) {
        tif.value = prefillTif;
      }
      tradeviewOrderFormStore.setPrefill({});
      window.history.replaceState({}, document.title, useRouter().currentRoute.value.path);
    }
    function fullClear() {
      price.value = "";
      percentage.value = 0;
      tradeviewTriggerValueStore.setPriceSetByTrigger(null);
      amount.value = "";
      value.value = "";
      nextTick(resetForm);
    }
    function onAmountInput(newAmount) {
      amount.value = newAmount;
      updatePercentage();
      if (isValueInputInCalcMode.value) {
        if (!amount.value) {
          value.value = "";
          return;
        }
        value.value = numberFormatter.formatWithStrippedTrailingZeros(
          toDecimal(newAmount).mul(toDecimal(price.value)).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_UP),
          activeMarket.value.decimals.counter
        );
      }
    }
    function onValueInput(newValue) {
      value.value = newValue;
      if (value.value === "") {
        amount.value = "";
        return;
      }
      if (isValueInputInCalcMode.value) {
        return;
      }
      const newPrice = toDecimal(price.value);
      if (!newPrice.isZero()) {
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(
          toDecimal(newValue).div(newPrice).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN),
          activeMarket.value.decimals.base
        );
      }
    }
    function updatePercentage() {
      const decimalAmount = toDecimal(amount.value);
      if (!decimalAmount.isPositive()) {
        percentage.value = 0;
      }
      if (!maxOrderAmount.value.isPositive()) {
        percentage.value = 0;
      } else {
        percentage.value = Math.min(100, Number.parseInt(decimalAmount.div(maxOrderAmount.value).mul(100).toFixed(0)));
      }
    }
    function onPriceInput(newPrice) {
      price.value = newPrice;
      const { amount: newAmount, value: newValue } = orderUtils.calcAmountAndValueBasedOnPrice(
        newPrice,
        amount.value,
        value.value,
        activeMarket.value.decimals.base,
        activeMarket.value.decimals.counter
      );
      amount.value = newAmount;
      value.value = newValue;
      const decimalPrice = toDecimal(newPrice);
      const currentSelectedPrice = tradeviewTriggerValueStore.priceSetByTrigger;
      if (decimalPrice.gte(0) && (!currentSelectedPrice || !decimalPrice.equals(currentSelectedPrice))) {
        tradeviewTriggerValueStore.setPriceSetByTrigger(decimalPrice);
      }
      if (newPrice !== "") {
        nextTick(() => {
          if (amount.value) {
            updatePercentage();
          }
        });
      }
    }
    function onPostOnlyToggle() {
      if (reduceOnly.value) {
        return false;
      }
      postOnly.value = !postOnly.value;
    }
    function calculateLimitOrderAmountFromPercentage2({ percent, baseDecimals, maxOrderAmount: maxOrderAmount2 }) {
      const fraction = new Decimal(percent).div(100);
      return numberFormatter.formatWithStrippedTrailingZeros(
        maxOrderAmount2.mul(fraction).toDecimalPlaces(baseDecimals, Decimal.ROUND_DOWN),
        baseDecimals
      );
    }
    function onPercentageInput(newPercent) {
      if (price.value === "") {
        fillPriceFromOrderbook();
      }
      amount.value = calculateLimitOrderAmountFromPercentage2({
        percent: newPercent,
        baseDecimals: activeMarket.value.decimals.base,
        maxOrderAmount: maxOrderAmount.value
      });
    }
    function fillPriceFromOrderbook() {
      let priceFromOB;
      const decimals = activeMarket.value.decimals.counter;
      const delta = 10 ** (-1 * decimals);
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        priceFromOB = orderbook100Store.activeMarketCurrentOffer.bid.add(delta);
      } else {
        priceFromOB = orderbook100Store.activeMarketCurrentOffer.ask.sub(delta);
      }
      price.value = priceFromOB.toFixed(decimals);
    }
    function fillAvailableBalance() {
      onPercentageInput(100);
    }
    watch(
      maxOrderAmount,
      (newValue, oldValue) => {
        if (newValue && oldValue && newValue.eq(oldValue)) {
          return;
        }
        updatePercentage();
      }
    );
    watch(isPostOnlySettingOn, (isEnabled) => {
      if (reduceOnly.value) {
        return;
      }
      postOnly.value = isEnabled;
    });
    watch(postOnly, (isActive) => {
      if (isActive) {
        tif.value = constants$1.TIF.GTC;
      }
    });
    watch(reduceOnly, (isActive) => {
      if (isActive) {
        postOnly.value = false;
        if (tif.value === constants$1.TIF.GTD || tif.value === constants$1.TIF.DAILY) {
          tif.value = constants$1.TIF.GTC;
        }
      }
    });
    watch(tif, (newValue) => {
      if (newValue !== constants$1.TIF.GTC) {
        postOnly.value = false;
      }
    });
    watch(() => props.side, () => {
      updatePercentage();
      requestAnimationFrame(() => {
        if (price.value !== "" || amount.value !== "") {
          validate();
        }
      });
      throttledFetchMarginImpact();
    });
    watch(
      () => tradeviewTriggerValueStore.priceSetByTrigger,
      /** @param {Decimal|null} priceSetByTrigger */
      (priceSetByTrigger) => {
        if (!priceSetByTrigger || priceSetByTrigger.isZero()) {
          return;
        }
        const currentPrice = toDecimal(price.value);
        if (currentPrice.equals(priceSetByTrigger)) {
          return;
        }
        price.value = numberFormatter.formatWithStrippedTrailingZeros(priceSetByTrigger, activeMarket.value.decimals.counter);
      }
    );
    watch(
      () => tradeviewTriggerValueStore.amountSetByTrigger,
      /** @param {Decimal|null} amountSetByTrigger */
      (amountSetByTrigger) => {
        if (!amountSetByTrigger) {
          return;
        }
        const currentAmount = toDecimal(amount.value);
        if (currentAmount.equals(amountSetByTrigger)) {
          return;
        }
        if (price.value === "") {
          fillPriceFromOrderbook();
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
      }
    );
    watch(price, (newPrice) => {
      tradeviewOrderFormStore.setLimitPrice(toDecimal(newPrice));
      throttledFetchMarginImpact();
    });
    watch(
      amount,
      (newAmount) => {
        tradeviewOrderFormStore.setAmount(toDecimal(newAmount));
        throttledFetchMarginImpact();
      },
      { immediate: true }
    );
    watch(
      isUserOnlyAllowedToPlaceReduceOnlyOrders,
      (onlyAllowReduceOnlyOrders) => {
        if (onlyAllowReduceOnlyOrders) {
          postOnly.value = false;
          reduceOnly.value = true;
          if (tif.value !== constants$1.TIF.FOK && tif.value !== constants$1.TIF.IOC) {
            tif.value = constants$1.TIF.FOK;
          }
        }
      },
      { immediate: true }
    );
    onBeforeMount(() => {
      tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.LIMIT);
      if (reduceOnly.value && !isReduceOnlyPossible.value) {
        tif.value = constants$1.TIF.FOK;
        cancelAfter.value = 1;
      } else if (!tradeviewSettingsStore.rememberLastTif || postOnly.value) {
        tif.value = constants$1.TIF.GTC;
        cancelAfter.value = 1;
      }
    });
    onMounted(() => {
      if (tradeviewTriggerValueStore.priceSetByTrigger) {
        if (tradeviewTriggerValueStore.priceSetByTrigger.lessThanOrEqualTo(0)) {
          fillPriceFromOrderbook();
        } else {
          price.value = tradeviewTriggerValueStore.priceSetByTrigger.toFixed(activeMarket.value.decimals.counter);
        }
        tradeviewOrderFormStore.setAmount(toDecimal(amount.value));
      }
      if (price.value && !toDecimal(price.value).isZero()) {
        tradeviewOrderFormStore.setLimitPrice(toDecimal(price.value));
      }
      prefill();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        "order-data": orderData.value,
        side: props.side,
        "requires-update-if-bonus-fee": false,
        "fee-estimate": feeEstimate.value,
        "order-type-disabled": isSubmitDisabledDueToReduceOnlyValidation.value,
        valid: unref(meta).valid,
        dirty: unref(meta).dirty,
        onClear: fullClear,
        onFill: fillAvailableBalance
      }, {
        default: withCtx(() => [
          createVNode(unref(OrderInputWithValidation), {
            modelValue: price.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => price.value = $event),
            label: labels.value.price.external,
            "inline-label": labels.value.price.inline,
            "price-fill-button-text": `Best ${isBuyOrder.value ? "bid" : "ask"}`,
            "show-price-fill-button": "",
            class: "price-input",
            field: "price",
            "data-test": "priceInput",
            onInput: onPriceInput,
            onPriceFillRequested: fillPriceFromOrderbook
          }, null, 8, ["modelValue", "label", "inline-label", "price-fill-button-text"]),
          _cache[34] || (_cache[34] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: amount.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => amount.value = $event),
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: "amount-input",
            field: "amount",
            "data-test": "amountInput",
            onInput: onAmountInput
          }, null, 8, ["modelValue", "label", "inline-label"]),
          _cache[35] || (_cache[35] = createTextVNode()),
          createVNode(unref(OrderSlider), {
            value: percentage.value,
            "onUpdate:value": [
              _cache[2] || (_cache[2] = ($event) => percentage.value = $event),
              onPercentageInput
            ],
            class: "order-slider",
            min: 0,
            max: 100,
            "tooltip-formatter": (v) => `${v}%`,
            marks: (v) => v % 25 === 0,
            disabled: isSliderDisabled.value
          }, null, 8, ["value", "tooltip-formatter", "marks", "disabled"]),
          _cache[36] || (_cache[36] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: value.value,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => value.value = $event),
            label: labels.value.value.external,
            "inline-label": labels.value.value.inline,
            class: "value-input",
            field: "value",
            "data-test": "totalInput",
            onFocus: _cache[4] || (_cache[4] = ($event) => setIsValueInputInCalcMode(false)),
            onBlur: _cache[5] || (_cache[5] = ($event) => setIsValueInputInCalcMode(true)),
            onInput: onValueInput
          }, null, 8, ["modelValue", "label", "inline-label"]),
          _cache[37] || (_cache[37] = createTextVNode()),
          createBaseVNode("div", _hoisted_1$I, [
            createVNode(unref(LabeledSwitch), {
              value: postOnly.value,
              "onUpdate:value": _cache[6] || (_cache[6] = ($event) => postOnly.value = $event),
              disabled: reduceOnly.value,
              class: "advanced-option",
              "test-id": "postOnlySwitch",
              "label-placement": "right",
              compact: ""
            }, {
              label: withCtx(() => [
                createVNode(unref(AppTooltip), {
                  distance: 8,
                  delay: { show: 750, hide: 100 }
                }, {
                  trigger: withCtx(() => [
                    createBaseVNode("label", {
                      class: normalizeClass(["advanced-option__label", { "advanced-option__label--disabled": reduceOnly.value }]),
                      onClick: onPostOnlyToggle
                    }, "\n                Post only\n              ", 2)
                  ]),
                  default: withCtx(() => [
                    _cache[10] || (_cache[10] = createBaseVNode("p", null, [
                      createBaseVNode("strong", null, "Post Only")
                    ], -1)),
                    _cache[11] || (_cache[11] = createTextVNode()),
                    _cache[12] || (_cache[12] = createBaseVNode("p", null, "\n              Post only ensures the order is not fully or partially filled when placed.\n            ", -1)),
                    _cache[13] || (_cache[13] = createTextVNode()),
                    _cache[14] || (_cache[14] = createBaseVNode("p", null, "\n              In case it would be, the order is canceled.\n            ", -1)),
                    _cache[15] || (_cache[15] = createTextVNode()),
                    _cache[16] || (_cache[16] = createBaseVNode("p", null, "\n              If post only is enabled only GTC time in force is allowed.\n            ", -1)),
                    _cache[17] || (_cache[17] = createTextVNode())
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value", "disabled"]),
            _cache[31] || (_cache[31] = createTextVNode()),
            createBaseVNode("div", _hoisted_2$u, [
              (openBlock(), createBlock(unref(DropdownSelector), {
                key: `${postOnly.value}-${reduceOnly.value}-${unref(tif)}`,
                value: unref(tif),
                "onUpdate:value": _cache[7] || (_cache[7] = ($event) => isRef(tif) ? tif.value = $event : null),
                options: tifOptions.value
              }, {
                label: withCtx(() => [
                  createVNode(unref(AppTooltip), {
                    distance: 8,
                    delay: { show: 750, hide: 100 },
                    placement: "left"
                  }, {
                    trigger: withCtx(() => _cache[18] || (_cache[18] = [
                      createBaseVNode("label", {
                        class: "advanced-option__label",
                        "test-id": "tifOptionsTrigger"
                      }, "\n                  TIF\n                ", -1)
                    ])),
                    default: withCtx(() => [
                      _cache[19] || (_cache[19] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "Time in force")
                      ], -1)),
                      _cache[20] || (_cache[20] = createTextVNode()),
                      _cache[21] || (_cache[21] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "GTC (Good 'til canceled)"),
                        createTextVNode(": Order remains active until executed or canceled.\n              ")
                      ], -1)),
                      _cache[22] || (_cache[22] = createTextVNode()),
                      _cache[23] || (_cache[23] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "FOK (Fill or kill)"),
                        createTextVNode(": Order must be executed immediately in its entirety,\n                otherwise it will be canceled.\n              ")
                      ], -1)),
                      _cache[24] || (_cache[24] = createTextVNode()),
                      _cache[25] || (_cache[25] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "IOC (Immediate or cancel)"),
                        createTextVNode(": Order is executed immediately and any portion that cannot be\n                filled immediately will be canceled.\n              ")
                      ], -1)),
                      _cache[26] || (_cache[26] = createTextVNode()),
                      _cache[27] || (_cache[27] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "GTD (Good 'til date)"),
                        createTextVNode(": Lets you choose how long the order will stay open.\n              ")
                      ], -1)),
                      _cache[28] || (_cache[28] = createTextVNode()),
                      _cache[29] || (_cache[29] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "Daily"),
                        createTextVNode(": Order will be canceled at 0:00 UTC unless it has already been executed.\n              ")
                      ], -1)),
                      _cache[30] || (_cache[30] = createTextVNode())
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["value", "options"]))
            ])
          ]),
          _cache[38] || (_cache[38] = createTextVNode()),
          unref(tif) === unref(GTD) || unref(areReduceOnlyOrdersEnabled) ? (openBlock(), createElementBlock("div", _hoisted_3$r, [
            createVNode(unref(ReduceOnlySwitch), {
              value: reduceOnly.value,
              "onUpdate:value": _cache[8] || (_cache[8] = ($event) => reduceOnly.value = $event),
              disabled: !isReduceOnlyPossible.value || isUserOnlyAllowedToPlaceReduceOnlyOrders.value
            }, {
              tooltip: withCtx(() => _cache[32] || (_cache[32] = [
                createBaseVNode("p", null, "\n            Reduce-only orders can only decrease your existing position size.\n          ", -1),
                createTextVNode(),
                createBaseVNode("p", null, "\n            FOK or IOC time in force must be chosen to submit a reduce-only limit order.\n          ", -1)
              ])),
              _: 1
            }, 8, ["value", "disabled"]),
            _cache[33] || (_cache[33] = createTextVNode()),
            withDirectives(createBaseVNode("div", _hoisted_4$o, [
              createVNode(unref(DropdownSelector), {
                value: unref(cancelAfter),
                "onUpdate:value": _cache[9] || (_cache[9] = ($event) => isRef(cancelAfter) ? cancelAfter.value = $event : null),
                class: "advanced-option__gtd-options",
                label: "Cancel after",
                options: gtdOptions
              }, null, 8, ["value"])
            ], 512), [
              [vShow, unref(tif) === unref(GTD)]
            ])
          ])) : createCommentVNode("", true),
          _cache[39] || (_cache[39] = createTextVNode()),
          createVNode(unref(ReduceOnlyValidation), {
            "reduce-only": reduceOnly.value,
            "order-side": __props.side,
            onChange: onReduceOnlyValidationChange
          }, null, 8, ["reduce-only", "order-side"]),
          _cache[40] || (_cache[40] = createTextVNode()),
          createVNode(unref(ReduceOnlyRequiredNotification))
        ]),
        _: 1
      }, 8, ["order-data", "side", "fee-estimate", "order-type-disabled", "valid", "dirty"]);
    };
  }
};
const DerivativesLimitOrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__scopeId", "data-v-95935014"]]);
const priceFitMarket = {
  message({ side }) {
    if (side === constants$1.ORDER_SIDE.BUY) {
      return "Trigger price must be above current market price";
    } else {
      return "Trigger price must be below current market price";
    }
  },
  validate(triggerPrice, { side, currentPrice }) {
    triggerPrice = toDecimal(triggerPrice);
    if (side === constants$1.ORDER_SIDE.BUY) {
      return triggerPrice.greaterThan(currentPrice);
    }
    return triggerPrice.lessThan(currentPrice);
  }
};
const positivePrice = {
  message() {
    return `Trigger price can't be negative`;
  },
  validate(value) {
    return !toDecimal(value).isNegative();
  }
};
const minMarketTotal = {
  message: minOrderValueMessage,
  validate(amount, { side }, ctx) {
    const activeMarket = useActiveMarketStore().activeMarket;
    amount = toDecimal(amount);
    if (side === constants$1.ORDER_SIDE.BUY) {
      return amount.greaterThanOrEqualTo(activeMarket.minOrderValue);
    } else {
      const userEnteredPrice = ctx.form["price"];
      if (!userEnteredPrice) {
        return true;
      }
      try {
        const userEnteredPriceDecimal = new Decimal(userEnteredPrice);
        return amount.mul(userEnteredPriceDecimal).greaterThanOrEqualTo(activeMarket.minOrderValue);
      } catch (e) {
        return true;
      }
    }
  }
};
const limitPriceBand = {
  message({ side }) {
    if (side === constants$1.ORDER_SIDE.BUY) {
      return "Limit price should be less than 20% above trigger price";
    } else {
      return "Limit price should be less than 20% below trigger price";
    }
  },
  validate(value, { side }, ctx) {
    const triggerPriceDecimal = toDecimal(ctx.form["triggerPrice"]);
    if (value === "" || !triggerPriceDecimal.isPositive()) {
      return true;
    }
    if (side === constants$1.ORDER_SIDE.BUY) {
      return triggerPriceDecimal.mul(1.2).greaterThan(toDecimal(value));
    } else {
      return triggerPriceDecimal.mul(0.8).lessThan(toDecimal(value));
    }
  }
};
const triggerFitsReferencePrice = {
  message({ side, orderType, triggerPriceLabel }) {
    if (constants$1.STOP_LOSS_TYPES.includes(orderType)) {
      switch (side) {
        case constants$1.ORDER_SIDE.SELL:
          return `${triggerPriceLabel} must be below current reference price`;
        case constants$1.ORDER_SIDE.BUY:
        default:
          return `${triggerPriceLabel} must be above current reference price`;
      }
    } else {
      switch (side) {
        case constants$1.ORDER_SIDE.SELL:
          return `${triggerPriceLabel} must be above current reference price`;
        case constants$1.ORDER_SIDE.BUY:
        default:
          return `${triggerPriceLabel} must be below current reference price`;
      }
    }
  },
  validate(triggerPrice, { side, orderType, triggerPriceType, activeMarketTicker }) {
    let referencePrice;
    switch (triggerPriceType) {
      case constants$1.TRIGGER_PRICE_TYPE.MARK_PRICE:
        referencePrice = activeMarketTicker.markPrice;
        break;
      case constants$1.TRIGGER_PRICE_TYPE.INDEX_PRICE:
        referencePrice = activeMarketTicker.indexPrice;
        break;
      default:
        referencePrice = activeMarketTicker.last;
    }
    triggerPrice = toDecimal(triggerPrice);
    if (constants$1.STOP_LOSS_TYPES.includes(orderType)) {
      switch (side) {
        case constants$1.ORDER_SIDE.SELL:
          return triggerPrice.lt(referencePrice);
        case constants$1.ORDER_SIDE.BUY:
        default:
          return triggerPrice.gt(referencePrice);
      }
    } else {
      switch (side) {
        case constants$1.ORDER_SIDE.SELL:
          return triggerPrice.gt(referencePrice);
        case constants$1.ORDER_SIDE.BUY:
        default:
          return triggerPrice.lt(referencePrice);
      }
    }
  }
};
const minOrderValueForLimitOrders = {
  message: minOrderValueMessage,
  validate(price, params, ctx) {
    const amount = ctx.form["amount"];
    if (!amount) {
      return true;
    }
    try {
      const activeMarket = useActiveMarketStore().activeMarket;
      const decimals = activeMarket.decimals.counter;
      const orderValue = new Decimal(price).mul(amount).toDecimalPlaces(decimals, Decimal.ROUND_UP);
      return orderValue.greaterThanOrEqualTo(activeMarket.minOrderValue);
    } catch (e) {
      return false;
    }
  }
};
const maxOrderValueForLimitOrders = {
  message: () => {
    const activeMarket = useActiveMarketStore().activeMarket;
    const value = numberFormatter.amount({
      value: activeMarket.maxOrderValue,
      decimals: activeMarket.decimals.counter,
      currencyCode: activeMarket.counter
    });
    return `Maximum order value is ${value}`;
  },
  validate(price, params, ctx) {
    const amount = ctx.form["amount"];
    if (!amount) {
      return true;
    }
    try {
      const activeMarket = useActiveMarketStore().activeMarket;
      const decimals = activeMarket.decimals.counter;
      const orderValue = new Decimal(price).mul(amount).toDecimalPlaces(decimals, Decimal.ROUND_UP);
      return orderValue.lessThanOrEqualTo(activeMarket.maxOrderValue);
    } catch (e) {
      return false;
    }
  }
};
defineRule("derivativesTPSL_triggerFitsReferencePrice", wrapper(triggerFitsReferencePrice));
defineRule("derivativesTPSL_positivePrice", wrapper(positivePrice));
defineRule("derivativesTPSL_minAmount", wrapper(minAmount));
defineRule("derivativesTPSL_maxAmount", wrapper(maxAmount$2));
defineRule("derivativesTPSL_maxNumber", wrapper(maxNumber));
defineRule("derivativesTPSL_marketRange20", wrapper(marketRange20));
defineRule("derivativesTPSL_minOrderValueForLimitOrders", wrapper(minOrderValueForLimitOrders));
defineRule("derivativesTPSL_maxOrderValueForLimitOrders", wrapper(maxOrderValueForLimitOrders));
const _hoisted_1$H = { class: "order-form-dropdowns" };
const _hoisted_2$t = { class: "advanced-option-group" };
const _hoisted_3$q = { class: "advanced-option" };
const _sfc_main$J = {
  __name: "DerivativesTakeProfitStopLossForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const activeMarketStore = useActiveMarketStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const featureStatusStore = useFeatureStatusStore();
    const tradeviewTickersStore = useTradeviewTickersStore();
    const orderbook100Store = useOrderbook100Store();
    const triggerPriceType = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_TPSL_TRIGGER_PRICE_TYPE,
      constants$1.TRIGGER_PRICE_TYPE.LAST_TRADED_PRICE
    );
    const orderTypeDropdownChoice = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TRADEVIEW_TPSL_ORDER_TYPE,
      constants$1.ORDER_TYPE.STOP_LOSS
    );
    const amount = ref("");
    const triggerPrice = ref("");
    const limitPrice = ref("");
    const trailingDelta = ref("");
    const percentage = ref(0);
    const reduceOnly = ref(false);
    const tif = ref(constants$1.TIF.GTC);
    const isUserOnlyAllowedToPlaceReduceOnlyOrders = computed(() => {
      return featureStatusStore.isTradeDerivativesReduceOnlyEnabled;
    });
    const isReduceOnlyPossible = computed(() => {
      if (!isLimitOrder.value || isUserOnlyAllowedToPlaceReduceOnlyOrders.value) {
        return true;
      }
      return tif.value === constants$1.TIF.IOC || tif.value === constants$1.TIF.FOK;
    });
    const tifOptions = computed(() => {
      return [
        { text: "GTC", value: constants$1.TIF.GTC, notAllowed: reduceOnly.value && isLimitOrder.value },
        { text: "FOK", value: constants$1.TIF.FOK, notAllowed: !isLimitOrder.value },
        { text: "IOC", value: constants$1.TIF.IOC, notAllowed: !isLimitOrder.value }
      ];
    });
    const triggerPriceTypeOptions = computed(() => {
      return [
        {
          value: constants$1.TRIGGER_PRICE_TYPE.LAST_TRADED_PRICE,
          text: constants$1.TRIGGER_PRICE_TYPE_DISPLAY[constants$1.TRIGGER_PRICE_TYPE.LAST_TRADED_PRICE]
        },
        {
          value: constants$1.TRIGGER_PRICE_TYPE.MARK_PRICE,
          text: constants$1.TRIGGER_PRICE_TYPE_DISPLAY[constants$1.TRIGGER_PRICE_TYPE.MARK_PRICE]
        },
        {
          value: constants$1.TRIGGER_PRICE_TYPE.INDEX_PRICE,
          text: constants$1.TRIGGER_PRICE_TYPE_DISPLAY[constants$1.TRIGGER_PRICE_TYPE.INDEX_PRICE]
        }
      ];
    });
    const orderTypeOptions = computed(() => {
      return [
        {
          value: constants$1.ORDER_TYPE.STOP_LOSS,
          text: "Stop Loss"
        },
        {
          value: constants$1.ORDER_TYPE.TAKE_PROFIT,
          text: "Take Profit"
        },
        {
          value: constants$1.ORDER_TYPE.TRAILING_STOP_LOSS,
          text: "Trailing SL"
        },
        {
          value: constants$1.ORDER_TYPE.TRAILING_TAKE_PROFIT,
          text: "Trailing TP"
        }
      ];
    });
    const activeMarket = computed(() => {
      return activeMarketStore.activeMarket;
    });
    const orderType = computed(() => {
      if (isLimitOrder.value) {
        return `${orderTypeDropdownChoice.value}-limit`;
      }
      return orderTypeDropdownChoice.value;
    });
    const orderData = computed(() => {
      const fields = {
        side: props.side,
        type: orderType.value,
        amount: amount.value,
        trigger: triggerPriceType.value,
        market: activeMarket.value.key,
        reduceOnly: reduceOnly.value,
        leverage: tradeviewOrderFormStore.activeOrderFormLeverage,
        marginMode: tradeviewMarginSettingsStore.activeMarginMode
      };
      if (tif.value !== constants$1.TIF.GTC) {
        fields.timeInForce = tif.value;
      }
      if (isLimitOrder.value) {
        fields.price = limitPrice.value;
      }
      if (isTrailing.value) {
        fields.activationPrice = triggerPrice.value;
        fields.trailingDelta = trailingDelta.value;
      } else {
        fields.stopPrice = triggerPrice.value;
      }
      return fields;
    });
    const isLimitOrder = computed(() => {
      return limitPrice.value !== "";
    });
    const isTrailing = computed(() => {
      return constants$1.TRAILING_TYPES.includes(orderType.value);
    });
    const labels = computed(() => {
      return {
        amount: {
          external: "Amount",
          inline: activeMarket.value.base
        },
        triggerPrice: {
          external: `${isTrailing.value ? "Activation" : "Stop"} price`,
          inline: activeMarket.value.counter,
          error: `${isTrailing.value ? "activation" : "stop"} price`
        },
        limitPrice: {
          external: "Limit price (optional)",
          inline: activeMarket.value.counter,
          error: "limit price"
        },
        trailingDelta: {
          external: "Trailing delta",
          inline: "bps",
          error: "trailing delta",
          tooltip: "Allowed range: 1-2000."
        }
      };
    });
    const validationSchema = computed(() => {
      const rules = {
        amount: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.base },
          "derivativesTPSL_maxAmount": { maxOrderAmount: tradeviewOrderFormStore.maxOrderAmount },
          "derivativesTPSL_minAmount": true,
          "derivativesTPSL_maxNumber": true
        },
        triggerPrice: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.counter },
          "derivativesTPSL_triggerFitsReferencePrice": {
            side: props.side,
            orderType: orderType.value,
            triggerPriceType: triggerPriceType.value,
            triggerPriceLabel: labels.value.triggerPrice.external,
            activeMarketTicker: tradeviewTickersStore.activeMarketTicker
          },
          "derivativesTPSL_maxNumber": true,
          "derivativesTPSL_positivePrice": true
        },
        trailingDelta: {
          required: isTrailing.value,
          decimal: { decimals: 0 },
          min_value: 1,
          max_value: 2e3
        }
      };
      if (isLimitOrder.value) {
        rules.limitPrice = {
          decimal: { decimals: activeMarket.value.decimals.counter },
          "derivativesTPSL_marketRange20": {
            side: props.side,
            orderbook: orderbook100Store.orderbook
          },
          "derivativesTPSL_maxNumber": true,
          "derivativesTPSL_positivePrice": true,
          "derivativesTPSL_minOrderValueForLimitOrders": true,
          "derivativesTPSL_maxOrderValueForLimitOrders": true
        };
      }
      return rules;
    });
    const { meta, resetForm } = useForm({ validationSchema });
    function prefill() {
      const {
        amount: prefillAmount = "",
        triggerPrice: prefillTriggerPrice = ""
      } = tradeviewOrderFormStore.prefill;
      if (!prefillAmount && !prefillTriggerPrice) {
        return;
      }
      amount.value = prefillAmount;
      triggerPrice.value = prefillTriggerPrice;
      tradeviewOrderFormStore.setPrefill({});
      window.history.replaceState({}, document.title, useRouter().currentRoute.value.path);
    }
    function onPercentage(percent) {
      const fraction = new Decimal(percent).div(100);
      amount.value = numberFormatter.formatWithStrippedTrailingZeros(
        tradeviewOrderFormStore.maxOrderAmount.mul(fraction).todp(activeMarket.value.decimals.base, Decimal.ROUND_DOWN),
        activeMarket.value.decimals.base
      );
    }
    function fullClear() {
      triggerPrice.value = "";
      trailingDelta.value = "";
      limitPrice.value = "";
      amount.value = "";
      percentage.value = 0;
      nextTick(resetForm);
    }
    function updateAmount(newAmount) {
      amount.value = newAmount;
      updatePercentage();
    }
    function updatePercentage() {
      if (amount.value === "") {
        percentage.value = 0;
        return;
      }
      let fraction = 0;
      if (!tradeviewOrderFormStore.maxOrderAmount.isPositive()) {
        percentage.value = 0;
        return;
      }
      fraction = toDecimal(amount.value).div(tradeviewOrderFormStore.maxOrderAmount);
      const newPercentage = fraction.mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      percentage.value = Math.min(100, Number.parseInt(newPercentage.toFixed(0)));
    }
    function onTrailingDeltaInput(delta) {
      trailingDelta.value = delta;
      tradeviewOrderFormStore.setTrailingDelta(toDecimal(delta));
    }
    function onLimitPriceInput(newLimitPrice) {
      limitPrice.value = newLimitPrice;
      tradeviewOrderFormStore.setLimitPrice(toDecimal(newLimitPrice));
    }
    function onTriggerPriceInput(newPrice) {
      triggerPrice.value = newPrice;
      const priceAsDecimal = toDecimal(newPrice);
      if (isTrailing.value) {
        tradeviewOrderFormStore.setActivationPrice(priceAsDecimal);
        tradeviewOrderFormStore.setStopPrice(toDecimal(0));
      } else {
        tradeviewOrderFormStore.setActivationPrice(toDecimal(0));
        tradeviewOrderFormStore.setStopPrice(priceAsDecimal);
      }
      const decimalPrice = toDecimal(newPrice);
      const currentSelectedPrice = tradeviewTriggerValueStore.priceSetByTrigger;
      if (decimalPrice.gte(0) && (!currentSelectedPrice || !decimalPrice.equals(currentSelectedPrice))) {
        tradeviewTriggerValueStore.setPriceSetByTrigger(decimalPrice);
      }
    }
    watch(
      orderType,
      (newType) => {
        tradeviewOrderFormStore.setActiveOrderType(newType);
      },
      { immediate: true }
    );
    watch(isLimitOrder, (isLimitStopOrder) => {
      if (!isLimitStopOrder) {
        tif.value = constants$1.TIF.GTC;
      } else if (isUserOnlyAllowedToPlaceReduceOnlyOrders.value && tif.value === constants$1.TIF.GTC) {
        tif.value = constants$1.TIF.FOK;
      }
    });
    watch(isReduceOnlyPossible, (isPossible) => {
      if (!isPossible) {
        reduceOnly.value = false;
      }
    });
    watch(() => props.side, updatePercentage);
    watch(amount, (newAmount) => {
      tradeviewOrderFormStore.setAmount(toDecimal(newAmount));
    });
    watch(
      () => tradeviewTriggerValueStore.priceSetByTrigger,
      /** @param {Decimal|null} selectedPrice */
      (selectedPrice) => {
        if (!selectedPrice) {
          return;
        }
        const currentPrice = toDecimal(triggerPrice.value);
        if (currentPrice.equals(selectedPrice)) {
          return;
        }
        triggerPrice.value = numberFormatter.formatWithStrippedTrailingZeros(selectedPrice, activeMarket.value.decimals.counter);
      }
    );
    watch(
      () => tradeviewTriggerValueStore.amountSetByTrigger,
      /** @param {Decimal|null} amountSetByTrigger */
      (amountSetByTrigger) => {
        if (!amountSetByTrigger) {
          return;
        }
        const currentAmount = toDecimal(amount.value);
        if (currentAmount.equals(amountSetByTrigger)) {
          return;
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
      }
    );
    watch(
      isUserOnlyAllowedToPlaceReduceOnlyOrders,
      (onlyAllowReduceOnlyOrders) => {
        if (onlyAllowReduceOnlyOrders) {
          reduceOnly.value = true;
          if (isLimitOrder.value && tif.value === constants$1.TIF.GTC) {
            tif.value = constants$1.TIF.FOK;
          }
        }
      },
      { immediate: true }
    );
    onMounted(() => {
      var _a2;
      tradeviewOrderFormStore.setTrailingDelta(toDecimal(0));
      prefill();
      if ((_a2 = tradeviewTriggerValueStore.priceSetByTrigger) == null ? void 0 : _a2.isPositive()) {
        triggerPrice.value = numberFormatter.formatWithStrippedTrailingZeros(
          tradeviewTriggerValueStore.priceSetByTrigger,
          activeMarket.value.decimals.counter
        );
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        "order-data": orderData.value,
        side: props.side,
        valid: unref(meta).valid,
        dirty: unref(meta).dirty,
        "requires-update-if-bonus-fee": false,
        "order-type-disabled": unref(tradeviewOrderFormStore).maxOrderAmount.isZero(),
        "requires-matching": "",
        onClear: fullClear,
        onFill: _cache[9] || (_cache[9] = ($event) => onPercentage(100))
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$H, [
            createVNode(unref(DropdownSelector), {
              value: unref(orderTypeDropdownChoice),
              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => isRef(orderTypeDropdownChoice) ? orderTypeDropdownChoice.value = $event : null),
              options: orderTypeOptions.value,
              class: "order-form-dropdowns__dropdown"
            }, null, 8, ["value", "options"]),
            _cache[10] || (_cache[10] = createTextVNode()),
            createVNode(unref(DropdownSelector), {
              value: unref(triggerPriceType),
              "onUpdate:value": _cache[1] || (_cache[1] = ($event) => isRef(triggerPriceType) ? triggerPriceType.value = $event : null),
              options: triggerPriceTypeOptions.value,
              class: "order-form-dropdowns__dropdown",
              title: "Choose trigger price type"
            }, null, 8, ["value", "options"])
          ]),
          _cache[22] || (_cache[22] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: triggerPrice.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => triggerPrice.value = $event),
            label: labels.value.triggerPrice.external,
            "inline-label": labels.value.triggerPrice.inline,
            "error-label": labels.value.triggerPrice.error,
            class: "bottom-margin",
            field: "triggerPrice",
            "data-test": "priceInput",
            onInput: onTriggerPriceInput
          }, null, 8, ["modelValue", "label", "inline-label", "error-label"]),
          _cache[23] || (_cache[23] = createTextVNode()),
          isTrailing.value ? (openBlock(), createBlock(unref(OrderInputWithValidation), {
            key: 0,
            modelValue: trailingDelta.value,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => trailingDelta.value = $event),
            label: labels.value.trailingDelta.external,
            "inline-label": labels.value.trailingDelta.inline,
            "error-label": labels.value.trailingDelta.error,
            "title-tooltip": labels.value.trailingDelta.tooltip,
            class: "bottom-margin",
            field: "trailingDelta",
            "data-test": "deltaInput",
            onInput: onTrailingDeltaInput
          }, null, 8, ["modelValue", "label", "inline-label", "error-label", "title-tooltip"])) : createCommentVNode("", true),
          _cache[24] || (_cache[24] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: amount.value,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => amount.value = $event),
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: "bottom-margin",
            field: "amount",
            "data-test": "amountInput",
            onInput: updateAmount
          }, null, 8, ["modelValue", "label", "inline-label"]),
          _cache[25] || (_cache[25] = createTextVNode()),
          createVNode(unref(OrderSlider), {
            value: percentage.value,
            "onUpdate:value": [
              _cache[5] || (_cache[5] = ($event) => percentage.value = $event),
              onPercentage
            ],
            class: "bottom-margin",
            min: 0,
            max: 100,
            "tooltip-formatter": (v) => `${v}%`,
            marks: (v) => v % 25 === 0
          }, null, 8, ["value", "tooltip-formatter", "marks"]),
          _cache[26] || (_cache[26] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: limitPrice.value,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => limitPrice.value = $event),
            label: labels.value.limitPrice.external,
            "inline-label": labels.value.limitPrice.inline,
            "error-label": labels.value.limitPrice.error,
            class: "bottom-margin",
            field: "limitPrice",
            "data-test": "limitPriceInput",
            onInput: onLimitPriceInput
          }, null, 8, ["modelValue", "label", "inline-label", "error-label"]),
          _cache[27] || (_cache[27] = createTextVNode()),
          createBaseVNode("div", _hoisted_2$t, [
            createVNode(unref(ReduceOnlySwitch), {
              value: reduceOnly.value,
              "onUpdate:value": _cache[7] || (_cache[7] = ($event) => reduceOnly.value = $event),
              class: "advanced-option",
              disabled: !isReduceOnlyPossible.value || isUserOnlyAllowedToPlaceReduceOnlyOrders.value
            }, {
              tooltip: withCtx(() => _cache[11] || (_cache[11] = [
                createBaseVNode("p", null, "\n            Reduce-only orders can only decrease your existing position size.\n          ", -1),
                createTextVNode(),
                createBaseVNode("p", null, "\n            FOK or IOC time in force must be chosen to submit a reduce-only order with a limit price.\n          ", -1)
              ])),
              _: 1
            }, 8, ["value", "disabled"]),
            _cache[21] || (_cache[21] = createTextVNode()),
            createBaseVNode("div", _hoisted_3$q, [
              (openBlock(), createBlock(unref(DropdownSelector), {
                key: `${reduceOnly.value}-${tif.value}`,
                value: tif.value,
                "onUpdate:value": _cache[8] || (_cache[8] = ($event) => tif.value = $event),
                options: tifOptions.value
              }, {
                label: withCtx(() => [
                  createVNode(unref(AppTooltip), {
                    distance: 8,
                    delay: { show: 750, hide: 100 },
                    placement: "left"
                  }, {
                    trigger: withCtx(() => _cache[12] || (_cache[12] = [
                      createBaseVNode("label", {
                        class: "advanced-option__label",
                        "test-id": "tifOptionsTrigger"
                      }, "\n                  TIF\n                ", -1)
                    ])),
                    default: withCtx(() => [
                      _cache[13] || (_cache[13] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "Time in force")
                      ], -1)),
                      _cache[14] || (_cache[14] = createTextVNode()),
                      _cache[15] || (_cache[15] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "GTC (Good 'til canceled)"),
                        createTextVNode(": Order remains placed until executed or canceled.\n              ")
                      ], -1)),
                      _cache[16] || (_cache[16] = createTextVNode()),
                      _cache[17] || (_cache[17] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "FOK (Fill or kill)"),
                        createTextVNode(": Only applicable if Limit price is set.\n                The triggered Limit Order must be executed immediately in its entirety, otherwise it will be canceled.\n              ")
                      ], -1)),
                      _cache[18] || (_cache[18] = createTextVNode()),
                      _cache[19] || (_cache[19] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "IOC (Immediate or cancel)"),
                        createTextVNode(": Only applicable if Limit price is set.\n                The triggered Limit Order is executed immediately and any portion that cannot be filled immediately will be canceled.\n              ")
                      ], -1)),
                      _cache[20] || (_cache[20] = createTextVNode())
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["value", "options"]))
            ])
          ]),
          _cache[28] || (_cache[28] = createTextVNode()),
          createVNode(unref(ReduceOnlyRequiredNotification))
        ]),
        _: 1
      }, 8, ["order-data", "side", "valid", "dirty", "order-type-disabled"]);
    };
  }
};
const DerivativesTakeProfitStopLossForm = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__scopeId", "data-v-4eea3b43"]]);
const maxAmount = {
  message: maxAmountMessage,
  validate(amount, { side, availableBalances }, ctx) {
    if (useSubAccountStore().doesActiveAccountAllowNegativeBalances) {
      return true;
    }
    if (side === constants$1.ORDER_SIDE.BUY) {
      const userEnteredPrice = ctx.form["price"];
      if (!userEnteredPrice) {
        return true;
      }
      try {
        let orderValue = new Decimal(amount).mul(userEnteredPrice);
        const fee = useTradeviewFeeCalculators().calculateNetVolumeFeeForActiveMarketNoBonus(orderValue);
        const decimals = useActiveMarketStore().activeMarket.decimals.counter;
        orderValue = orderValue.add(fee).toDecimalPlaces(decimals, Decimal.ROUND_UP);
        return orderValue.lessThanOrEqualTo(availableBalances.counter);
      } catch (e) {
        return false;
      }
    } else {
      return availableBalances.base.greaterThanOrEqualTo(toDecimal(amount));
    }
  }
};
const osoPriceMinValue = {
  message({ side }) {
    if (side === constants$1.ORDER_SIDE.BUY) {
      return `OSO price must be higher than buy price`;
    } else {
      return `OSO price must be lower than sell price`;
    }
  },
  validate(value, { side }, ctx) {
    const userEnteredPrice = ctx.form["price"];
    if (!userEnteredPrice) {
      return true;
    }
    try {
      const valueAsDecimal = new Decimal(value);
      const useEnteredPriceAsDecimal = new Decimal(userEnteredPrice);
      if (side === constants$1.ORDER_SIDE.BUY) {
        return valueAsDecimal.greaterThan(useEnteredPriceAsDecimal);
      } else {
        return valueAsDecimal.lessThan(useEnteredPriceAsDecimal);
      }
    } catch (e) {
      return false;
    }
  }
};
defineRule("limitOrder_marketRange20", wrapper(marketRange20));
defineRule("limitOrder_maxAmount", wrapper(maxAmount));
defineRule("limitOrder_minOrderValue", wrapper(minOrderValue));
defineRule("limitOrder_osoPriceMinValue", wrapper(osoPriceMinValue));
defineRule("limitOrder_maxNumber", wrapper(maxNumber));
const _hoisted_1$G = { class: "advanced-option-group" };
const _hoisted_2$s = { class: "advanced-option" };
const _hoisted_3$p = { class: "advanced-option-group" };
const _hoisted_4$n = { class: "advanced-option advanced-option--gtd" };
const _sfc_main$I = {
  __name: "LimitOrderForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const tradeviewFeeCalculators = useTradeviewFeeCalculators();
    const tradeviewSettingsStore = useTradeviewSettingsStore();
    const activeMarketStore = useActiveMarketStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const orderbook100Store = useOrderbook100Store();
    const balancesStore = useBalancesStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const gtdOptions = [
      { text: "1 min", value: 1 },
      { text: "1 hour", value: 60 },
      { text: "1 day", value: 1440 }
    ];
    const postOnly = ref(false);
    postOnly.value = tradeviewSettingsStore.isPostOnlyOnAsDefaultEnabled;
    const amount = ref("");
    const value = ref("");
    const price = ref("");
    const osoEnabled = ref(false);
    const osoPrice = ref("");
    const isValueInputInCalcMode = ref(true);
    const percentage = ref(0);
    const tif = useLocalStorage(localStorageConstants.LOCAL_STORAGE.TV_LAST_TIF_SPOT_LIMIT, constants$1.TIF.GTC);
    const cancelAfter = useLocalStorage(localStorageConstants.LOCAL_STORAGE.TV_LAST_GTD_SPOT_LIMIT, 1);
    const activeMarket = computed(() => {
      return activeMarketStore.activeMarket;
    });
    const isPostOnlySettingOn = computed(() => {
      return tradeviewSettingsStore.isPostOnlyOnAsDefaultEnabled;
    });
    const tifOptions = computed(() => {
      return [
        { text: "GTC", value: constants$1.TIF.GTC },
        { text: "FOK", value: constants$1.TIF.FOK, notAllowed: postOnly.value },
        { text: "IOC", value: constants$1.TIF.IOC, notAllowed: postOnly.value || osoEnabled.value },
        { text: "GTD", value: constants$1.TIF.GTD, notAllowed: postOnly.value || osoEnabled.value },
        { text: "Daily", value: constants$1.TIF.DAILY, notAllowed: postOnly.value || osoEnabled.value }
      ];
    });
    const isSliderDisabled = computed(() => {
      const available = balancesStore.activeMarketAccountAvailableBalance;
      if (isBuyOrder.value) {
        return available.counter.isZero();
      }
      return available.base.isZero();
    });
    const orderData = computed(() => {
      const order = {
        type: constants$1.ORDER_TYPE.LIMIT,
        side: props.side,
        amount: amount.value,
        price: price.value,
        market: activeMarket.value.key
      };
      if (postOnly.value) {
        order.timeInForce = constants$1.TIF.MOC;
      } else if (tif.value !== constants$1.TIF.GTC) {
        order.timeInForce = tif.value;
      }
      if (tif.value === constants$1.TIF.GTD) {
        order.expireTime = cancelAfter.value;
      }
      if (osoEnabled.value && osoPrice.value) {
        order.osoPrice = osoPrice.value;
      }
      return order;
    });
    const isBuyOrder = computed(() => {
      return props.side === constants$1.ORDER_SIDE.BUY;
    });
    const labels = computed(() => {
      return {
        amount: {
          external: "Amount",
          inline: activeMarket.value.base
        },
        value: {
          external: "Value",
          inline: activeMarket.value.counter
        },
        price: {
          external: "Price",
          inline: activeMarket.value.counter
        },
        osoPrice: {
          external: "Price",
          inline: activeMarket.value.counter,
          error: "oso price"
        }
      };
    });
    const isGtdTifActive = computed(() => tif.value === constants$1.TIF.GTD);
    const validationSchema = computed(() => {
      return {
        amount: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.base },
          "limitOrder_maxAmount": {
            side: props.side,
            availableBalances: balancesStore.activeMarketAccountAvailableBalance
          },
          "limitOrder_minOrderValue": true,
          "limitOrder_maxNumber": true
        },
        price: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.counter },
          "limitOrder_marketRange20": {
            side: props.side,
            orderbook: orderbook100Store.orderbook
          },
          "limitOrder_maxNumber": true
        },
        osoPrice: {
          required: osoEnabled.value,
          decimal: { decimals: activeMarket.value.decimals.counter },
          "limitOrder_osoPriceMinValue": osoEnabled.value ? { side: props.side } : false,
          "limitOrder_maxNumber": osoEnabled.value
        }
      };
    });
    const { meta, resetForm } = useForm({ validationSchema });
    const feeEstimate = computed(() => {
      const orderVolume = toDecimal(value.value);
      if (!orderVolume.isPositive()) {
        return null;
      }
      return {
        maker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, true),
        taker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, false)
      };
    });
    function toggleOsoEnabled() {
      osoEnabled.value = !osoEnabled.value;
    }
    function togglePostOnly() {
      postOnly.value = !postOnly.value;
    }
    function setIsValueInputInCalcMode(newValue) {
      isValueInputInCalcMode.value = newValue;
    }
    function prefill() {
      const {
        amount: prefillAmount = "",
        price: prefillPrice = "",
        osoPrice: prefillOsoPrice = "",
        tif: prefillTif = ""
      } = tradeviewOrderFormStore.prefill;
      if (!prefillPrice && !prefillAmount) {
        return;
      }
      amount.value = prefillAmount;
      price.value = prefillPrice;
      if (prefillOsoPrice) {
        osoEnabled.value = true;
        nextTick(() => {
          osoPrice.value = prefillOsoPrice;
        });
      }
      if (prefillTif) {
        tif.value = prefillTif;
      }
      tradeviewOrderFormStore.setPrefill({});
      window.history.replaceState({}, document.title, useRouter().currentRoute.value.path);
    }
    function fullClear() {
      price.value = "";
      percentage.value = 0;
      tradeviewTriggerValueStore.setPriceSetByTrigger(null);
      tradeviewTriggerValueStore.setAmountSetByTrigger(null);
      amount.value = "";
      value.value = "";
      osoEnabled.value = false;
      osoPrice.value = "";
      nextTick(resetForm);
    }
    function onAmountInput(newAmount) {
      amount.value = newAmount;
      updatePercentage();
      if (isValueInputInCalcMode.value) {
        if (!amount.value) {
          value.value = "";
          return;
        }
        value.value = numberFormatter.formatWithStrippedTrailingZeros(
          toDecimal(newAmount).mul(toDecimal(price.value)).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_UP),
          activeMarket.value.decimals.counter
        );
      }
    }
    function onValueInput(newValue) {
      value.value = newValue;
      if (value.value === "") {
        amount.value = "";
        return;
      }
      if (isValueInputInCalcMode.value) {
        return;
      }
      const priceDecimal = toDecimal(price.value);
      if (!priceDecimal.isZero()) {
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(
          toDecimal(newValue).div(priceDecimal).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN),
          activeMarket.value.decimals.base
        );
      }
    }
    function updatePercentage() {
      percentage.value = orderUtils.calculateLimitOrderPercentage(
        price.value,
        amount.value,
        isBuyOrder.value,
        activeMarket.value.decimals.counter,
        () => tradeviewFeeCalculators,
        () => balancesStore
      );
    }
    function onPriceInput(newPrice) {
      price.value = newPrice;
      const { amount: newAmount, value: newValue } = orderUtils.calcAmountAndValueBasedOnPrice(
        newPrice,
        amount.value,
        value.value,
        activeMarket.value.decimals.base,
        activeMarket.value.decimals.counter
      );
      amount.value = newAmount;
      if (amount.value && price.value) {
        value.value = newValue;
      }
      const decimalPrice = toDecimal(newPrice);
      const currentSelectedPrice = tradeviewTriggerValueStore.priceSetByTrigger;
      if (decimalPrice.gte(0) && (!currentSelectedPrice || !decimalPrice.equals(currentSelectedPrice))) {
        tradeviewTriggerValueStore.setPriceSetByTrigger(decimalPrice);
      }
      if (newPrice !== "") {
        requestAnimationFrame(() => {
          if (amount.value) {
            updatePercentage();
          }
        });
      }
    }
    function onPercentageInput(newPercent) {
      if (price.value === "") {
        fillPriceFromOrderbook();
      }
      amount.value = orderUtils.calculateLimitOrderAmountFromPercentage(
        newPercent,
        price.value,
        isBuyOrder.value,
        activeMarket.value.decimals.base,
        activeMarket.value.decimals.counter,
        () => tradeviewFeeCalculators,
        () => balancesStore
      );
    }
    function fillPriceFromOrderbook() {
      let orderbookPrice;
      const decimals = activeMarket.value.decimals.counter;
      const delta = 10 ** (-1 * decimals);
      if (props.side === constants$1.ORDER_SIDE.BUY) {
        orderbookPrice = orderbook100Store.activeMarketCurrentOffer.bid.add(delta);
      } else {
        orderbookPrice = orderbook100Store.activeMarketCurrentOffer.ask.sub(delta);
      }
      price.value = orderbookPrice.toFixed(decimals);
    }
    function fillAvailableBalance() {
      onPercentageInput(100);
    }
    onBeforeMount(() => {
      tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.LIMIT);
      if (!tradeviewSettingsStore.rememberLastTif || postOnly.value) {
        tif.value = constants$1.TIF.GTC;
        cancelAfter.value = 1;
      }
    });
    onMounted(() => {
      tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.LIMIT);
      if (tradeviewTriggerValueStore.priceSetByTrigger !== null) {
        if (tradeviewTriggerValueStore.priceSetByTrigger.lessThanOrEqualTo(0)) {
          fillPriceFromOrderbook();
        } else {
          price.value = tradeviewTriggerValueStore.priceSetByTrigger.toFixed(activeMarket.value.decimals.counter);
        }
      }
      prefill();
    });
    watch(isPostOnlySettingOn, (isEnabled) => {
      postOnly.value = isEnabled;
    });
    watch(osoEnabled, (isEnabled) => {
      if (isEnabled && tif.value !== constants$1.TIF.GTC && tif.value !== constants$1.TIF.FOK) {
        tif.value = constants$1.TIF.GTC;
      }
    });
    watch(postOnly, (isActive) => {
      if (isActive) {
        tif.value = constants$1.TIF.GTC;
      }
    });
    watch(tif, (newValue) => {
      if (newValue !== constants$1.TIF.GTC) {
        postOnly.value = false;
      }
      if (newValue !== constants$1.TIF.FOK && newValue !== constants$1.TIF.GTC) {
        osoEnabled.value = false;
      }
    });
    watch(() => props.side, updatePercentage);
    watch(
      () => tradeviewTriggerValueStore.priceSetByTrigger,
      (priceSetByTrigger) => {
        if (!priceSetByTrigger) {
          return;
        }
        const currentPrice = toDecimal(price.value);
        if (currentPrice.equals(priceSetByTrigger)) {
          return;
        }
        price.value = numberFormatter.formatWithStrippedTrailingZeros(priceSetByTrigger, activeMarket.value.decimals.counter);
      }
    );
    watch(
      () => tradeviewTriggerValueStore.amountSetByTrigger,
      (amountSetByTrigger) => {
        if (!amountSetByTrigger) {
          return;
        }
        const currentAmount = toDecimal(amount.value);
        if (currentAmount.equals(amountSetByTrigger)) {
          return;
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        "order-data": orderData.value,
        side: props.side,
        "requires-update-if-bonus-fee": false,
        "fee-estimate": feeEstimate.value,
        valid: unref(meta).valid,
        dirty: unref(meta).dirty,
        onClear: fullClear,
        onFill: fillAvailableBalance
      }, {
        default: withCtx(() => [
          createVNode(unref(OrderInputWithValidation), {
            modelValue: price.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => price.value = $event),
            label: labels.value.price.external,
            "inline-label": labels.value.price.inline,
            "price-fill-button-text": `Best ${isBuyOrder.value ? "bid" : "ask"}`,
            "show-price-fill-button": "",
            class: "price-input",
            field: "price",
            "data-test": "priceInput",
            onInput: onPriceInput,
            onPriceFillRequested: fillPriceFromOrderbook
          }, null, 8, ["modelValue", "label", "inline-label", "price-fill-button-text"]),
          _cache[39] || (_cache[39] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: amount.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => amount.value = $event),
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: "amount-input",
            field: "amount",
            "data-test": "amountInput",
            onInput: onAmountInput
          }, null, 8, ["modelValue", "label", "inline-label"]),
          _cache[40] || (_cache[40] = createTextVNode()),
          createVNode(unref(OrderSlider), {
            value: percentage.value,
            "onUpdate:value": [
              _cache[2] || (_cache[2] = ($event) => percentage.value = $event),
              onPercentageInput
            ],
            class: "order-slider",
            min: 0,
            max: 100,
            "tooltip-formatter": (v) => `${v}%`,
            marks: (v) => v % 25 === 0,
            disabled: isSliderDisabled.value
          }, null, 8, ["value", "tooltip-formatter", "marks", "disabled"]),
          _cache[41] || (_cache[41] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: value.value,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => value.value = $event),
            label: labels.value.value.external,
            "inline-label": labels.value.value.inline,
            class: "value-input",
            field: "value",
            "data-test": "totalInput",
            onFocus: _cache[4] || (_cache[4] = ($event) => setIsValueInputInCalcMode(false)),
            onBlur: _cache[5] || (_cache[5] = ($event) => setIsValueInputInCalcMode(true)),
            onInput: onValueInput
          }, null, 8, ["modelValue", "label", "inline-label"]),
          _cache[42] || (_cache[42] = createTextVNode()),
          createBaseVNode("div", _hoisted_1$G, [
            createVNode(unref(LabeledSwitch), {
              value: postOnly.value,
              "onUpdate:value": _cache[6] || (_cache[6] = ($event) => postOnly.value = $event),
              class: "advanced-option",
              "test-id": "postOnlySwitch",
              "label-placement": "right",
              compact: ""
            }, {
              label: withCtx(() => [
                createVNode(unref(AppTooltip), {
                  distance: 8,
                  delay: { show: 750, hide: 100 }
                }, {
                  trigger: withCtx(() => [
                    createBaseVNode("label", {
                      class: "advanced-option__label",
                      onClick: togglePostOnly
                    }, "\n                Post only\n              ")
                  ]),
                  default: withCtx(() => [
                    _cache[11] || (_cache[11] = createBaseVNode("p", null, [
                      createBaseVNode("strong", null, "Post Only")
                    ], -1)),
                    _cache[12] || (_cache[12] = createTextVNode()),
                    _cache[13] || (_cache[13] = createBaseVNode("p", null, "\n              Post only ensures the order is not fully or partially filled when placed.\n            ", -1)),
                    _cache[14] || (_cache[14] = createTextVNode()),
                    _cache[15] || (_cache[15] = createBaseVNode("p", null, "\n              In case it would be, the order is canceled.\n            ", -1)),
                    _cache[16] || (_cache[16] = createTextVNode()),
                    _cache[17] || (_cache[17] = createBaseVNode("p", null, "\n              If post only is enabled only GTC time in force is allowed.\n            ", -1)),
                    _cache[18] || (_cache[18] = createTextVNode())
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value"]),
            _cache[32] || (_cache[32] = createTextVNode()),
            createBaseVNode("div", _hoisted_2$s, [
              (openBlock(), createBlock(unref(DropdownSelector), {
                key: `${postOnly.value}-${osoEnabled.value}-${unref(tif)}`,
                value: unref(tif),
                "onUpdate:value": _cache[7] || (_cache[7] = ($event) => isRef(tif) ? tif.value = $event : null),
                options: tifOptions.value
              }, {
                label: withCtx(() => [
                  createVNode(unref(AppTooltip), {
                    distance: 8,
                    delay: { show: 750, hide: 100 },
                    placement: "left",
                    strategy: "fixed"
                  }, {
                    trigger: withCtx(() => _cache[19] || (_cache[19] = [
                      createBaseVNode("label", {
                        class: "advanced-option__label",
                        "test-id": "tifOptionsTrigger"
                      }, "\n                  TIF\n                ", -1)
                    ])),
                    default: withCtx(() => [
                      _cache[20] || (_cache[20] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "Time in force")
                      ], -1)),
                      _cache[21] || (_cache[21] = createTextVNode()),
                      _cache[22] || (_cache[22] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "GTC (Good 'til canceled)"),
                        createTextVNode(": Order remains active until executed or canceled.\n              ")
                      ], -1)),
                      _cache[23] || (_cache[23] = createTextVNode()),
                      _cache[24] || (_cache[24] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "FOK (Fill or kill)"),
                        createTextVNode(": Order must be executed immediately in its entirety,\n                otherwise it will be canceled.\n              ")
                      ], -1)),
                      _cache[25] || (_cache[25] = createTextVNode()),
                      _cache[26] || (_cache[26] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "IOC (Immediate or cancel)"),
                        createTextVNode(": Order is executed immediately and any portion that cannot be\n                filled immediately will be canceled.\n              ")
                      ], -1)),
                      _cache[27] || (_cache[27] = createTextVNode()),
                      _cache[28] || (_cache[28] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "GTD (Good 'til date)"),
                        createTextVNode(": Lets you choose how long the order will stay open.\n                "),
                        createBaseVNode("br"),
                        createTextVNode(" Note that all GTD orders are canceled at 00:00 UTC.\n              ")
                      ], -1)),
                      _cache[29] || (_cache[29] = createTextVNode()),
                      _cache[30] || (_cache[30] = createBaseVNode("p", null, [
                        createBaseVNode("strong", null, "Daily"),
                        createTextVNode(": Order will be canceled at 00:00 UTC unless it has already been executed.\n              ")
                      ], -1)),
                      _cache[31] || (_cache[31] = createTextVNode())
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["value", "options"]))
            ])
          ]),
          _cache[43] || (_cache[43] = createTextVNode()),
          createBaseVNode("div", _hoisted_3$p, [
            createVNode(unref(LabeledSwitch), {
              value: osoEnabled.value,
              "onUpdate:value": _cache[8] || (_cache[8] = ($event) => osoEnabled.value = $event),
              class: "advanced-option",
              "test-id": "osoEnabledSwitch",
              "label-placement": "right",
              compact: ""
            }, {
              label: withCtx(() => [
                createVNode(unref(AppTooltip), {
                  distance: 8,
                  delay: { show: 750, hide: 100 }
                }, {
                  trigger: withCtx(() => [
                    createBaseVNode("label", {
                      class: "advanced-option__label",
                      "data-test": "osoEnabledSwitch",
                      onClick: toggleOsoEnabled
                    }, "\n                OSO\n              ")
                  ]),
                  default: withCtx(() => [
                    _cache[33] || (_cache[33] = createBaseVNode("p", null, [
                      createBaseVNode("strong", null, "Order Sets Order")
                    ], -1)),
                    _cache[34] || (_cache[34] = createTextVNode()),
                    createBaseVNode("p", null, "\n              For each parent order fill, a new " + toDisplayString(isBuyOrder.value ? "Sell" : "Buy") + "\n              Limit order will be placed at the chosen price.\n            ", 1),
                    _cache[35] || (_cache[35] = createTextVNode()),
                    _cache[36] || (_cache[36] = createBaseVNode("p", null, "\n              Only a GTC or FOK time in force is supported for OSO orders.\n            ", -1)),
                    _cache[37] || (_cache[37] = createTextVNode())
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["value"]),
            _cache[38] || (_cache[38] = createTextVNode()),
            withDirectives(createBaseVNode("div", _hoisted_4$n, [
              createVNode(unref(DropdownSelector), {
                value: unref(cancelAfter),
                "onUpdate:value": _cache[9] || (_cache[9] = ($event) => isRef(cancelAfter) ? cancelAfter.value = $event : null),
                class: "advanced-option__gtd-options",
                label: "Cancel after",
                options: gtdOptions
              }, null, 8, ["value"])
            ], 512), [
              [vShow, isGtdTifActive.value]
            ])
          ]),
          _cache[44] || (_cache[44] = createTextVNode()),
          osoEnabled.value ? (openBlock(), createBlock(unref(OrderInputWithValidation), {
            key: 0,
            modelValue: osoPrice.value,
            "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => osoPrice.value = $event),
            label: labels.value.osoPrice.external,
            "inline-label": labels.value.osoPrice.inline,
            "error-label": labels.value.osoPrice.error,
            field: "osoPrice",
            "data-test": "osoPriceInput"
          }, null, 8, ["modelValue", "label", "inline-label", "error-label"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["order-data", "side", "fee-estimate", "valid", "dirty"]);
    };
  }
};
const LimitOrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__scopeId", "data-v-52066012"]]);
const maxMarketAmount = {
  message: maxAmountMessage,
  validate(amount, { side, availableBalances }) {
    if (useSubAccountStore().doesActiveAccountAllowNegativeBalances) {
      return true;
    }
    if (side === constants$1.ORDER_SIDE.BUY) {
      let decimalAmount;
      try {
        decimalAmount = new Decimal(amount);
      } catch (e) {
        return false;
      }
      const fee = useTradeviewFeeCalculators().calculateNetVolumeFeeForActiveMarketNoBonus(decimalAmount);
      const decimals = useActiveMarketStore().activeMarket.decimals.counter;
      const neededFunds = decimalAmount.add(fee).toDecimalPlaces(decimals, Decimal.ROUND_UP);
      return availableBalances.counter.greaterThanOrEqualTo(neededFunds);
    } else {
      return availableBalances.base.greaterThanOrEqualTo(toDecimal(amount));
    }
  }
};
defineRule("stopOrder_maxMarketAmount", wrapper(maxMarketAmount));
defineRule("stopOrder_priceFitMarket", wrapper(priceFitMarket));
defineRule("stopOrder_minMarketTotal", wrapper(minMarketTotal));
defineRule("stopOrder_maxNumber", wrapper(maxNumber));
defineRule("stopOrder_positivePrice", wrapper(positivePrice));
defineRule("stopOrder_limitPriceBand", wrapper(limitPriceBand));
const _hoisted_1$F = ["href"];
const _sfc_main$H = {
  __name: "StopMarketOrderForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const tradeviewFeeCalculators = useTradeviewFeeCalculators();
    const activeMarketStore = useActiveMarketStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const orderbook100Store = useOrderbook100Store();
    const balancesStore = useBalancesStore();
    const tradeviewTickersStore = useTradeviewTickersStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const amount = ref("");
    const price = ref("");
    const trailing = ref(false);
    const percentage = ref(0);
    const activeMarket = computed(() => {
      return activeMarketStore.activeMarket;
    });
    const isBuyOrder = computed(() => {
      return props.side === constants$1.ORDER_SIDE.BUY;
    });
    const estimate = computed(() => {
      if (price.value === "" || amount.value === "") {
        return "≈ 0.0";
      }
      let value;
      if (isBuyOrder.value) {
        const priceDecimal = toDecimal(price.value);
        if (priceDecimal.isZero()) {
          return "≈ 0.0";
        }
        value = toDecimal(amount.value).div(priceDecimal);
      } else {
        value = toDecimal(amount.value).mul(toDecimal(price.value));
      }
      return `≈ ${numberFormatter.price({
        value,
        decimals: !isBuyOrder.value ? activeMarket.value.decimals.counter : activeMarket.value.decimals.base,
        currencyCode: !isBuyOrder.value ? activeMarket.value.counter : activeMarket.value.base
      })}`;
    });
    const feeEstimate = computed(() => {
      const orderVolume = isBuyOrder.value ? toDecimal(amount.value) : toDecimal(amount.value).mul(toDecimal(price.value));
      if (!orderVolume.isPositive()) {
        return null;
      }
      return {
        taker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, false)
      };
    });
    const isSliderDisabled = computed(() => {
      const available = balancesStore.activeMarketAccountAvailableBalance;
      if (isBuyOrder.value) {
        return available.counter.isZero();
      }
      return available.base.isZero();
    });
    const trailingStopFaqLink = computed(() => {
      return URLService.getPageUrl("faq_get_answer", { question: "trailing-stop-order" });
    });
    const orderData = computed(() => {
      return {
        type: constants$1.ORDER_TYPE.STOP_MARKET,
        side: props.side,
        amount: amount.value,
        stopPrice: price.value,
        trailing: trailing.value,
        market: activeMarket.value.key
      };
    });
    const labels = computed(() => {
      return {
        amount: {
          external: isBuyOrder.value ? "Value" : "Amount",
          inline: activeMarket.value[isBuyOrder.value ? "counter" : "base"]
        },
        price: {
          external: "Trigger price",
          inline: activeMarket.value.counter,
          error: "trigger price"
        }
      };
    });
    const validationSchema = computed(() => {
      const decimals = isBuyOrder.value ? activeMarket.value.decimals.counter : activeMarket.value.decimals.base;
      return {
        amount: {
          required: true,
          decimal: { decimals },
          "stopOrder_maxMarketAmount": {
            side: props.side,
            availableBalances: balancesStore.activeMarketAccountAvailableBalance
          },
          "stopOrder_minMarketTotal": { side: props.side },
          "stopOrder_maxNumber": true
        },
        price: {
          required: true,
          decimal: {
            decimals: activeMarket.value.decimals.counter
          },
          "stopOrder_priceFitMarket": {
            side: props.side,
            currentPrice: tradeviewTickersStore.activeMarketTickerLastValue
          },
          "stopOrder_maxNumber": true,
          "stopOrder_positivePrice": true
        }
      };
    });
    const { meta, resetForm } = useForm({ validationSchema });
    function prefill() {
      const {
        amount: prefillAmount = "",
        stopPrice: prefillStopPrice = "",
        trailing: prefillTrailing = false
      } = tradeviewOrderFormStore.prefill;
      if (!prefillStopPrice && !prefillAmount) {
        return;
      }
      amount.value = prefillAmount;
      price.value = prefillStopPrice;
      trailing.value = Boolean(prefillTrailing);
      tradeviewOrderFormStore.setPrefill({});
      window.history.replaceState({}, document.title, useRouter().currentRoute.value.path);
    }
    function onPercentage(newPercent) {
      const fraction = new Decimal(newPercent).div(100);
      const availableBalances = balancesStore.activeMarketAccountAvailableBalance;
      if (isBuyOrder.value) {
        let availableCounter = availableBalances.counter.toDecimalPlaces(
          activeMarket.value.decimals.counter,
          Decimal.ROUND_DOWN
        );
        const fee = tradeviewFeeCalculators.calculateGrossVolumeFeeForActiveMarketNoBonus(
          availableCounter
        );
        availableCounter = availableCounter.minus(fee);
        if (availableCounter.isNegative()) {
          amount.value = "0";
          return;
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(
          availableCounter.mul(fraction).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN),
          activeMarket.value.decimals.counter
        );
      } else {
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(
          availableBalances.base.mul(fraction.toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN)),
          activeMarket.value.decimals.base
        );
      }
    }
    function clear() {
      amount.value = "";
      trailing.value = false;
      nextTick(resetForm);
    }
    function fullClear() {
      price.value = "";
      percentage.value = 0;
      clear();
    }
    function updateAmount(newAmount) {
      amount.value = newAmount;
      updatePercentage();
    }
    function updatePercentage() {
      if (amount.value === "") {
        percentage.value = 0;
        return;
      }
      let fraction = 0;
      const availableBalances = balancesStore.activeMarketAccountAvailableBalance;
      if (isBuyOrder.value) {
        const counterAmount = toDecimal(amount.value);
        const fee = tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(counterAmount);
        if (!availableBalances.counter.isPositive()) {
          percentage.value = 0;
          return;
        }
        fraction = counterAmount.plus(fee).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_UP).div(availableBalances.counter);
      } else {
        if (!availableBalances.base.isPositive()) {
          percentage.value = 0;
          return;
        }
        fraction = toDecimal(amount.value).div(availableBalances.base);
      }
      const newPercentage = fraction.mul(100).toDecimalPlaces(0, Decimal.ROUND_UP);
      percentage.value = Math.min(100, Number.parseInt(newPercentage.toFixed(0)));
    }
    function onPriceInput(newPrice) {
      price.value = newPrice;
      const decimalPrice = toDecimal(newPrice);
      const currentSelectedPrice = tradeviewTriggerValueStore.priceSetByTrigger;
      if (decimalPrice.gte(0) && (!currentSelectedPrice || !decimalPrice.equals(currentSelectedPrice))) {
        tradeviewTriggerValueStore.setPriceSetByTrigger(decimalPrice);
      }
    }
    function fillAvailableBalance() {
      onPercentage(100);
    }
    onBeforeMount(() => {
      tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.STOP_MARKET);
    });
    onMounted(() => {
      var _a2;
      prefill();
      if ((_a2 = tradeviewTriggerValueStore.priceSetByTrigger) == null ? void 0 : _a2.isPositive()) {
        price.value = numberFormatter.formatWithStrippedTrailingZeros(tradeviewTriggerValueStore.priceSetByTrigger, activeMarket.value.decimals.counter);
      }
    });
    watch(() => props.side, updatePercentage);
    watch(
      () => tradeviewTriggerValueStore.priceSetByTrigger,
      /** @param {module:numberUtils.Decimal|null} priceSetByTrigger */
      (priceSetByTrigger) => {
        if (!priceSetByTrigger) {
          return;
        }
        const currentPrice = toDecimal(price.value);
        if (currentPrice.equals(priceSetByTrigger)) {
          return;
        }
        price.value = numberFormatter.formatWithStrippedTrailingZeros(priceSetByTrigger, activeMarket.value.decimals.counter);
      }
    );
    watch(
      () => tradeviewTriggerValueStore.amountSetByTrigger,
      /** @param {module:numberUtils.Decimal|null} amountSetByTrigger */
      (amountSetByTrigger) => {
        if (!amountSetByTrigger) {
          return;
        }
        if (isBuyOrder.value) {
          const currentOffer = orderbook100Store.activeMarketCurrentOffer;
          if (!(currentOffer == null ? void 0 : currentOffer.ask)) {
            return;
          }
          amountSetByTrigger = amountSetByTrigger.mul(currentOffer.ask);
        }
        const currentAmount = toDecimal(amount.value);
        if (currentAmount.equals(amountSetByTrigger)) {
          return;
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        "order-data": orderData.value,
        side: props.side,
        "requires-matching": true,
        "requires-update-if-bonus-fee": false,
        "fee-estimate": feeEstimate.value,
        valid: unref(meta).valid,
        dirty: unref(meta).dirty,
        "taker-only-fee-estimate": "",
        onClear: fullClear,
        onFill: fillAvailableBalance
      }, {
        default: withCtx(() => [
          createVNode(unref(OrderInputWithValidation), {
            modelValue: price.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => price.value = $event),
            label: labels.value.price.external,
            "inline-label": labels.value.price.inline,
            "error-label": labels.value.price.error,
            class: "trigger-price-input",
            field: "price",
            "data-test": "priceInput",
            onInput: onPriceInput
          }, null, 8, ["modelValue", "label", "inline-label", "error-label"]),
          _cache[6] || (_cache[6] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: amount.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => amount.value = $event),
            estimate: estimate.value,
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: "amount-input",
            field: "amount",
            "data-test": "amountInput",
            onInput: updateAmount
          }, null, 8, ["modelValue", "estimate", "label", "inline-label"]),
          _cache[7] || (_cache[7] = createTextVNode()),
          createVNode(unref(OrderSlider), {
            value: percentage.value,
            "onUpdate:value": [
              _cache[2] || (_cache[2] = ($event) => percentage.value = $event),
              onPercentage
            ],
            class: "order-slider",
            min: 0,
            max: 100,
            "tooltip-formatter": (v) => `${v}%`,
            marks: (v) => v % 25 === 0,
            disabled: isSliderDisabled.value
          }, null, 8, ["value", "tooltip-formatter", "marks", "disabled"]),
          _cache[8] || (_cache[8] = createTextVNode()),
          createVNode(unref(LabeledSwitch), {
            value: trailing.value,
            "onUpdate:value": _cache[3] || (_cache[3] = ($event) => trailing.value = $event),
            class: "action",
            label: "Trailing stop",
            compact: ""
          }, {
            icon: withCtx(() => [
              createVNode(unref(AppTooltip), {
                "icon-size": 12,
                icon: "monochrome/info-circle.svg",
                distance: 8
              }, {
                default: withCtx(() => [
                  _cache[4] || (_cache[4] = createBaseVNode("p", null, "\n            A trailing stop follows the market movements and adjusts the trigger price of the stop order accordingly.\n          ", -1)),
                  _cache[5] || (_cache[5] = createTextVNode()),
                  createBaseVNode("a", {
                    href: trailingStopFaqLink.value,
                    target: "_blank",
                    class: "link"
                  }, "\n            Learn more.\n          ", 8, _hoisted_1$F)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["value"])
        ]),
        _: 1
      }, 8, ["order-data", "side", "fee-estimate", "valid", "dirty"]);
    };
  }
};
const StopMarketOrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__scopeId", "data-v-27068d03"]]);
const _sfc_main$G = {
  __name: "StopLimitOrderForm",
  props: {
    // One of ordersConstants.ORDER_SIDE.BUY|SELL
    side: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const tradeviewFeeCalculators = useTradeviewFeeCalculators();
    const activeMarketStore = useActiveMarketStore();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const balancesStore = useBalancesStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const tradeviewTickersStore = useTradeviewTickersStore();
    const triggerPrice = ref("");
    const limitPrice = ref("");
    const amount = ref("");
    const value = ref("");
    const percentage = ref(0);
    const isValueInputInCalcMode = ref(true);
    const activeMarket = computed(() => {
      return activeMarketStore.activeMarket;
    });
    const isSliderDisabled = computed(() => {
      if (!limitPrice.value || !toDecimal(limitPrice.value).isPositive()) {
        return true;
      }
      const available = balancesStore.activeMarketAccountAvailableBalance;
      if (isBuyOrder.value) {
        return available.counter.isZero();
      }
      return available.base.isZero();
    });
    const isBuyOrder = computed(() => {
      return props.side === constants$1.ORDER_SIDE.BUY;
    });
    const orderData = computed(() => {
      return {
        type: constants$1.ORDER_TYPE.STOP_LIMIT,
        side: props.side,
        amount: amount.value,
        stopPrice: triggerPrice.value,
        trailing: false,
        market: activeMarket.value.key,
        price: limitPrice.value
      };
    });
    const labels = computed(() => {
      return {
        triggerPrice: {
          external: "Trigger price",
          inline: activeMarket.value.counter,
          error: "trigger price"
        },
        amount: {
          external: "Amount",
          inline: activeMarket.value.base
        },
        value: {
          external: "Value",
          inline: activeMarket.value.counter
        },
        limitPrice: {
          external: "Limit price",
          inline: activeMarket.value.counter,
          error: "limit price"
        }
      };
    });
    const validationSchema = computed(() => {
      return {
        amount: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.base },
          "limitOrder_maxAmount": {
            side: props.side,
            availableBalances: balancesStore.activeMarketAccountAvailableBalance
          },
          "limitOrder_minOrderValue": true,
          "limitOrder_maxNumber": true
        },
        triggerPrice: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.counter },
          "stopOrder_priceFitMarket": {
            side: props.side,
            currentPrice: tradeviewTickersStore.activeMarketTickerLastValue
          },
          "limitOrder_maxNumber": true
        },
        limitPrice: {
          required: true,
          decimal: { decimals: activeMarket.value.decimals.counter },
          "stopOrder_limitPriceBand": { side: props.side },
          "limitOrder_maxNumber": true
        }
      };
    });
    const feeEstimate = computed(() => {
      const orderVolume = toDecimal(value.value);
      if (!orderVolume.isPositive()) {
        return null;
      }
      return {
        maker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, true),
        taker: tradeviewFeeCalculators.calculateNetVolumeFeeForActiveMarketNoBonus(orderVolume, false)
      };
    });
    const { meta, resetForm } = useForm({ validationSchema });
    function setIsValueInputInCalcMode(newValue) {
      isValueInputInCalcMode.value = newValue;
    }
    function prefill() {
      const {
        amount: prefillAmount = "",
        stopPrice: prefillStopPrice = "",
        price: prefillPrice = ""
      } = tradeviewOrderFormStore.prefill;
      if (!prefillAmount || !prefillStopPrice || !prefillPrice) {
        return;
      }
      amount.value = prefillAmount;
      limitPrice.value = prefillPrice;
      triggerPrice.value = prefillStopPrice;
      tradeviewOrderFormStore.setPrefill({});
      window.history.replaceState({}, document.title, useRouter().currentRoute.value.path);
    }
    function fullClear() {
      limitPrice.value = "";
      triggerPrice.value = "";
      amount.value = "";
      value.value = "";
      tradeviewTriggerValueStore.setPriceSetByTrigger(null);
      percentage.value = 0;
      nextTick(resetForm);
    }
    function onTriggerPriceInput(price) {
      triggerPrice.value = price;
      const decimalPrice = toDecimal(price);
      const currentSelectedPrice = tradeviewTriggerValueStore.priceSetByTrigger;
      if (decimalPrice.gte(0) && (!currentSelectedPrice || !decimalPrice.equals(currentSelectedPrice))) {
        tradeviewTriggerValueStore.setPriceSetByTrigger(decimalPrice);
      }
    }
    function onAmountInput(newAmount) {
      amount.value = newAmount;
      updatePercentage();
      if (isValueInputInCalcMode.value) {
        if (!amount.value) {
          value.value = "";
          return;
        }
        value.value = numberFormatter.formatWithStrippedTrailingZeros(
          toDecimal(newAmount).mul(toDecimal(limitPrice.value)).toDecimalPlaces(activeMarket.value.decimals.counter, Decimal.ROUND_DOWN),
          activeMarket.value.decimals.counter
        );
      }
    }
    function onValueInput(newValue) {
      value.value = newValue;
      if (isValueInputInCalcMode.value) {
        return;
      }
      const decimalPrice = toDecimal(limitPrice.value);
      if (!decimalPrice.isZero()) {
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(
          toDecimal(newValue).div(decimalPrice).toDecimalPlaces(activeMarket.value.decimals.base, Decimal.ROUND_DOWN),
          activeMarket.value.decimals.base
        );
      }
    }
    function updatePercentage() {
      percentage.value = orderUtils.calculateLimitOrderPercentage(
        limitPrice.value,
        amount.value,
        isBuyOrder.value,
        activeMarket.value.decimals.counter,
        () => tradeviewFeeCalculators,
        () => balancesStore
      );
    }
    function onLimitPriceInput(newLimitPrice) {
      limitPrice.value = newLimitPrice;
      const { amount: calculatedAmount, value: calculatedValue } = orderUtils.calcAmountAndValueBasedOnPrice(
        newLimitPrice,
        amount.value,
        value.value,
        activeMarket.value.decimals.base,
        activeMarket.value.decimals.counter
      );
      amount.value = calculatedAmount;
      value.value = calculatedValue;
      if (newLimitPrice !== "") {
        requestAnimationFrame(() => {
          if (amount.value) {
            updatePercentage();
          }
        });
      }
    }
    function onPercentageInput(newPercentage) {
      amount.value = orderUtils.calculateLimitOrderAmountFromPercentage(
        newPercentage,
        limitPrice.value,
        isBuyOrder.value,
        activeMarket.value.decimals.base,
        activeMarket.value.decimals.counter,
        () => tradeviewFeeCalculators,
        () => balancesStore
      );
    }
    function fillAvailableBalance() {
      onPercentageInput(100);
    }
    onBeforeMount(() => {
      tradeviewOrderFormStore.setActiveOrderType(constants$1.ORDER_TYPE.STOP_LIMIT);
    });
    onMounted(() => {
      prefill();
      const priceSetFromOutsideForm = tradeviewTriggerValueStore.priceSetByTrigger;
      if (priceSetFromOutsideForm && priceSetFromOutsideForm.isPositive()) {
        triggerPrice.value = priceSetFromOutsideForm.toFixed(activeMarket.value.decimals.counter);
      }
    });
    watch(() => props.side, updatePercentage);
    watch(
      () => tradeviewTriggerValueStore.priceSetByTrigger,
      /** @param {module:numberUtils.Decimal|null} priceSetByTrigger */
      (priceSetByTrigger) => {
        if (!priceSetByTrigger) {
          return;
        }
        const currentPrice = toDecimal(triggerPrice.value);
        if (currentPrice.equals(priceSetByTrigger)) {
          return;
        }
        triggerPrice.value = numberFormatter.formatWithStrippedTrailingZeros(priceSetByTrigger, activeMarket.value.decimals.counter);
      }
    );
    watch(
      () => tradeviewTriggerValueStore.amountSetByTrigger,
      /** @param {module:numberUtils.Decimal|null} amountSetByTrigger */
      (amountSetByTrigger) => {
        if (!amountSetByTrigger) {
          return;
        }
        const currentAmount = toDecimal(amount.value);
        if (currentAmount.equals(amountSetByTrigger)) {
          return;
        }
        amount.value = numberFormatter.formatWithStrippedTrailingZeros(amountSetByTrigger, activeMarket.value.decimals.base);
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(OrderForm), {
        "order-data": orderData.value,
        side: props.side,
        "requires-update-if-bonus-fee": false,
        "fee-estimate": feeEstimate.value,
        valid: unref(meta).valid,
        dirty: unref(meta).dirty,
        "requires-matching": "",
        onClear: fullClear,
        onFill: fillAvailableBalance
      }, {
        default: withCtx(() => [
          createVNode(unref(OrderInputWithValidation), {
            modelValue: triggerPrice.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => triggerPrice.value = $event),
            label: labels.value.triggerPrice.external,
            "inline-label": labels.value.triggerPrice.inline,
            "error-label": labels.value.triggerPrice.error,
            class: "input",
            field: "triggerPrice",
            "data-test": "triggerPriceInput",
            onInput: onTriggerPriceInput
          }, null, 8, ["modelValue", "label", "inline-label", "error-label"]),
          _cache[7] || (_cache[7] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: limitPrice.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => limitPrice.value = $event),
            label: labels.value.limitPrice.external,
            "inline-label": labels.value.limitPrice.inline,
            "error-label": labels.value.limitPrice.error,
            class: "input",
            field: "limitPrice",
            "data-test": "limitPriceInput",
            onInput: onLimitPriceInput
          }, null, 8, ["modelValue", "label", "inline-label", "error-label"]),
          _cache[8] || (_cache[8] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: amount.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => amount.value = $event),
            label: labels.value.amount.external,
            "inline-label": labels.value.amount.inline,
            class: "input",
            field: "amount",
            "data-test": "amountInput",
            onInput: onAmountInput
          }, null, 8, ["modelValue", "label", "inline-label"]),
          _cache[9] || (_cache[9] = createTextVNode()),
          createVNode(unref(OrderSlider), {
            value: percentage.value,
            "onUpdate:value": [
              _cache[3] || (_cache[3] = ($event) => percentage.value = $event),
              onPercentageInput
            ],
            class: "order-slider",
            min: 0,
            max: 100,
            "tooltip-formatter": (v) => `${v}%`,
            marks: (v) => v % 25 === 0,
            disabled: isSliderDisabled.value
          }, null, 8, ["value", "tooltip-formatter", "marks", "disabled"]),
          _cache[10] || (_cache[10] = createTextVNode()),
          createVNode(unref(OrderInputWithValidation), {
            modelValue: value.value,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => value.value = $event),
            label: labels.value.value.external,
            "inline-label": labels.value.value.inline,
            field: "value",
            "data-test": "totalInput",
            onFocus: _cache[5] || (_cache[5] = ($event) => setIsValueInputInCalcMode(false)),
            onBlur: _cache[6] || (_cache[6] = ($event) => setIsValueInputInCalcMode(true)),
            onInput: onValueInput
          }, null, 8, ["modelValue", "label", "inline-label"])
        ]),
        _: 1
      }, 8, ["order-data", "side", "fee-estimate", "valid", "dirty"]);
    };
  }
};
const StopLimitOrderForm = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-d1d11601"]]);
const _sfc_main$F = {
  name: "OrderTypeSelector",
  components: {
    BtsLink,
    TabSelector
  },
  props: {
    choices: {
      type: Array,
      required: true
    }
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore()
    };
  },
  data() {
    return {
      ORDER_SIDE: constants$1.ORDER_SIDE
    };
  },
  computed: {
    activeOrderFormType() {
      return this.tradeviewOrderFormStore.activeOrderFormType;
    },
    activeOrderSide() {
      return this.tradeviewOrderFormStore.activeOrderSide;
    },
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    }
  },
  methods: {
    setActiveOrderFormType({ value, disabled }) {
      if (disabled) {
        return;
      }
      this.tradeviewOrderFormStore.setActiveOrderFormType(value);
    }
  }
};
const _hoisted_1$E = { class: "order-type-selector" };
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BtsLink = resolveComponent("BtsLink");
  const _component_TabSelector = resolveComponent("TabSelector");
  return openBlock(), createElementBlock("div", _hoisted_1$E, [
    (openBlock(), createBlock(_component_TabSelector, {
      key: `order-tabs-${$props.choices.length}`,
      "active-tab-id": $options.activeOrderFormType,
      "indicator-color": $setup.tradeviewOrderFormStore.activeOrderSide
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.choices, (choice) => {
          return openBlock(), createBlock(_component_BtsLink, {
            key: choice.name,
            class: normalizeClass([{
              "order-type-selector__item--selected-buy": $options.activeOrderFormType === choice.value && $options.activeOrderSide === $data.ORDER_SIDE.BUY,
              "order-type-selector__item--selected-sell": $options.activeOrderFormType === choice.value && $options.activeOrderSide === $data.ORDER_SIDE.SELL,
              "order-type-selector__item--disabled": choice.disabled,
              [`js-tab__${choice.value}`]: true
            }, "order-type-selector__item"]),
            title: choice.tooltipText,
            "test-id": `order-type-selector--${choice.value}`,
            onClick: ($event) => $options.setActiveOrderFormType(choice)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(choice.name), 1)
            ]),
            _: 2
          }, 1032, ["class", "title", "test-id", "onClick"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["active-tab-id", "indicator-color"]))
  ]);
}
const OrderTypeSelector = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$x], ["__scopeId", "data-v-da495bd5"]]);
const _sfc_main$E = {
  name: "AccountInfo",
  components: {
    TradeviewModal,
    AppButton: BtsButton
  },
  setup() {
    return {
      toastStore: useToastStore(),
      activeMarketStore: useActiveMarketStore(),
      currenciesStore: useCurrenciesStore(),
      subAccountStore: useSubAccountStore(),
      balancesStore: useBalancesStore(),
      settlementBatchStore: useSettlementBatchStore()
    };
  },
  data() {
    return {
      isSettlementModalOpen: false,
      isBatchPreparing: false
    };
  },
  computed: {
    isTransferButtonVisible() {
      return this.subAccountStore.hasSubAccounts && this.$has("sub_accounts_transfer");
    },
    isDepositAndWithdrawalVisible() {
      return this.$has("deposits_read") && this.$has("withdrawals_read");
    },
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    withdrawUrl() {
      return URLService.getPageUrl("accountWithdraw");
    },
    depositUrl() {
      return URLService.getPageUrl("accountDeposit");
    },
    transferUrl() {
      return URLService.getPageUrl("sub_account_transfer");
    },
    userBalance() {
      return this.balancesStore.activeMarketAccountBalance;
    },
    userAvailableBalance() {
      return this.balancesStore.activeMarketAccountAvailableBalance;
    },
    /**
     * @returns {module:Settlement.AccountSettlementPositionInfo}
     */
    settlementPosition() {
      return this.balancesStore.activeAccountSettlementPositions;
    },
    preparedBatchId() {
      return this.settlementBatchStore.preparedSettlementBatchId;
    },
    isBatchPrepared() {
      return this.preparedBatchId !== null;
    },
    preparedBatchPartialId() {
      return `${this.preparedBatchId.slice(0, 4)}...${this.preparedBatchId.slice(-4)}`;
    }
  },
  methods: {
    openTransferModal(e) {
      e.preventDefault();
      this.subAccountStore.openTransferFundsModal();
    },
    formatBalance(value, currency) {
      const decimals = this.currenciesStore.getCurrency(currency).decimals;
      return numberFormatter.decimal({ value, decimals });
    },
    openSettlementConfirmationModal() {
      this.isSettlementModalOpen = true;
    },
    async prepare() {
      this.isBatchPreparing = true;
      this.isSettlementModalOpen = false;
      try {
        const response = await settlementBatchApi.prepare(this.subAccountStore.activeSubAccountId);
        this.settlementBatchStore.setPreparedSettlementBatchId((response == null ? void 0 : response.batchUuid) ?? null);
        this.toastStore.showSuccessToast("You can now settle this batch.", "Settlement batch prepared");
      } catch (e) {
        this.settlementBatchStore.fetch();
        this.toastStore.showErrorToast(getErrorTextFromApiResponseError(e), "Error preparing settlement batch");
      } finally {
        this.isBatchPreparing = false;
      }
    },
    async settle() {
      try {
        await settlementBatchApi.settle(this.preparedBatchId);
        this.toastStore.showSuccessToast(
          `Settlement batch with id ${this.preparedBatchId} has been successfully settled.`,
          "Settlement batch settled"
        );
      } catch (e) {
        this.toastStore.showErrorToast(getErrorTextFromApiResponseError(e), "Error settling batch");
      } finally {
        this.balancesStore.fetch();
        this.settlementBatchStore.fetch();
      }
    }
  }
};
const _hoisted_1$D = { class: "account-info" };
const _hoisted_2$r = { class: "account-info__wrapper" };
const _hoisted_3$o = { class: "account-info__group" };
const _hoisted_4$m = { class: "info" };
const _hoisted_5$j = {
  class: "info__value",
  "data-test": "baseAvailability"
};
const _hoisted_6$g = { class: "info" };
const _hoisted_7$e = {
  class: "info__value",
  "data-test": "counterAvailability"
};
const _hoisted_8$e = { class: "account-info__group" };
const _hoisted_9$c = { class: "info" };
const _hoisted_10$c = {
  class: "info__value",
  "data-test": "activePairBaseAvailability"
};
const _hoisted_11$b = { class: "info" };
const _hoisted_12$9 = {
  class: "info__value",
  "data-test": "activePairCounterAvailability"
};
const _hoisted_13$9 = ["href"];
const _hoisted_14$9 = ["href"];
const _hoisted_15$9 = ["href"];
const _hoisted_16$9 = {
  key: 0,
  class: "settlement"
};
const _hoisted_17$9 = { class: "account-info__wrapper" };
const _hoisted_18$8 = { class: "account-info__group" };
const _hoisted_19$6 = { class: "info" };
const _hoisted_20$6 = {
  class: "info__value",
  "data-test": "netOpenPosition"
};
const _hoisted_21$6 = { class: "account-info__group" };
const _hoisted_22$6 = { class: "info" };
const _hoisted_23$4 = {
  class: "info__value",
  "data-test": "maxOpenPosition"
};
const _hoisted_24$4 = { class: "account-info__pts-button-wrapper" };
const _hoisted_25$4 = {
  key: 0,
  class: "prepared-batch-info"
};
const _hoisted_26$3 = ["title"];
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppButton = resolveComponent("AppButton");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createElementBlock("div", _hoisted_1$D, [
    createBaseVNode("div", _hoisted_2$r, [
      !$options.settlementPosition ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _cache[3] || (_cache[3] = createBaseVNode("span", { class: "account-info__subtitle" }, "Total balances", -1)),
        _cache[4] || (_cache[4] = createTextVNode()),
        createBaseVNode("div", _hoisted_3$o, [
          createBaseVNode("div", _hoisted_4$m, [
            createTextVNode(toDisplayString($options.activeMarket.base) + " ", 1),
            createBaseVNode("span", _hoisted_5$j, toDisplayString($options.formatBalance($options.userBalance.base, $options.activeMarket.base)), 1)
          ]),
          _cache[2] || (_cache[2] = createTextVNode()),
          createBaseVNode("div", _hoisted_6$g, [
            createTextVNode(toDisplayString($options.activeMarket.counter) + " ", 1),
            createBaseVNode("span", _hoisted_7$e, toDisplayString($options.formatBalance($options.userBalance.counter, $options.activeMarket.counter)), 1)
          ])
        ])
      ], 64)) : createCommentVNode("", true),
      _cache[8] || (_cache[8] = createTextVNode()),
      _cache[9] || (_cache[9] = createBaseVNode("span", { class: "account-info__subtitle" }, "Available balances", -1)),
      _cache[10] || (_cache[10] = createTextVNode()),
      createBaseVNode("div", _hoisted_8$e, [
        createBaseVNode("div", _hoisted_9$c, [
          createTextVNode(toDisplayString($options.activeMarket.base) + " ", 1),
          createBaseVNode("span", _hoisted_10$c, toDisplayString($options.formatBalance($options.userAvailableBalance.base, $options.activeMarket.base)), 1)
        ]),
        _cache[5] || (_cache[5] = createTextVNode()),
        createBaseVNode("div", _hoisted_11$b, [
          createTextVNode(toDisplayString($options.activeMarket.counter) + " ", 1),
          createBaseVNode("span", _hoisted_12$9, toDisplayString($options.formatBalance($options.userAvailableBalance.counter, $options.activeMarket.counter)), 1)
        ])
      ]),
      _cache[11] || (_cache[11] = createTextVNode()),
      !$options.settlementPosition && $options.isDepositAndWithdrawalVisible ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["account-info__button-wrapper", { "account-info__button-wrapper--with-transfer": $options.isTransferButtonVisible }])
      }, [
        createBaseVNode("a", {
          href: $options.depositUrl,
          class: "account-info__button",
          target: "_blank"
        }, "\n          Deposit\n        ", 8, _hoisted_13$9),
        _cache[6] || (_cache[6] = createTextVNode()),
        createBaseVNode("a", {
          href: $options.withdrawUrl,
          class: "account-info__button",
          target: "_blank"
        }, "\n          Withdraw\n        ", 8, _hoisted_14$9),
        _cache[7] || (_cache[7] = createTextVNode()),
        $options.isTransferButtonVisible ? (openBlock(), createElementBlock("a", {
          key: 0,
          class: "account-info__button",
          target: "_blank",
          href: $options.transferUrl,
          onClick: _cache[0] || (_cache[0] = (...args) => $options.openTransferModal && $options.openTransferModal(...args))
        }, "\n          Transfer\n        ", 8, _hoisted_15$9)) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true)
    ]),
    _cache[27] || (_cache[27] = createTextVNode()),
    $options.settlementPosition ? (openBlock(), createElementBlock("div", _hoisted_16$9, [
      createBaseVNode("div", _hoisted_17$9, [
        _cache[16] || (_cache[16] = createBaseVNode("span", { class: "account-info__subtitle" }, "Net open position", -1)),
        _cache[17] || (_cache[17] = createTextVNode()),
        createBaseVNode("div", _hoisted_18$8, [
          createBaseVNode("div", _hoisted_19$6, [
            createTextVNode(toDisplayString($options.settlementPosition.calculationCurrency) + " ", 1),
            createBaseVNode("span", _hoisted_20$6, toDisplayString($options.formatBalance($options.settlementPosition.netOpenPosition, $options.settlementPosition.calculationCurrency)), 1)
          ])
        ]),
        _cache[18] || (_cache[18] = createTextVNode()),
        _cache[19] || (_cache[19] = createBaseVNode("span", { class: "account-info__subtitle" }, "Max open position", -1)),
        _cache[20] || (_cache[20] = createTextVNode()),
        createBaseVNode("div", _hoisted_21$6, [
          createBaseVNode("div", _hoisted_22$6, [
            createTextVNode(toDisplayString($options.settlementPosition.calculationCurrency) + " ", 1),
            createBaseVNode("span", _hoisted_23$4, toDisplayString($options.formatBalance($options.settlementPosition.maxOpenPosition, $options.settlementPosition.calculationCurrency)), 1)
          ])
        ]),
        _cache[21] || (_cache[21] = createTextVNode()),
        createBaseVNode("div", _hoisted_24$4, [
          $options.isBatchPrepared ? (openBlock(), createBlock(_component_AppButton, {
            key: 0,
            class: "account-info__button",
            disabled: $data.isBatchPreparing,
            onClick: $options.settle
          }, {
            default: withCtx(() => _cache[12] || (_cache[12] = [
              createTextVNode("\n            Settle batch\n          ")
            ])),
            _: 1
          }, 8, ["disabled", "onClick"])) : (openBlock(), createBlock(_component_AppButton, {
            key: 1,
            class: "account-info__button",
            disabled: $data.isBatchPreparing,
            onClick: $options.openSettlementConfirmationModal
          }, {
            default: withCtx(() => _cache[13] || (_cache[13] = [
              createTextVNode("\n            Prepare settlement batch\n          ")
            ])),
            _: 1
          }, 8, ["disabled", "onClick"]))
        ]),
        _cache[22] || (_cache[22] = createTextVNode()),
        $options.isBatchPrepared ? (openBlock(), createElementBlock("div", _hoisted_25$4, [
          _cache[14] || (_cache[14] = createBaseVNode("div", { class: "account-info__subtitle" }, "\n            Prepared batch id:\n          ", -1)),
          _cache[15] || (_cache[15] = createTextVNode()),
          createBaseVNode("div", {
            class: "info__value",
            title: $options.preparedBatchId
          }, toDisplayString($options.preparedBatchPartialId), 9, _hoisted_26$3)
        ])) : createCommentVNode("", true)
      ]),
      _cache[26] || (_cache[26] = createTextVNode()),
      createVNode(_component_TradeviewModal, {
        "is-open": $data.isSettlementModalOpen,
        "onUpdate:isOpen": _cache[1] || (_cache[1] = ($event) => $data.isSettlementModalOpen = $event),
        "confirm-text": "Prepare",
        "cancel-text": "Cancel",
        onConfirm: $options.prepare
      }, {
        title: withCtx(() => _cache[23] || (_cache[23] = [
          createTextVNode("\n          Prepare settlement batch\n        ")
        ])),
        body: withCtx(() => _cache[24] || (_cache[24] = [
          createTextVNode("\n          Are you sure you want to prepare a settlement batch?\n        ")
        ])),
        _: 1
      }, 8, ["is-open", "onConfirm"])
    ])) : createCommentVNode("", true)
  ]);
}
const AccountInfo = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$w], ["__scopeId", "data-v-d1eaad25"]]);
const _sfc_main$D = {
  name: "CreateOrder",
  components: {
    BtsLink,
    AccountInfo,
    TabSelector,
    WidgetLayout,
    MarketOrderForm,
    LimitOrderForm,
    StopMarketOrderForm,
    StopLimitOrderForm,
    OrderTypeSelector,
    DerivativesMarketOrderForm,
    DerivativesLimitOrderForm,
    DerivativesTakeProfitStopLossForm
  },
  setup() {
    return {
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      activeMarketStore: useActiveMarketStore(),
      featureStatusStore: useFeatureStatusStore(),
      userStateStore: useUserStateStore()
    };
  },
  data() {
    return {
      ordersConstants: constants$1
    };
  },
  computed: {
    activeOrderSide() {
      return this.tradeviewOrderFormStore.activeOrderSide;
    },
    orderFormTypeChoices() {
      if (this.activeMarketStore.isSpot) {
        return [
          {
            name: "Market",
            value: constants$1.ORDER_FORM_TYPE.MARKET
          },
          {
            name: "Limit",
            value: constants$1.ORDER_FORM_TYPE.LIMIT
          },
          {
            name: "Stop Market",
            value: constants$1.ORDER_FORM_TYPE.STOP_MARKET
          },
          {
            name: "Stop Limit",
            value: constants$1.ORDER_FORM_TYPE.STOP_LIMIT
          }
        ];
      } else if (this.activeMarketStore.isPerpetual) {
        return [
          {
            name: "Market",
            value: constants$1.ORDER_FORM_TYPE.MARKET
          },
          {
            name: "Limit",
            value: constants$1.ORDER_FORM_TYPE.LIMIT
          },
          {
            name: "TP / SL",
            value: constants$1.ORDER_FORM_TYPE.TPSL
          }
        ];
      }
      return [];
    },
    activeOrderFormTypeComponent() {
      if (this.activeMarketStore.isSpot) {
        const components = {
          [constants$1.ORDER_FORM_TYPE.MARKET]: markRaw(MarketOrderForm),
          [constants$1.ORDER_FORM_TYPE.LIMIT]: markRaw(LimitOrderForm),
          [constants$1.ORDER_FORM_TYPE.STOP_MARKET]: markRaw(StopMarketOrderForm),
          [constants$1.ORDER_FORM_TYPE.STOP_LIMIT]: markRaw(StopLimitOrderForm)
        };
        return components[this.tradeviewOrderFormStore.activeOrderFormType] ? components[this.tradeviewOrderFormStore.activeOrderFormType] : MarketOrderForm;
      } else if (this.activeMarketStore.isPerpetual) {
        const components = {
          [constants$1.ORDER_FORM_TYPE.MARKET]: markRaw(DerivativesMarketOrderForm),
          [constants$1.ORDER_FORM_TYPE.LIMIT]: markRaw(DerivativesLimitOrderForm),
          [constants$1.ORDER_FORM_TYPE.TPSL]: markRaw(DerivativesTakeProfitStopLossForm)
        };
        return components[this.tradeviewOrderFormStore.activeOrderFormType] ? components[this.tradeviewOrderFormStore.activeOrderFormType] : DerivativesMarketOrderForm;
      }
      return {
        [constants$1.ORDER_FORM_TYPE.MARKET]: MarketOrderForm
      };
    },
    /**
     * @type {module:featureStatusStore.FeatureStatus}
     */
    tradeFeatureStatus() {
      if (!this.featureStatusStore.isTradeEnabled) {
        return this.featureStatusStore.getFeatureStatus(featureStatusConstants.FEATURE_TYPES.TRADE);
      }
      return { enabled: true };
    },
    activeTab() {
      return this.activeOrderSide === constants$1.ORDER_SIDE.BUY ? 0 : 1;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    }
  },
  methods: {
    setActiveOrderSide(side) {
      this.tradeviewOrderFormStore.setActiveOrderSide(side);
    },
    redirectToPage(link) {
      window.location.href = link;
    }
  }
};
const _hoisted_1$C = {
  key: 0,
  class: "create-order__container"
};
const _hoisted_2$q = { class: "create-order__form" };
const _hoisted_3$n = {
  key: 1,
  class: "trade-feature-status-disabled"
};
const _hoisted_4$l = { class: "trade-feature-status-disabled__text trade-feature-status-disabled__text--title" };
const _hoisted_5$i = {
  key: 0,
  class: "trade-feature-status-disabled__text"
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BtsLink = resolveComponent("BtsLink");
  const _component_TabSelector = resolveComponent("TabSelector");
  const _component_OrderTypeSelector = resolveComponent("OrderTypeSelector");
  const _component_AccountInfo = resolveComponent("AccountInfo");
  const _component_WidgetLayout = resolveComponent("WidgetLayout");
  return openBlock(), createBlock(_component_WidgetLayout, { class: "widget create-order" }, {
    tabs: withCtx(() => [
      createVNode(_component_TabSelector, {
        class: normalizeClass({ "buy-sell-selector-disabled": $options.isAuthenticated && !$options.tradeFeatureStatus.enabled }),
        "active-tab-id": $options.activeOrderSide,
        "indicator-color": $options.activeOrderSide
      }, {
        default: withCtx(() => [
          createVNode(_component_BtsLink, {
            class: normalizeClass([{
              "tab-selector__item--active-buy": $options.activeOrderSide === $data.ordersConstants.ORDER_SIDE.BUY
            }, "tab-selector__item js-tab__buy"]),
            "test-id": "order-side-selector--buy",
            onClick: _cache[0] || (_cache[0] = ($event) => $options.setActiveOrderSide($data.ordersConstants.ORDER_SIDE.BUY))
          }, {
            default: withCtx(() => _cache[3] || (_cache[3] = [
              createTextVNode("\n          Buy\n        ")
            ])),
            _: 1
          }, 8, ["class"]),
          _cache[5] || (_cache[5] = createTextVNode()),
          createVNode(_component_BtsLink, {
            class: normalizeClass([{
              "tab-selector__item--active-sell": $options.activeOrderSide === $data.ordersConstants.ORDER_SIDE.SELL
            }, "tab-selector__item js-tab__sell"]),
            "test-id": "order-side-selector--sell",
            onClick: _cache[1] || (_cache[1] = ($event) => $options.setActiveOrderSide($data.ordersConstants.ORDER_SIDE.SELL))
          }, {
            default: withCtx(() => _cache[4] || (_cache[4] = [
              createTextVNode("\n          Sell\n        ")
            ])),
            _: 1
          }, 8, ["class"])
        ]),
        _: 1
      }, 8, ["class", "active-tab-id", "indicator-color"])
    ]),
    default: withCtx(() => [
      _cache[9] || (_cache[9] = createTextVNode()),
      !$options.isAuthenticated || $options.tradeFeatureStatus.enabled ? (openBlock(), createElementBlock("div", _hoisted_1$C, [
        createVNode(_component_OrderTypeSelector, { choices: $options.orderFormTypeChoices }, null, 8, ["choices"]),
        _cache[6] || (_cache[6] = createTextVNode()),
        createBaseVNode("div", _hoisted_2$q, [
          (openBlock(), createBlock(resolveDynamicComponent($options.activeOrderFormTypeComponent), { side: $options.activeOrderSide }, null, 8, ["side"]))
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_3$n, [
        createBaseVNode("div", _hoisted_4$l, toDisplayString($options.tradeFeatureStatus.summary), 1),
        _cache[7] || (_cache[7] = createTextVNode()),
        $options.tradeFeatureStatus.description ? (openBlock(), createElementBlock("div", _hoisted_5$i, toDisplayString($options.tradeFeatureStatus.description), 1)) : createCommentVNode("", true),
        _cache[8] || (_cache[8] = createTextVNode()),
        $options.tradeFeatureStatus.ctaText && $options.tradeFeatureStatus.ctaLink ? (openBlock(), createElementBlock("button", {
          key: 1,
          class: "button button--primary mt24",
          onClick: _cache[2] || (_cache[2] = ($event) => $options.redirectToPage($options.tradeFeatureStatus.ctaLink))
        }, toDisplayString($options.tradeFeatureStatus.ctaText), 1)) : createCommentVNode("", true)
      ])),
      _cache[10] || (_cache[10] = createTextVNode()),
      $options.isAuthenticated && $setup.activeMarketStore.isSpot ? (openBlock(), createBlock(_component_AccountInfo, { key: 2 })) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
const CreateOrder = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$v], ["__scopeId", "data-v-fc66e779"]]);
const TRADES_DISPLAYED = 100;
const _sfc_main$C = {
  name: "TradeBookData",
  components: {
    AppScrollbar: _sfc_main$1g
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradesStore: useTradesStore(),
      visibilityStore: useVisibilityStore(),
      tradeviewSoundsStore: useTradeviewSoundsStore()
    };
  },
  data() {
    return {
      liveTrades: [],
      isAnimationDisabled: true,
      throttledUpdateTrades: this.$minMaxThrottle(
        this.updateTrades,
        constants.TIMERS.TRADEBOOK.MIN_THROTTLE,
        constants.TIMERS.TRADEBOOK.MAX_THROTTLE
      ),
      constants,
      ordersConstants: constants$1
    };
  },
  watch: {
    "tradesStore.activeMarketTrades": {
      handler(newTrades) {
        if (this.visibilityStore.isHidden) {
          return;
        }
        if (this.liveTrades.length === 0) {
          this.updateTrades(newTrades);
        } else {
          this.throttledUpdateTrades(newTrades);
        }
      },
      immediate: true
    },
    "visibilityStore.isHidden": {
      handler(isHidden, wasHidden) {
        if (wasHidden) {
          this.throttledUpdateTrades(this.tradesStore.activeMarketTrades);
        }
      }
    }
  },
  methods: {
    updateTrades(newTrades) {
      newTrades = this.formatTrades(newTrades.slice(0, TRADES_DISPLAYED));
      if (this.liveTrades.length === 0 && newTrades.length > 0 || this.liveTrades.length > 0 && newTrades.length === 0) {
        this.isAnimationDisabled = true;
        setTimeout(() => {
          this.isAnimationDisabled = false;
        }, constants.TIMERS.TRADEBOOK.ANIMATION * 2);
      }
      requestAnimationFrame(() => {
        const scrollbarComponent = this.$refs.perfectScrollbar;
        if (scrollbarComponent && scrollbarComponent.ps && this.liveTrades.length >= TRADES_DISPLAYED) {
          scrollbarComponent.ps.isAlive = false;
          requestAnimationFrame(() => {
            if (scrollbarComponent.ps) {
              scrollbarComponent.ps.isAlive = true;
            }
          });
        }
        this.liveTrades = Object.freeze(newTrades);
      });
    },
    /**
     * @param {module:publicTrades.trade[]} trades
     * @returns {*}
     */
    formatTrades(trades) {
      const maxAmount2 = trades.reduce(
        (max, { amount }) => max.greaterThan(amount) ? max : amount,
        new Decimal(1e-9)
      );
      const decimals = this.activeMarketStore.activeMarket.decimals;
      return trades.map(({ amount, date, price, takerSide, id }) => {
        return {
          time: format(date, constants$4.TRADEVIEW_TIME),
          timeDetail: format(date, constants$4.TRADEVIEW_DATETIME),
          amount: this.fixedLength(amount, decimals.base, true),
          price: numberFormatter.formatZeroPaddedWithoutRounding({
            value: price,
            minimumDecimals: decimals.counter
          }),
          id,
          takerSide,
          relativeSize: Math.max(amount.div(maxAmount2).toSignificantDigits(2).mul(100).toNumber(), 10)
        };
      });
    },
    /**
     * Set number to fixed decimal length. If using color `span` class is added for extra appended zeros.
     * @param value - Decimal
     * @param decimals
     * @param color
     * @returns {string}
     */
    fixedLength(value, decimals, color = false) {
      const significantDecimals = value.decimalPlaces();
      if (decimals - significantDecimals < 0) {
        return value.toFixed(decimals);
      }
      let number = value.toFixed(significantDecimals);
      number = significantDecimals < 1 && decimals > 0 ? `${number}.` : number;
      const padding = "0".repeat(decimals - significantDecimals);
      if (color) {
        return `${number}<span class="filter-fixed-length">${padding}</span>`;
      }
      return `${number}${padding}`;
    }
  }
};
const _hoisted_1$B = {
  class: "tradebook-data",
  "data-test": "tradebookBody"
};
const _hoisted_2$p = { class: "tradebook-row__amount-indicator" };
const _hoisted_3$m = ["title"];
const _hoisted_4$k = ["innerHTML"];
const _hoisted_5$h = { class: "tradebook-row__time" };
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppScrollbar = resolveComponent("AppScrollbar");
  return openBlock(), createElementBlock("div", _hoisted_1$B, [
    _cache[4] || (_cache[4] = createBaseVNode("div", { class: "tradebook-header" }, [
      createBaseVNode("span", { class: "tradebook-header__price" }, "Price"),
      createTextVNode(),
      createBaseVNode("span", { class: "tradebook-header__amount" }, "Amount"),
      createTextVNode(),
      createBaseVNode("span", { class: "tradebook-header__time" }, "Time")
    ], -1)),
    _cache[5] || (_cache[5] = createTextVNode()),
    createVNode(_component_AppScrollbar, {
      ref: "perfectScrollbar",
      class: "tradebook-body"
    }, {
      default: withCtx(() => [
        createVNode(TransitionGroup, {
          name: `${$data.isAnimationDisabled ? "" : "list"}`,
          duration: $data.constants.TIMERS.TRADEBOOK.ANIMATION,
          tag: "div"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.liveTrades, (trade) => {
              return openBlock(), createElementBlock("div", {
                key: trade.id,
                class: normalizeClass([{
                  "tradebook-row--buy": trade.takerSide === $data.ordersConstants.ORDER_SIDE.BUY,
                  "tradebook-row--sell": trade.takerSide === $data.ordersConstants.ORDER_SIDE.SELL
                }, "tradebook-row"]),
                "data-test": "tradebookRow"
              }, [
                createBaseVNode("div", _hoisted_2$p, [
                  createBaseVNode("div", {
                    style: normalizeStyle({ width: trade.relativeSize + "%" }),
                    class: "tradebook-row__indicator-size"
                  }, null, 4)
                ]),
                _cache[0] || (_cache[0] = createTextVNode()),
                createBaseVNode("div", {
                  title: trade.timeDetail,
                  class: "overlay"
                }, null, 8, _hoisted_3$m),
                _cache[1] || (_cache[1] = createTextVNode()),
                createBaseVNode("span", {
                  class: normalizeClass([{
                    "tradebook-row__price--buy": trade.takerSide === $data.ordersConstants.ORDER_SIDE.BUY,
                    "tradebook-row__price--sell": trade.takerSide === $data.ordersConstants.ORDER_SIDE.SELL
                  }, "tradebook-row__price"]),
                  "data-test": "tradebookPrice"
                }, toDisplayString(trade.price), 3),
                _cache[2] || (_cache[2] = createTextVNode()),
                createBaseVNode("span", {
                  class: "tradebook-row__amount",
                  "data-test": "tradebookAmount",
                  innerHTML: trade.amount
                }, null, 8, _hoisted_4$k),
                _cache[3] || (_cache[3] = createTextVNode()),
                createBaseVNode("span", _hoisted_5$h, toDisplayString(trade.time), 1)
              ], 2);
            }), 128))
          ]),
          _: 1
        }, 8, ["name", "duration"])
      ]),
      _: 1
    }, 512)
  ]);
}
const TradeBookData = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$u], ["__scopeId", "data-v-02ac1936"]]);
const _hoisted_1$A = {
  xmlns: "http://www.w3.org/2000/svg",
  "xml:space": "preserve",
  viewBox: "0 0 16 13"
};
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$A, _cache[0] || (_cache[0] = [
    createStaticVNode('<g fill="currentColor"><path d="M8.5 13c-.1 0-.2 0-.3-.1L2.3 9H.5C.2 9 0 8.8 0 8.5v-4c0-.3.2-.5.5-.5h1.8L8.2.1c.2-.1.4-.1.5 0 .2 0 .3.2.3.4v12c0 .2-.1.4-.3.4 0 .1-.1.1-.2.1M1 8h1.5c.1 0 .2 0 .3.1L8 11.6V1.4L2.8 4.9c-.1.1-.2.1-.3.1H1z"></path><g class="sound-icon_svg__sound-wave" data-test="soundWave"><path d="M12.3 9.8c-.1 0-.3 0-.4-.1-.2-.2-.2-.5 0-.7.7-.7 1-1.5 1-2.5 0-.9-.4-1.8-1-2.5-.2-.2-.2-.5 0-.7s.5-.2.7 0c.8.8 1.3 2 1.3 3.2s-.5 2.3-1.3 3.2c0 .1-.1.1-.3.1"></path><path d="M10.9 8.4c-.1 0-.3 0-.4-.1-.2-.2-.2-.5 0-.7.6-.6.6-1.5 0-2.1-.2-.2-.2-.5 0-.7s.5-.2.7 0c1 1 1 2.6 0 3.5 0 .1-.2.1-.3.1m2.8 2.8c-.1 0-.3 0-.4-.1-.2-.2-.2-.5 0-.7 1-1 1.6-2.4 1.6-3.9s-.6-2.9-1.6-3.9c-.2-.2-.2-.5 0-.7s.5-.2.7 0c1.3 1.2 2 2.9 2 4.6s-.7 3.4-1.9 4.6c-.1.1-.2.1-.4.1"></path></g><path d="M2.5 9c-.3 0-.5-.2-.5-.5v-4c0-.3.2-.5.5-.5s.5.2.5.5v4c0 .3-.2.5-.5.5"></path></g>', 1)
  ]));
}
const SoundSVG = { render: render$4 };
const _sfc_main$B = {
  name: "TradeBook",
  components: {
    WidgetLayout,
    TradeBookData,
    SoundSVG
  },
  setup() {
    return {
      tradeviewSoundsStore: useTradeviewSoundsStore()
    };
  }
};
const _hoisted_1$z = { class: "trade-book__data" };
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SoundSVG = resolveComponent("SoundSVG");
  const _component_TradeBookData = resolveComponent("TradeBookData");
  const _component_WidgetLayout = resolveComponent("WidgetLayout");
  return openBlock(), createBlock(_component_WidgetLayout, {
    "is-header-underlined": true,
    class: "trade-book"
  }, {
    title: withCtx(() => _cache[1] || (_cache[1] = [
      createTextVNode("\n      Trades\n    ")
    ])),
    icon: withCtx(() => [
      createBaseVNode("span", {
        class: "icon-wrapper",
        title: "Toggle sound",
        "data-test": "toggleSound",
        onClick: _cache[0] || (_cache[0] = (...args) => $setup.tradeviewSoundsStore.toggleIsPublicTradeSoundEnabled && $setup.tradeviewSoundsStore.toggleIsPublicTradeSoundEnabled(...args))
      }, [
        createVNode(_component_SoundSVG, {
          class: normalizeClass(["icon-wrapper__icon", { "sound--disabled": !$setup.tradeviewSoundsStore.isPublicTradeSoundEnabled }])
        }, null, 8, ["class"])
      ])
    ]),
    default: withCtx(() => [
      _cache[2] || (_cache[2] = createTextVNode()),
      _cache[3] || (_cache[3] = createTextVNode()),
      createBaseVNode("div", _hoisted_1$z, [
        createVNode(_component_TradeBookData)
      ])
    ]),
    _: 1
  });
}
const TradeBook = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$t], ["__scopeId", "data-v-486ccfa6"]]);
function normalizeTimezoneForTradingView(timezone) {
  const map = /* @__PURE__ */ new Map();
  map.set("Europe/Ljubljana", "Europe/Rome");
  if (map.has(timezone)) {
    return map.get(timezone);
  }
  return timezone;
}
const toBarTime = (resolution, date) => {
  date.setUTCSeconds(0);
  date.setUTCMilliseconds(0);
  const timeFrame = isNaN(resolution) ? null : parseInt(resolution, 10) * 60;
  if (timeFrame && timeFrame < 3600) {
    const minutesInterval = timeFrame / 60;
    const minutes = date.getUTCMinutes();
    date = subMinutes(date, minutes % minutesInterval);
  } else if (timeFrame && timeFrame / 3600 < 24) {
    const hoursInterval = timeFrame / 3600;
    const hours = date.getUTCHours();
    date.setUTCMinutes(0);
    date = subHours(date, hours % hoursInterval);
  } else if (resolution[1] === "D") {
    const daysInterval = intervalToSeconds(resolution) / (24 * 3600);
    const firstDate = /* @__PURE__ */ new Date("2011-08-18T00:00:00");
    const daysDifference = differenceInDays(date, firstDate);
    date.setUTCMinutes(0);
    date.setUTCHours(0);
    date = subDays(date, daysDifference % daysInterval);
  } else if (resolution[1] === "W") {
    date = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() - (date.getUTCDay() - 1)));
  } else if (resolution[1] === "M") {
    date = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth()));
  }
  return date;
};
const toLiveBarTime = (resolution) => toBarTime(resolution, /* @__PURE__ */ new Date());
const getExpectedLastPriceHistoryBarTime = (resolution) => {
  const liveBarDate = toLiveBarTime(resolution);
  const resolutionAsNumber = isNaN(resolution) ? null : parseInt(resolution, 10);
  if (resolutionAsNumber) {
    return subMinutes(liveBarDate, resolutionAsNumber).getTime();
  } else if (resolution[1] === "H") {
    return subHours(liveBarDate, parseInt(resolution[0])).getTime();
  } else if (resolution[1] === "D") {
    return subDays(liveBarDate, parseInt(resolution[0])).getTime();
  } else if (resolution[1] === "W") {
    return subWeeks(liveBarDate, parseInt(resolution[0])).getTime();
  } else if (resolution[1] === "M") {
    return subMonths(liveBarDate, parseInt(resolution[0])).getTime();
  }
  return liveBarDate;
};
function intervalToSeconds(interval, date = /* @__PURE__ */ new Date()) {
  if (interval === "D") {
    interval = "3D";
  }
  if (interval[1] === "D") {
    interval = parseInt(interval[0]) * 24 * 60 * 60;
  } else if (interval[1] === "W") {
    interval = 24 * 60 * 60 * 7;
  } else if (interval[1] === "M") {
    interval = 24 * 60 * 60 * getDaysInCurrentMonth(date);
  } else {
    interval = parseInt(interval) * 60;
  }
  return interval;
}
function getDaysInCurrentMonth(date) {
  return getDaysInMonth(date);
}
function tradesToCandle(cachedLiveCandle, trades, resolution) {
  let candle = new LiveCandle({
    time: cachedLiveCandle.time,
    open: cachedLiveCandle.open ? cachedLiveCandle.open : _.last(trades).price,
    high: cachedLiveCandle.high ? cachedLiveCandle.high : trades[0].price,
    low: cachedLiveCandle.low ? cachedLiveCandle.low : trades[0].price,
    close: trades[0].price,
    volume: cachedLiveCandle.volume,
    lastTradeId: trades[0].id,
    pair: cachedLiveCandle.pair,
    resolution
  });
  candle = trades.reduce(
    (acc, currentVal) => ({
      ...acc,
      high: acc.high.greaterThan(currentVal.price) ? acc.high : currentVal.price,
      low: acc.low.lessThan(currentVal.price) ? acc.low : currentVal.price,
      volume: acc.volume.add(currentVal.amount)
    }),
    candle
  );
  return candle;
}
class LiveCandle {
  constructor({
    open = null,
    high = null,
    low = null,
    close = null,
    volume = new Decimal(0),
    time,
    lastTradeId = null,
    pair = null,
    resolution = null
  }) {
    this.open = open;
    this.high = high;
    this.low = low;
    this.close = close;
    this.volume = volume;
    this.time = time;
    this.lastTradeId = lastTradeId;
    this.pair = pair;
    this.resolution = resolution;
  }
}
const priceChartUtils = {
  intervalToSeconds,
  getExpectedLastPriceHistoryBarTime,
  tradesToCandle,
  normalizeTimezoneForTradingView,
  toLiveBarTime,
  toBarTime,
  LiveCandle,
  getDaysInCurrentMonth
};
function parseTradingViewUserChart(data) {
  return data;
}
function parseTradingViewUserCharts(data) {
  return data.map((d) => parseTradingViewUserChart(d));
}
const tradingViewUserChartsApi = {
  list() {
    return axiosInstance.get(URLService.buildUrl("tradingViewUserChartListResource", { "user_id": "own" })).then((response) => parseTradingViewUserCharts(response.data.data));
  },
  create(data) {
    return axiosInstance.post(URLService.buildUrl("tradingViewUserChartListResource", { "user_id": "own" }), {
      name: data.name,
      resolution: data.resolution,
      symbol: data.symbol,
      content: data.content,
      darkMode: data.darkMode
    }).then((response) => parseTradingViewUserChart(response.data.data));
  },
  update(data) {
    return axiosInstance.patch(URLService.buildUrl("tradingViewUserChartResource", { "user_id": "own", "chart_id": data.id }), {
      name: data.name,
      resolution: data.resolution,
      symbol: data.symbol,
      content: data.content,
      darkMode: data.darkMode
    }).then((response) => parseTradingViewUserChart(response.data.data));
  },
  delete(id) {
    return axiosInstance.delete(URLService.buildUrl("tradingViewUserChartResource", { "user_id": "own", "chart_id": id }));
  }
};
const storeName$4 = "tradeviewUserChartsStore";
const useTradeviewUserChartsStore = addStoreHooks(
  defineStore(storeName$4, () => {
    const userStateStore = useUserStateStore({ caller: storeName$4 });
    const $errorTracking = useErrorTracking();
    const themeStore = useThemeStore({ caller: storeName$4 });
    const charts = shallowRef([]);
    const isProcessing = ref(false);
    const areTradingviewUserTemplatesEnabled = computed(
      () => userStateStore.isLoggedIn && (PAGE_CONTEXT.tradingviewUserTemplatesEnabled ?? false)
    );
    const latestChart = computed(() => {
      if (charts.value.length === 0) {
        return null;
      }
      let chart = charts.value[0];
      charts.value.forEach((c) => {
        if (chart.timestamp < c.timestamp) {
          chart = c;
        }
      });
      return chart;
    });
    async function fetchTradingViewUserCharts() {
      if (!areTradingviewUserTemplatesEnabled.value) {
        return Promise.resolve([]);
      }
      if (isProcessing.value) {
        return await new Promise((resolve) => {
          const unwatch = watch(isProcessing, (newValue) => {
            if (!newValue) {
              resolve(charts.value);
              unwatch();
            }
          });
        });
      }
      isProcessing.value = true;
      try {
        charts.value = await tradingViewUserChartsApi.list();
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
      isProcessing.value = false;
      return charts.value;
    }
    async function createTradingViewUserChart(data) {
      try {
        const response = await tradingViewUserChartsApi.create({
          ...data,
          darkMode: themeStore.isDarkThemeActive
        });
        charts.value = charts.value.filter((chart) => chart.id !== response.id).concat([response]);
        return response;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    async function updateTradingViewUserChart(data) {
      try {
        const response = await tradingViewUserChartsApi.update({
          ...data,
          darkMode: themeStore.isDarkThemeActive
        });
        charts.value = charts.value.filter((chart) => chart.id !== response.id).concat([response]);
        return response;
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    async function deleteTradingViewUserChart(id) {
      try {
        await tradingViewUserChartsApi.delete(id);
        charts.value = charts.value.filter((chart) => chart.id !== id);
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    return {
      areTradingviewUserTemplatesEnabled,
      charts,
      latestChart,
      fetchTradingViewUserCharts,
      createTradingViewUserChart,
      updateTradingViewUserChart,
      deleteTradingViewUserChart
    };
  })
);
class TradingviewOptions {
  /**
   *
   * @param getTheme
   * @param assetRoot
   * @param customCssUrl - an absolute URL path to TradingView override CSS, will be linked to from iframe
   */
  constructor(getTheme, assetRoot, customCssUrl = "") {
    // store = {};
    __publicField(this, "options", {});
    __publicField(this, "tradeviewUserChartsStoreInit", false);
    this._initOptions(getTheme, assetRoot, customCssUrl);
  }
  _initOptions(getTheme, assetRoot, customCssUrl) {
    const tradeviewUserChartsStore = useTradeviewUserChartsStore();
    const themeStore = useThemeStore();
    this.getOverrides = () => {
      const theme3 = getTheme();
      const BACKGROUND_COLOR2 = theme3.COLORS.BACKGROUND;
      const GRID_COLOR = theme3.COLORS.GRID;
      const SCALE_LINE_COLOR = theme3.COLORS.SCALE_LINE;
      const SCALE_TEXT_COLOR = theme3.COLORS.SCALE_TEXT;
      const TREND_UP_COLOR2 = theme3.COLORS.TREND_UP;
      const TREND_DOWN_COLOR2 = theme3.COLORS.TREND_DOWN;
      const TRADINGVIEW_LINE_COLOR2 = theme3.COLORS.TRADINGVIEW_LINE;
      return {
        "paneProperties.background": BACKGROUND_COLOR2,
        "paneProperties.backgroundType": "solid",
        "paneProperties.vertGridProperties.color": GRID_COLOR,
        "paneProperties.horzGridProperties.color": GRID_COLOR,
        "symbolWatermarkProperties.color": BACKGROUND_COLOR2,
        // Scales
        "scalesProperties.textColor": SCALE_TEXT_COLOR,
        "scalesProperties.lineColor": SCALE_LINE_COLOR,
        "scalesProperties.backgroundColor": BACKGROUND_COLOR2,
        // Candles styles
        "mainSeriesProperties.candleStyle.wickUpColor": TREND_UP_COLOR2,
        "mainSeriesProperties.candleStyle.wickDownColor": TREND_DOWN_COLOR2,
        "mainSeriesProperties.candleStyle.upColor": TREND_UP_COLOR2,
        "mainSeriesProperties.candleStyle.downColor": TREND_DOWN_COLOR2,
        "mainSeriesProperties.candleStyle.drawBorder": false,
        "mainSeriesProperties.candleStyle.borderColor": TREND_UP_COLOR2,
        "mainSeriesProperties.candleStyle.borderUpColor": TREND_UP_COLOR2,
        "mainSeriesProperties.candleStyle.borderDownColor": TREND_DOWN_COLOR2,
        // Hollow Candles styles
        "mainSeriesProperties.hollowCandleStyle.upColor": TREND_UP_COLOR2,
        "mainSeriesProperties.hollowCandleStyle.downColor": TREND_DOWN_COLOR2,
        // Heikin Ashi styles
        "mainSeriesProperties.haStyle.upColor": TREND_UP_COLOR2,
        "mainSeriesProperties.haStyle.downColor": TREND_DOWN_COLOR2,
        // Bar styles
        "mainSeriesProperties.barStyle.upColor": TREND_UP_COLOR2,
        "mainSeriesProperties.barStyle.downColor": TREND_DOWN_COLOR2,
        // Line styles
        "mainSeriesProperties.lineStyle.color": TRADINGVIEW_LINE_COLOR2,
        // Area styles
        "mainSeriesProperties.areaStyle.color1": TRADINGVIEW_LINE_COLOR2,
        "mainSeriesProperties.areaStyle.color2": BACKGROUND_COLOR2,
        "mainSeriesProperties.areaStyle.linecolor": TRADINGVIEW_LINE_COLOR2,
        // Baseline styles
        "mainSeriesProperties.baselineStyle.baselineColor": SCALE_LINE_COLOR,
        "mainSeriesProperties.baselineStyle.topLineColor": TREND_UP_COLOR2,
        "mainSeriesProperties.baselineStyle.bottomLineColor": TREND_DOWN_COLOR2,
        // Volume
        volumePaneSize: "medium"
      };
    };
    const theme2 = getTheme();
    const BACKGROUND_COLOR = theme2.COLORS.BACKGROUND;
    const TREND_UP_COLOR = theme2.COLORS.TREND_UP;
    const TREND_DOWN_COLOR = theme2.COLORS.TREND_DOWN;
    const TRADINGVIEW_LINE_COLOR = theme2.COLORS.TRADINGVIEW_LINE;
    this.options = {
      // Tradingview library assumed to fall back to UTC if user's timezone unsupported
      timezone: priceChartUtils.normalizeTimezoneForTradingView(Intl.DateTimeFormat().resolvedOptions().timeZone),
      interval: "1D",
      locale: "en",
      autosize: true,
      fullscreen: false,
      "client_id": "bitstamp.net",
      theme: theme2.ID,
      container: "tradingview_container",
      "library_path": `${assetRoot}s/charting_library/`,
      "time_frames": [
        { text: "1d", resolution: "15", description: "1 Day", title: "1D" },
        { text: "7d", resolution: "120", description: "7 Days", title: "7D" },
        { text: "1m", resolution: "360", description: "1 Month", title: "1M" },
        { text: "3m", resolution: "1D", description: "3 Months", title: "3M" },
        { text: "1y", resolution: "3D", description: "1 Year", title: "1Y" },
        { text: "1000y", resolution: "1M", description: "All", title: "All" }
      ],
      "disabled_features": [
        "border_around_the_chart",
        "header_symbol_search",
        "header_compare",
        "compare_symbol",
        "symbol_search_hot_key",
        "header_fullscreen_button",
        "header_screenshot",
        "header_settings",
        "symbol_search_hot_key",
        "display_market_status"
      ],
      "enabled_features": [
        "chart_crosshair_menu",
        // show plus button on price scale by default
        "show_symbol_logos",
        "show_symbol_logos_in_legend",
        "hide_last_na_study_output",
        "side_toolbar_in_fullscreen_mode",
        "create_volume_indicator_by_default"
      ],
      disableMenuItems: ["Change Interval...", "Compare or Add Symbol...", "Change Symbol..."],
      overrides: this.getOverrides(),
      "studies_overrides": {
        "volume.volume.color.0": TREND_DOWN_COLOR,
        "volume.volume.color.1": TREND_UP_COLOR,
        "volume.volume.transparency": 70,
        "volume.styles.vol_ma.color": TRADINGVIEW_LINE_COLOR
      },
      "studies_access": {
        type: "black",
        tools: [
          {
            name: "52 Week High/Low"
          }
        ]
      },
      "loading_screen": {
        backgroundColor: BACKGROUND_COLOR,
        foregroundColor: TREND_UP_COLOR
      },
      "custom_css_url": customCssUrl
      // debug: true,
    };
    if (tradeviewUserChartsStore.areTradingviewUserTemplatesEnabled) {
      const getOverrides = this.getOverrides;
      this.options["load_last_chart"] = true;
      this.options["save_load_adapter"] = {
        getAllCharts() {
          if (!this.tradeviewUserChartsStoreInit) {
            return Promise.resolve(tradeviewUserChartsStore.charts);
          }
          this.tradeviewUserChartsStoreInit = true;
          return tradeviewUserChartsStore.fetchTradingViewUserCharts();
        },
        async removeChart(id) {
          await tradeviewUserChartsStore.deleteTradingViewUserChart(id);
        },
        async saveChart(chartData) {
          let data;
          if (chartData.id) {
            data = await tradeviewUserChartsStore.updateTradingViewUserChart(chartData);
          } else {
            data = await tradeviewUserChartsStore.createTradingViewUserChart(chartData);
          }
          return Promise.resolve(data.id);
        },
        getChartContent(id) {
          for (let i = 0; i < tradeviewUserChartsStore.charts.length; i++) {
            if (tradeviewUserChartsStore.charts[i].id === id) {
              if (tradeviewUserChartsStore.charts[i].darkMode !== themeStore.isDarkThemeActive) {
                const chart = this.applyOverrides(tradeviewUserChartsStore.charts[i]);
                tradeviewUserChartsStore.updateTradingViewUserChart(chart);
                return Promise.resolve(chart.content);
              }
              return Promise.resolve(tradeviewUserChartsStore.charts[i].content);
            }
          }
          return Promise.reject();
        },
        applyOverrides(chart) {
          try {
            const newChart = _.cloneDeep(chart);
            const chartContent = JSON.parse(newChart.content);
            const chartInnerContent = JSON.parse(chartContent.content);
            chartInnerContent.charts.forEach((chart2, i) => {
              for (const [key, value] of Object.entries(getOverrides())) {
                _.set(chartInnerContent.charts[i].chartProperties, key, value);
              }
            });
            chartContent.content = JSON.stringify(chartInnerContent);
            newChart.content = JSON.stringify(chartContent);
            return newChart;
          } catch (e) {
            trackException(e);
            return chart;
          }
        }
      };
    }
  }
}
const _sfc_main$A = {
  name: "TradingviewLoader"
};
const _hoisted_1$y = { class: "tradingview-loader" };
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$y, _cache[0] || (_cache[0] = [
    createStaticVNode('<div class="tradingview-loader__img" data-v-017f1c79><svg viewBox="0 0 143.55 139.52" class="pictogram" data-v-017f1c79><path d="M83.8,77.59a9.94,9.94,0,0,1-7.06,2.5h-14V62.28h14a10,10,0,0,1,7.06,2.46,8.27,8.27,0,0,1,2.68,6.4,8.42,8.42,0,0,1-2.68,6.45M62.71,38.17H75.6a9.35,9.35,0,0,1,6.49,2.28,7.62,7.62,0,0,1,2.55,6,7.48,7.48,0,0,1-2.55,5.92,9.47,9.47,0,0,1-6.49,2.24H62.71ZM95.2,63.38a15.25,15.25,0,0,0-7.49-5.48A14.2,14.2,0,0,0,93.63,53a13.27,13.27,0,0,0,2.23-7.72A14.59,14.59,0,0,0,94.5,39a14.1,14.1,0,0,0-3.86-5,18.3,18.3,0,0,0-5.92-3.2,23.72,23.72,0,0,0-7.54-1.14H45.58v7.8h0a8.72,8.72,0,1,1,0,17.43V62h0a8.71,8.71,0,0,1,8.72,8.71v1.41a8.71,8.71,0,0,1-8.72,8.71h0v7.8h33a24.42,24.42,0,0,0,7.76-1.18,19,19,0,0,0,6.14-3.33A15.09,15.09,0,0,0,98,72.28a14.72,14.72,0,0,0-2.77-8.9" data-v-017f1c79></path> <rect class="cls-1" x="45.58" y="101.35" width="52.38" height="8.5" data-v-017f1c79></rect></svg> <div class="tradingview-loader__progress" data-v-017f1c79></div></div>', 1)
  ]));
}
const TradingviewLoader = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$s], ["__scopeId", "data-v-017f1c79"]]);
class PriceChartService {
  static saveChartLayout(data) {
    LocalStorageService.writeObject(constants.LOCAL_STORAGE.PRICE_CHART, data);
  }
  /**
   * Load tradingview chart layout from local storage and replace currency pair
   * @param pairOverride {string}; example: `BTC/USD`
   * @returns {Object}
   */
  static loadChartLayout(pairOverride) {
    const chartLayout = LocalStorageService.readObject(constants.LOCAL_STORAGE.PRICE_CHART, null);
    try {
      const state = chartLayout.charts[0].panes[0].sources[0].state;
      state.symbol = pairOverride;
      state.shortName = pairOverride;
    } catch (e) {
      return null;
    }
    return chartLayout;
  }
}
const SUPPORTED_RESOLUTIONS = ["1", "3", "5", "15", "30", "60", "120", "240", "360", "720", "1D", "3D", "1W", "1M"];
function getCurrencyLogoUrl(currencyCode) {
  var _a2;
  return (_a2 = CURRENCIES[currencyCode]) == null ? void 0 : _a2.logo_svg;
}
class Datafeed {
  constructor(getActiveMarketStore, getMarketsStore, getTradeviewTickersStore, setTimeframeAndResolution, reloadLiveCandle, getLastPriceHistoryBarTime, setLastPriceHistoryBarTime, getIsHiddenState) {
    /**
     * Convert internal tradeview market objects to TradingView symbols
     * @param markets
     * @returns {*}
     * @private
     */
    __publicField(this, "_marketsToSearchSymbols", (markets) => {
      return markets.map((market) => ({
        "base_name": market.key,
        symbol: market.name,
        "full_name": market.name,
        description: market.description,
        exchange: "Bitstamp",
        ticker: market.name,
        type: market.type,
        "logo_urls": [getCurrencyLogoUrl(market.base), getCurrencyLogoUrl(market.counter)]
      }));
    });
    __publicField(this, "changeLastBar", (ohlc, marketName, resolution) => {
      const key = this._toSubscriberUID(marketName, resolution);
      this._ensureSubscriptionInfoInitialized(key);
      this.subscriptionInfo[key].referenceCandle = ohlc;
      this.subscriptionInfo[key].onRealtimeCallback(ohlc);
    });
    // call this to change last bar
    // call this to clear cache before issuing a chart().resetData()
    __publicField(this, "resetCache", () => {
      for (const subscriberUID in this.resetCacheNeededCallbacks) {
        this.resetCacheNeededCallbacks[subscriberUID]();
      }
    });
    this.getActiveMarketStore = getActiveMarketStore;
    this.getMarketsStore = getMarketsStore;
    this.getTradeviewTickersStore = getTradeviewTickersStore;
    this.setTimeframeAndResolution = setTimeframeAndResolution;
    this.reloadLiveCandle = reloadLiveCandle;
    this.getLastPriceHistoryBarTime = getLastPriceHistoryBarTime;
    this.setLastPriceHistoryBarTime = setLastPriceHistoryBarTime;
    this.getIsHiddenState = getIsHiddenState;
    this.resetCacheNeededCallbacks = {};
    this.cacheForMarketSearch = [];
    this.subscriptionInfo = {};
    this.supportedResolutions = SUPPORTED_RESOLUTIONS;
  }
  _toSubscriberUID(marketName, resolution) {
    return `${marketName}_#_${resolution}`;
  }
  _ensureSubscriptionInfoInitialized(subscriberUID) {
    if (!this.subscriptionInfo[subscriberUID]) {
      this.subscriptionInfo[subscriberUID] = {
        priceHistoryHelper: null,
        realtimeCallbackInterval: null,
        referenceCandle: {},
        onRealtimeCallback: () => {
        }
      };
    }
  }
  onReady(callback) {
    const data = {
      "supports_search": true,
      "supports_group_request": false,
      "supports_marks": false,
      "supports_timescale_marks": false,
      "supported_resolutions": this.supportedResolutions
    };
    setTimeout(() => callback(data), 0);
  }
  searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {
    if (this.cacheForMarketSearch.length < 1) {
      this.cacheForMarketSearch = this._marketsToSearchSymbols(Object.values(this.getMarketsStore().visibleMarkets));
      this.cacheForMarketSearch = _.orderBy(this.cacheForMarketSearch, ["symbol"]);
    }
    const lowerCaseSearch = userInput.toLowerCase();
    onResultReadyCallback(
      this.cacheForMarketSearch.filter(
        (m) => m.base_name.includes(lowerCaseSearch) || m.symbol.toLowerCase().includes(lowerCaseSearch) || m.description.toLowerCase().includes(lowerCaseSearch)
      )
    );
  }
  resolveSymbol(symbolName, onSymbolResolvedCallback) {
    const exchange = "Bitstamp";
    symbolName = symbolName.replace(new RegExp(`${exchange}:`, "g"), "");
    const marketKey = symbolName.replace(/\//, "").toLowerCase();
    const market = this.getMarketsStore().getMarket(marketKey);
    const symbolInfo = {
      "base_name": market.key,
      name: market.name,
      ticker: market.name,
      description: market.name,
      type: market.type,
      "has_intraday": true,
      minmov: 1,
      exchange,
      "listed_exchange": exchange,
      // FROM WIKI: pricescale defines the number of decimal places. It is 10^number-of-decimal-places.
      // FROM WIKI: If a price is displayed as 1.01, pricescale is 100; If it is displayed as 1.005, pricescale is 1000.
      pricescale: 10 ** market.decimals.counter,
      session: "24x7",
      timezone: "Etc/UTC",
      "supported_resolutions": this.supportedResolutions,
      "has_weekly_and_monthly": true,
      "logo_urls": [getCurrencyLogoUrl(market.base)]
    };
    setTimeout(() => onSymbolResolvedCallback(symbolInfo));
  }
  async getBars(symbolInfo, interval, periodParams, onHistoryCallback, onErrorCallback) {
    var _a2, _b;
    let fromDate = periodParams.from;
    let toDate2 = periodParams.to;
    const step = priceChartUtils.intervalToSeconds(interval);
    fromDate = new Date(fromDate * 1e3);
    const subscriberUID = this._toSubscriberUID(symbolInfo.ticker, interval);
    this._ensureSubscriptionInfoInitialized(subscriberUID);
    try {
      let bars = [];
      let response = [];
      do {
        toDate2 = response.length > 0 ? new Date(_.first(response).time - step * 1e3) : new Date(toDate2 * 1e3);
        response = await candlesApi.getPriceHistoryData(
          symbolInfo.base_name,
          interval,
          fromDate,
          toDate2,
          ((_a2 = this.subscriptionInfo[subscriberUID]) == null ? void 0 : _a2.priceHistoryHelper) ?? this.getTradeviewTickersStore().activeMarketTickerLastValue.toNumber()
        );
        bars = [...response, ...bars];
        this.subscriptionInfo[subscriberUID].priceHistoryHelper = ((_b = bars == null ? void 0 : bars[0]) == null ? void 0 : _b.open) ?? null;
      } while (response.length === constants.PRICE_HISTORY_MAX_RESULTS);
      this.reloadLiveCandle();
      onHistoryCallback(bars, {
        noData: bars.length === 0
      });
      if (symbolInfo.base_name === this.getActiveMarketStore().activeMarket.key && bars.length > 0) {
        const lastPriceHistoryBarTime = this.getLastPriceHistoryBarTime();
        if (!lastPriceHistoryBarTime || _.last(bars).time >= lastPriceHistoryBarTime.time || step !== lastPriceHistoryBarTime.timeFrame) {
          this.setLastPriceHistoryBarTime(_.last(bars).time, step);
        }
      }
    } catch (error) {
      onErrorCallback("Price history error");
    }
  }
  subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) {
    if (symbolInfo.base_name === this.getActiveMarketStore().activeMarket.key) {
      this.setTimeframeAndResolution({
        timeFrame: priceChartUtils.intervalToSeconds(resolution),
        resolution
      });
      this._ensureSubscriptionInfoInitialized(subscriberUID);
      this.subscriptionInfo[subscriberUID].onRealtimeCallback = onRealtimeCallback;
      clearInterval(this.subscriptionInfo[subscriberUID].realtimeCallbackInterval);
      this.subscriptionInfo[subscriberUID].realtimeCallbackInterval = setInterval(() => {
        var _a2;
        if (this.getIsHiddenState()) {
          return;
        }
        const intervalSeconds = priceChartUtils.intervalToSeconds(resolution);
        const referenceCandleTime = fromUnixTime(this.subscriptionInfo[subscriberUID].referenceCandle.time / 1e3);
        const referenceCandleTimePlusOneInterval = addSeconds(referenceCandleTime, intervalSeconds);
        const currentTimeMinusTwoIntervals = subSeconds(/* @__PURE__ */ new Date(), 2 * intervalSeconds).getTime();
        if (currentTimeMinusTwoIntervals <= referenceCandleTimePlusOneInterval.getTime() && // Make sure reference candle is at least T-2 old
        referenceCandleTime.getTime() <= currentTimeMinusTwoIntervals) {
          const prevOhlcClose = (_a2 = this.subscriptionInfo[subscriberUID].referenceCandle) == null ? void 0 : _a2.close;
          this.subscriptionInfo[subscriberUID].referenceCandle = {
            isBarClosed: true,
            isLastBar: true,
            open: prevOhlcClose,
            high: prevOhlcClose,
            low: prevOhlcClose,
            close: prevOhlcClose,
            volume: 0,
            time: getUnixTime(referenceCandleTimePlusOneInterval) * 1e3
          };
          this.subscriptionInfo[subscriberUID].onRealtimeCallback(this.subscriptionInfo[subscriberUID].referenceCandle);
        }
      }, 1e3 * 10);
    }
    this.resetCacheNeededCallbacks[subscriberUID] = onResetCacheNeededCallback;
  }
  unsubscribeBars(subscriberUID) {
    this._ensureSubscriptionInfoInitialized(subscriberUID);
    this.subscriptionInfo[subscriberUID].priceHistoryHelper = null;
    clearInterval(this.subscriptionInfo[subscriberUID].realtimeCallbackInterval);
    this.subscriptionInfo[subscriberUID].realtimeCallbackInterval = null;
    delete this.resetCacheNeededCallbacks[subscriberUID];
  }
  // resolution, resolutionBack, intervalBack
  calculateHistoryDepth() {
  }
  // symbolInfo, from, to, onDataCallback, resolution
  getMarks() {
  }
  // symbolInfo, from, to, onDataCallback, resolution
  getTimescaleMarks() {
  }
  getServerTime(callback) {
    setTimeout(() => callback((/* @__PURE__ */ new Date()).getTime() / 1e3), 0);
  }
}
function ve(e, t) {
  const i = { ...e };
  for (const o in t) "object" != typeof e[o] || null === e[o] || Array.isArray(e[o]) ? void 0 !== t[o] && (i[o] = t[o]) : i[o] = ve(e[o], t[o]);
  return i;
}
const Ie$1 = {
  width: 800,
  height: 500,
  interval: "1D",
  timezone: "Etc/UTC",
  container: "",
  library_path: "",
  locale: "en",
  widgetbar: { details: false, watchlist: false, news: false, datawindow: false, watchlist_settings: { default_symbols: [] } },
  overrides: { "mainSeriesProperties.showCountdown": false },
  studies_overrides: {},
  trading_customization: { position: {}, order: {} },
  brokerConfig: { configFlags: {} },
  fullscreen: false,
  autosize: false,
  disabled_features: [],
  enabled_features: [],
  debug: false,
  logo: {},
  time_frames: [{ text: "5y", resolution: "1W" }, { text: "1y", resolution: "1W" }, {
    text: "6m",
    resolution: "120"
  }, { text: "3m", resolution: "60" }, { text: "1m", resolution: "30" }, {
    text: "5d",
    resolution: "5"
  }, { text: "1d", resolution: "1" }],
  client_id: "0",
  user_id: "0",
  charts_storage_api_version: "1.0",
  favorites: { intervals: [], chartTypes: [], indicators: [], drawingTools: [] }
}, Oe$1 = JSON.parse('[{"iso":"ar","dir":"rtl","language":"ar"},{"iso":"pt","dir":"ltr","language":"pt"},{"iso":"ca","dir":"ltr","language":"ca_ES"},{"iso":"cs","dir":"ltr","language":"cs"},{"iso":"de","dir":"ltr","language":"de"},{"iso":"en","dir":"ltr","language":"en"},{"iso":"es","dir":"ltr","language":"es"},{"iso":"fa","dir":"rtl","language":"fa"},{"iso":"fr","dir":"ltr","language":"fr"},{"iso":"he","dir":"rtl","language":"he_IL"},{"iso":"hu","dir":"ltr","language":"hu_HU"},{"iso":"id","dir":"ltr","language":"id_ID"},{"iso":"en","dir":"ltr","language":"en"},{"iso":"it","dir":"ltr","language":"it"},{"iso":"ja","dir":"ltr","language":"ja"},{"iso":"ko","dir":"ltr","language":"ko"},{"iso":"ms","dir":"ltr","language":"ms_MY"},{"iso":"pl","dir":"ltr","language":"pl"},{"iso":"ru","dir":"ltr","language":"ru"},{"iso":"sv","dir":"ltr","language":"sv"},{"iso":"th","dir":"ltr","language":"th"},{"iso":"tr","dir":"ltr","language":"tr"},{"iso":"vi","dir":"ltr","language":"vi"},{"iso":"zh-Hans","dir":"ltr","language":"zh"},{"iso":"zh-Hant","dir":"ltr","language":"zh_TW"},{"iso":"el","dir":"ltr","language":"el"},{"iso":"nl","dir":"ltr","language":"nl_NL"},{"iso":"ro","dir":"ltr","language":"ro"}]');
let Re = false;
function version() {
  return "CL v28.5.0 (internal id fb6f897f @ 2024-12-18T12:27:11.562Z)";
}
const widget = class {
  constructor(e) {
    var t, i;
    if (this._id = `tradingview_${(1048576 * (1 + Math.random()) | 0).toString(16).substring(1)}`, this._ready = false, this._readyHandlers = [], this._onWindowResize = this._autoResizeChart.bind(this), !e.datafeed) throw new Error("Datafeed is not defined");
    (null === (t = e.overrides) || void 0 === t ? void 0 : t["mainSeriesProperties.priceAxisProperties.lockScale"]) && (console.warn("mainSeriesProperties.priceAxisProperties.lockScale can not be set to true within the widget constructor"), delete e.overrides["mainSeriesProperties.priceAxisProperties.lockScale"]), this._options = ve(Ie$1, e);
    "dark" === (null !== (i = this._options.theme) && void 0 !== i ? i : "light").toLowerCase() && void 0 === this._options.loading_screen && (this._options.loading_screen = { backgroundColor: "#131722" }), (this._options.debug || this._options.debug_broker) && (Re || (Re = true, console.log("Using CL v28.5.0 (internal id fb6f897f @ 2024-12-18T12:27:11.562Z)"))), this._innerWindowLoaded = new Promise((e2) => {
      this._innerWindowResolver = e2;
    }), this._create();
  }
  setDebugMode(e) {
    this._innerAPI().setDebugMode(e);
  }
  onChartReady(e) {
    this._ready ? e.call(this) : this._readyHandlers.push(e);
  }
  headerReady() {
    return this._innerWindowLoaded.then(() => this._innerWindow().headerReady());
  }
  onGrayedObjectClicked(e) {
    this._doWhenInnerApiLoaded((t) => {
      t.onGrayedObjectClicked(e);
    });
  }
  onShortcut(e, t) {
    this._doWhenInnerWindowLoaded((i) => {
      i.createShortcutAction(e, t);
    });
  }
  subscribe(e, t) {
    this._doWhenInnerApiLoaded((i) => {
      i.subscribe(e, t);
    });
  }
  unsubscribe(e, t) {
    this._doWhenInnerApiLoaded((i) => {
      i.unsubscribe(e, t);
    });
  }
  chart(e) {
    return this._innerAPI().chart(e);
  }
  getLanguage() {
    return this._options.locale;
  }
  setSymbol(e, t, i) {
    this._innerAPI().changeSymbol(e, t, i);
  }
  remove() {
    window.removeEventListener("resize", this._onWindowResize), this._readyHandlers.splice(0, this._readyHandlers.length), delete window[this._id], this._iFrame.parentNode && this._iFrame.parentNode.removeChild(this._iFrame);
  }
  closePopupsAndDialogs() {
    this._doWhenInnerApiLoaded((e) => {
      e.closePopupsAndDialogs();
    });
  }
  selectLineTool(e, t) {
    this._innerAPI().selectLineTool(e, t);
  }
  selectedLineTool() {
    return this._innerAPI().selectedLineTool();
  }
  save(e, t) {
    this._innerAPI().saveChart(e, t);
  }
  load(e, t) {
    this._innerAPI().loadChart({ json: e, extendedData: t });
  }
  getSavedCharts(e) {
    this._innerAPI().getSavedCharts(e);
  }
  loadChartFromServer(e) {
    this._innerAPI().loadChartFromServer(e);
  }
  saveChartToServer(e, t, i) {
    this._innerAPI().saveChartToServer(e, t, i);
  }
  removeChartFromServer(e, t) {
    this._innerAPI().removeChartFromServer(e, t);
  }
  onContextMenu(e) {
    this._doWhenInnerApiLoaded((t) => {
      t.onContextMenu(e);
    });
  }
  createButton(e) {
    return this._innerWindow().createButton(e);
  }
  createDropdown(e) {
    return this._innerWindow().createDropdown(e);
  }
  showNoticeDialog(e) {
    this._doWhenInnerApiLoaded((t) => {
      t.showNoticeDialog(e);
    });
  }
  showConfirmDialog(e) {
    this._doWhenInnerApiLoaded((t) => {
      t.showConfirmDialog(e);
    });
  }
  showLoadChartDialog() {
    this._innerAPI().showLoadChartDialog();
  }
  showSaveAsChartDialog() {
    this._innerAPI().showSaveAsChartDialog();
  }
  symbolInterval() {
    return this._innerAPI().getSymbolInterval();
  }
  mainSeriesPriceFormatter() {
    return this._innerAPI().mainSeriesPriceFormatter();
  }
  getIntervals() {
    return this._innerAPI().getIntervals();
  }
  getStudiesList() {
    return this._innerAPI().getStudiesList();
  }
  getStudyInputs(e) {
    return this._innerAPI().getStudyInputs(e);
  }
  getStudyStyles(e) {
    return this._innerAPI().getStudyStyles(e);
  }
  addCustomCSSFile(e) {
    this._innerWindow().addCustomCSSFile(e);
  }
  applyOverrides(e) {
    this._options = ve(this._options, { overrides: e }), this._doWhenInnerWindowLoaded((t) => {
      t.applyOverrides(e);
    });
  }
  applyStudiesOverrides(e) {
    this._doWhenInnerWindowLoaded((t) => {
      t.applyStudiesOverrides(e);
    });
  }
  watchList() {
    return this._innerAPI().watchlist();
  }
  news() {
    return this._innerAPI().news();
  }
  widgetbar() {
    return this._innerAPI().widgetbar();
  }
  activeChart() {
    return this._innerAPI().activeChart();
  }
  activeChartIndex() {
    return this._innerAPI().activeChartIndex();
  }
  setActiveChart(e) {
    return this._innerAPI().setActiveChart(e);
  }
  chartsCount() {
    return this._innerAPI().chartsCount();
  }
  layout() {
    return this._innerAPI().layout();
  }
  setLayout(e) {
    this._innerAPI().setLayout(e);
  }
  layoutName() {
    return this._innerAPI().layoutName();
  }
  resetLayoutSizes(e) {
    this._innerAPI().resetLayoutSizes(e);
  }
  changeTheme(e, t) {
    return this._innerWindow().changeTheme(e, t);
  }
  getTheme() {
    return this._innerWindow().getTheme();
  }
  takeScreenshot() {
    this._doWhenInnerApiLoaded((e) => {
      e.takeScreenshot();
    });
  }
  lockAllDrawingTools() {
    return this._innerAPI().lockAllDrawingTools();
  }
  hideAllDrawingTools() {
    return this._innerAPI().hideAllDrawingTools();
  }
  drawOnAllChartsEnabled() {
    return this._innerAPI().drawOnAllChartsEnabled();
  }
  drawOnAllCharts(e) {
    this._innerAPI().drawOnAllCharts(e);
  }
  magnetEnabled() {
    return this._innerAPI().magnetEnabled();
  }
  magnetMode() {
    return this._innerAPI().magnetMode();
  }
  undoRedoState() {
    return this._innerAPI().undoRedoState();
  }
  setIntervalLinkingEnabled(e) {
    this._innerAPI().setIntervalLinkingEnabled(e);
  }
  setDateRangeLinkingEnabled(e) {
    this._innerAPI().setDateRangeLinkingEnabled(e);
  }
  setTimeFrame(e) {
    this._innerAPI().setTimeFrame(e);
  }
  symbolSync() {
    return this._innerAPI().symbolSync();
  }
  intervalSync() {
    return this._innerAPI().intervalSync();
  }
  crosshairSync() {
    return this._innerAPI().crosshairSync();
  }
  timeSync() {
    return this._innerAPI().timeSync();
  }
  dateRangeSync() {
    return this._innerAPI().dateRangeSync();
  }
  setFeatureEnabled(e, t) {
    this._innerAPI().setFeatureEnabled(e, t);
  }
  getAllFeatures() {
    return this._innerWindow().getAllFeatures();
  }
  clearUndoHistory() {
    return this._innerAPI().clearUndoHistory();
  }
  undo() {
    return this._innerAPI().undo();
  }
  redo() {
    return this._innerAPI().redo();
  }
  startFullscreen() {
    this._innerAPI().startFullscreen();
  }
  exitFullscreen() {
    this._innerAPI().exitFullscreen();
  }
  takeClientScreenshot(e) {
    return this._innerAPI().takeClientScreenshot(e);
  }
  navigationButtonsVisibility() {
    return this._innerWindow().getNavigationButtonsVisibility();
  }
  paneButtonsVisibility() {
    return this._innerWindow().getPaneButtonsVisibility();
  }
  dateFormat() {
    return this._innerWindow().getDateFormat();
  }
  timeHoursFormat() {
    return this._innerWindow().getTimeHoursFormat();
  }
  currencyAndUnitVisibility() {
    return this._innerWindow().getCurrencyAndUnitVisibility();
  }
  supportedChartTypes() {
    return this._innerAPI().supportedChartTypes();
  }
  watermark() {
    return this._innerAPI().watermark();
  }
  customSymbolStatus() {
    return this._innerWindow().customSymbolStatus();
  }
  setCSSCustomProperty(e, t) {
    if (false === e.startsWith("--")) throw new Error("customPropertyName should begin with a double hyphen");
    this._innerWindow().document.body.style.setProperty(e, t);
  }
  getCSSCustomPropertyValue(e) {
    if (false === e.startsWith("--")) throw new Error("customPropertyName should begin with a double hyphen");
    const t = this._innerWindow().document.body, i = t.style.getPropertyValue(e);
    if (i) return i;
    return getComputedStyle(t).getPropertyValue(e);
  }
  unloadUnusedCharts() {
    this._innerAPI().unloadUnusedCharts();
  }
  async customThemes() {
    return this._innerWindow().customThemes();
  }
  linking() {
    return this._innerAPI().linking;
  }
  _innerAPI() {
    return this._innerWindow().tradingViewApi;
  }
  _innerWindow() {
    return this._iFrame.contentWindow;
  }
  _doWhenInnerWindowLoaded(e) {
    this._ready ? e(this._innerWindow()) : this._innerWindowLoaded.then(() => {
      e(this._innerWindow());
    });
  }
  _doWhenInnerApiLoaded(e) {
    this._doWhenInnerWindowLoaded((t) => {
      t.doWhenApiIsReady(() => e(this._innerAPI()));
    });
  }
  _autoResizeChart() {
    this._options.fullscreen && (this._iFrame.style.height = window.innerHeight + "px", ke && setTimeout(() => {
      this._iFrame.style.height = window.innerHeight + "px";
    }, 30));
  }
  async _create() {
    var e, t, i, o;
    const r = null !== (t = null === (e = this._options.enabled_features) || void 0 === e ? void 0 : e.includes("iframe_loading_same_origin")) && void 0 !== t && t, n = r || null !== (o = null === (i = this._options.enabled_features) || void 0 === i ? void 0 : i.includes("iframe_loading_compatibility_mode")) && void 0 !== o && o, [a, s] = this._render(!n, r), l = this._options.container, d = "string" == typeof l ? document.getElementById(l) : l;
    if (null === d) throw new Error(`There is no such element - #${this._options.container}`);
    d.innerHTML = a, this._iFrame = d.querySelector(`#${this._id}`);
    const c = this._iFrame;
    r && await this._innerWindowEvent("sameOriginLoad"), n && (c.contentWindow ? (c.contentWindow.document.open(), c.contentWindow.document.write(s), c.contentWindow.document.close()) : console.warn("Unable to locate contentWindow for the created iframe. Please try disabling the `iframe_loading_compatibility_mode` featureset.")), this._innerWindow().addEventListener("innerWindowLoad", function(e2, t2) {
      if (void 0 === e2) throw new Error(`${t2} is undefined`);
      return e2;
    }(this._innerWindowResolver, "_innerWindowResolver"), { once: true }), (this._options.autosize || this._options.fullscreen) && (c.style.width = "100%", this._options.fullscreen || (c.style.height = "100%")), window.addEventListener("resize", this._onWindowResize), this._onWindowResize(), this._innerWindowLoaded.then(() => {
      try {
        this._innerWindow().widgetReady(() => {
          this._ready = true;
          for (const e2 of this._readyHandlers) try {
            e2.call(this);
          } catch (e3) {
            console.error(e3);
          }
          this._innerWindow().initializationFinished();
        });
      } catch (e2) {
        if (e2 instanceof Error && /widgetReady is not a function/.test(e2.message)) throw new Error(`There was an error when loading the library. Usually this error means the library failed to load its static files. Check that the library files are available at ${window.location.host}/${this._options.library_path || ""} or correct the library_path option.`);
      }
    });
  }
  _innerWindowEvent(e) {
    return new Promise((t) => {
      this._innerWindow().addEventListener(e, t, { once: true });
    });
  }
  _render(e, t) {
    var i;
    const o = window;
    if (o[this._id] = {
      datafeed: this._options.datafeed,
      customFormatters: this._options.custom_formatters,
      brokerFactory: this._options.broker_factory,
      overrides: this._options.overrides,
      studiesOverrides: this._options.studies_overrides,
      tradingCustomization: this._options.trading_customization,
      disabledFeatures: this._options.disabled_features,
      enabledFeatures: this._options.enabled_features,
      brokerConfig: this._options.broker_config || this._options.brokerConfig,
      restConfig: this._options.restConfig,
      favorites: this._options.favorites,
      logo: this._options.logo,
      numeric_formatting: this._options.numeric_formatting,
      rss_news_feed: this._options.rss_news_feed,
      rss_news_title: this._options.rss_news_title,
      newsProvider: this._options.news_provider,
      loadLastChart: this._options.load_last_chart,
      saveLoadAdapter: this._options.save_load_adapter,
      loading_screen: this._options.loading_screen,
      settingsAdapter: this._options.settings_adapter,
      getCustomIndicators: this._options.custom_indicators_getter,
      additionalSymbolInfoFields: this._options.additional_symbol_info_fields,
      headerWidgetButtonsMode: this._options.header_widget_buttons_mode,
      customTranslateFunction: this._options.custom_translate_function,
      symbolSearchComplete: this._options.symbol_search_complete,
      contextMenu: this._options.context_menu,
      settingsOverrides: this._options.settings_overrides,
      timeframe: this._options.timeframe,
      customTimezones: this._options.custom_timezones,
      customChartDescriptionFunction: this._options.custom_chart_description_function,
      customThemes: this._options.custom_themes,
      imageStorageAdapter: this._options.image_storage_adapter
    }, this._options.saved_data) o[this._id].chartContent = { json: this._options.saved_data }, this._options.saved_data_meta_info && (o[this._id].chartContentExtendedData = this._options.saved_data_meta_info);
    else if (!this._options.load_last_chart && !this._options.symbol) throw new Error("Symbol is not defined: either 'symbol' or 'load_last_chart' option must be set");
    if (this._options.library_path && !this._options.library_path.endsWith("/") && console.warn("library_path option should contain a trailing forward slash"), this._options.locale) {
      const e2 = encodeURIComponent(this._options.locale);
      Oe$1.findIndex((t2) => t2.language === e2) >= 0 || (console.warn("locale isn't supported. Using default of `en`."), this._options.locale = "en");
    }
    const r = function(e2, t2) {
      var i2;
      const cspNonce = document.body.dataset.cspNonce;
      const o2 = new URL(`${e2 || ""}`, location.href).href, r2 = JSON.parse('["bundles/runtime.0c59f90a8699f12ff40f.js","bundles/__LANG__.2312.a9353e46c20c3019a091.js","bundles/9662.03109f673cda5962c847.css","bundles/7346.a2efeed47130dd4e832c.js","bundles/library.8fdacc60e5256d6fcc84.js"]'), n2 = encodeURIComponent(t2), a2 = null !== (i2 = Oe$1.find((e3) => e3.language === n2)) && void 0 !== i2 ? i2 : { iso: "en", dir: "ltr" }, s = `lang="${a2.iso}" dir="${a2.dir}"`, l = `
${function(e3, t3, i3) {
        if (void 0 === e3) return "";
        const o3 = [], r3 = [];
        for (const n3 of e3) n3.endsWith(".js") ? o3.push(`<script nonce="${cspNonce}" defer src="${n3.replace("__LANG__", i3)}"><\/script>`) : n3.endsWith(".css") && r3.push(`<link type="text/css" href="${t3 ? n3.replace(/\.css$/i, ".rtl.css") : n3}" rel="stylesheet"/>`);
        return [...o3, ...r3].join("\n");
      }(r2, "rtl" === a2.dir, n2)}
`;
      return `<!DOCTYPE html><html ${(d = {
        bundles: l,
        localeLanguage: n2,
        htmlAttrs: s,
        libraryPath: o2
      }).htmlAttrs}><head><base href="${d.libraryPath}"><meta charset="utf-8"><script nonce="${cspNonce}">window===window.parent&&(location.href="about:blank")<\/script> ${d.bundles} </head><body class="chart-page unselectable on-widget"><div class="loading-indicator" id="loading-indicator"></div><script nonce="${cspNonce}">var JSServer={},__initialEnabledFeaturesets=["charting_library"]<\/script><script nonce="${cspNonce}">(function() {
		window.urlParams = (function () {
			var match,
				pl	 = /\\+/g,  // Regex for replacing addition symbol with a space
				search = /([^&=]+)=?([^&]*)/g,
				decode = function (s) { return decodeURIComponent(s.replace(pl, ' ')).replace(/<\\/?[^>]+(>|$)/g, ''); },
				query = function() {
					// We don't use hash on the url because: safari 13 throws an error if you attempt this
					// on a blob, and safari 14 will strip hash from blob urls.
					if (frameElement && frameElement.dataset.widgetOptions) {
						return frameElement.dataset.widgetOptions;
					} else {
						throw "Unexpected use of this page";
					}
				}(),
				result = {};

			while (match = search.exec(query)) {
				result[decode(match[1])] = decode(match[2]);
			}

			var additionalSettingsObject = window.parent[result.uid];

			var customObjectNames = ['datafeed', 'customFormatters', 'brokerFactory', 'save_load_adapter', 'customTranslateFunction', 'contextMenu'];

			for (var p in additionalSettingsObject) {
				if (customObjectNames.indexOf(p) === -1) {
					result[p] = JSON.stringify(additionalSettingsObject[p]);
				}
			}

			return result;
		})();

		window.locale = urlParams.locale;
		window.language = urlParams.locale; // a very big attention needed here
		window.customTranslateFunction = window.parent[urlParams.uid].customTranslateFunction;
		window.customChartDescriptionFunction = window.parent[urlParams.uid].customChartDescriptionFunction;

		window.addCustomCSSFile = function(href) {
			var link = document.createElement('link');
			link.setAttribute('type', 'text/css');
			link.setAttribute('rel', 'stylesheet');
			link.setAttribute('href', href);

			window.loadedCustomCss = new Promise((resolve) => {
				link.onload = resolve;
				link.onerror = resolve;
			});
			document.body.appendChild(link);
		};

		window.loadedCustomCss = Promise.resolve();
		if (!!urlParams.customCSS) {
			window.addCustomCSSFile(urlParams.customCSS);
		}

		var loadingScreenParams = {};

		if (typeof urlParams.loading_screen === 'string') {
			try {
				loadingScreenParams = JSON.parse(urlParams.loading_screen);
			} catch(e) {}
		}

		var loadingIndicatorElement = document.getElementById('loading-indicator');

		if (loadingScreenParams.backgroundColor) {
			loadingIndicatorElement.style = 'background-color: ' + loadingScreenParams.backgroundColor;
		}

		!function(){"use strict";var t,e=new WeakMap;!function(t){t[t.Element=1]="Element",t[t.Document=9]="Document"}(t||(t={}));var n={mini:"xsmall",xxsmall:"xxsmall",xsmall:"xsmall",small:"small",medium:"medium",large:"large"};var s,i,o,r,l,c=(void 0===l&&(l=""),s='<div class="tv-spinner '.concat(l,'" role="progressbar"></div>'),o=function(n,s){var i,o;return i=null==s?document.documentElement:s.nodeType===t.Document?s.documentElement:s,e&&(o=e.get(i)),o||((o=i.ownerDocument.createRange()).selectNodeContents(i),e&&e.set(i,o)),o.createContextualFragment(n)}(s,i),null!==(r=o.firstElementChild)&&o.removeChild(r),r),a=function(){function t(t){this._shown=!1,this._el=c.cloneNode(!0),this.setSize(n[t||"large"])}return t.prototype.spin=function(t){return this._el.classList.add("tv-spinner--shown"),void 0===this._container&&(this._container=t,void 0!==t&&t.appendChild(this._el)),this._shown=!0,this},t.prototype.stop=function(t){return t&&void 0!==this._container&&this._container.removeChild(this._el),this._el&&this._el.classList.remove("tv-spinner--shown"),this._shown=!1,this},t.prototype.setStyle=function(t){var e=this;return Object.keys(t).forEach((function(n){var s=t[n];void 0!==s&&e._el.style.setProperty(n,s)})),this},t.prototype.style=function(){return this._el.style},t.prototype.setSize=function(t){var e=void 0!==t?"tv-spinner--size_".concat(t):"";return this._el.className="tv-spinner ".concat(e," ").concat(this._shown?"tv-spinner--shown":""),this},t.prototype.getEl=function(){return this._el},t.prototype.destroy=function(){this.stop(),delete this._el,delete this._container},t}();window.Spinner=a}();


		var spinnerColor = (loadingScreenParams.foregroundColor) ? loadingScreenParams.foregroundColor : undefined;

		var loadingSpinner = new Spinner('large').setStyle({
			'--tv-spinner-color': spinnerColor,
			zIndex: String(2e9),
		});
		loadingSpinner.getEl().classList.add('spinner');
		loadingSpinner.spin(loadingIndicatorElement);
	})();<\/script></body></html>`;
      var d;
    }(this._options.library_path || "", this._options.locale);
    let n = new URL("about:blank");
    if (e) {
      const e2 = new Blob([r], { type: "text/html" }), t2 = URL.createObjectURL(e2);
      n = new URL(t2);
    } else if (t) {
      const e2 = null !== (i = this._options.library_path) && void 0 !== i ? i : "/";
      n = new URL(e2 + "sameorigin.html", location.origin);
    }
    const a = "symbol=" + encodeURIComponent(this._options.symbol || "") + "&interval=" + encodeURIComponent(this._options.interval) + (this._options.toolbar_bg ? "&toolbarbg=" + encodeURIComponent(this._options.toolbar_bg.replace("#", "")) : "") + (this._options.studies_access ? "&studiesAccess=" + encodeURIComponent(JSON.stringify(this._options.studies_access)) : "") + "&widgetbar=" + encodeURIComponent(JSON.stringify(this._options.widgetbar)) + (this._options.drawings_access ? "&drawingsAccess=" + encodeURIComponent(JSON.stringify(this._options.drawings_access)) : "") + "&timeFrames=" + encodeURIComponent(JSON.stringify(this._options.time_frames)) + "&locale=" + encodeURIComponent(this._options.locale) + "&uid=" + encodeURIComponent(this._id) + "&clientId=" + encodeURIComponent(String(this._options.client_id)) + "&userId=" + encodeURIComponent(String(this._options.user_id)) + (this._options.charts_storage_url ? "&chartsStorageUrl=" + encodeURIComponent(this._options.charts_storage_url) : "") + (this._options.charts_storage_api_version ? "&chartsStorageVer=" + encodeURIComponent(this._options.charts_storage_api_version) : "") + (this._options.custom_css_url ? "&customCSS=" + encodeURIComponent(this._options.custom_css_url) : "") + (this._options.custom_font_family ? "&customFontFamily=" + encodeURIComponent(this._options.custom_font_family) : "") + (this._options.auto_save_delay ? "&autoSaveDelay=" + encodeURIComponent(String(this._options.auto_save_delay)) : "") + "&debug=" + encodeURIComponent(String(this._options.debug)) + (this._options.debug_broker ? "&debugBroker=" + encodeURIComponent(String(this._options.debug_broker)) : "") + (this._options.snapshot_url ? "&snapshotUrl=" + encodeURIComponent(this._options.snapshot_url) : "") + (this._options.timezone ? "&timezone=" + encodeURIComponent(this._options.timezone) : "") + (this._options.study_count_limit ? "&studyCountLimit=" + encodeURIComponent(String(this._options.study_count_limit)) : "") + (this._options.symbol_search_request_delay ? "&ssreqdelay=" + encodeURIComponent(String(this._options.symbol_search_request_delay)) : "") + (this._options.compare_symbols ? "&compareSymbols=" + encodeURIComponent(JSON.stringify(this._options.compare_symbols)) : "") + (this._options.theme ? "&theme=" + encodeURIComponent(String(this._options.theme)) : "") + (this._options.header_widget_buttons_mode ? "&header_widget_buttons_mode=" + encodeURIComponent(String(this._options.header_widget_buttons_mode)) : "") + (this._options.time_scale ? "&time_scale=" + encodeURIComponent(JSON.stringify(this._options.time_scale)) : "");
    return [`<iframe
		version="CL v28.5.0 (internal id fb6f897f @ 2024-12-18T12:27:11.562Z)" id="${this._id}" name="${this._id}" src="${n.href}" data-widget-options="${a}"
		${this._options.autosize || this._options.fullscreen ? "" : `width="${this._options.width}" height="${this._options.height}"`} title="Financial Chart" frameborder="0" allowTransparency="true" scrolling="no" allowfullscreen style="display:block;">
	</iframe>`, r];
  }
};
if (typeof window !== "undefined") {
  window.TradingView = window.TradingView || {};
  window.TradingView.version = version();
}
function onPlusClick(widget2, fn2) {
  widget2.subscribe("onPlusClick", () => {
    fn2();
  });
}
function onStudyAdded(widget2, fn2) {
  widget2.subscribe("study", ({ value }) => {
    fn2(value);
  });
}
function onIntervalChanged(widget2, fn2) {
  widget2.chart().onIntervalChanged().subscribe(null, function(interval, obj) {
    fn2(interval, obj);
  });
}
function removeChangeIntervalOption(widget2) {
  widget2.onContextMenu(() => {
    return [{ text: "-Change Interval..." }];
  });
}
function removeMenuOptions(widget2, tradingviewOptions) {
  widget2.onContextMenu(() => {
    return tradingviewOptions.options.disableMenuItems.map((option) => {
      return {
        text: `-${option}`
      };
    });
  });
}
function addAutoSave(widget2, chartTypeChangeHandler) {
  widget2.subscribe("onAutoSaveNeeded", () => {
    widget2.save((data) => {
      var _a2;
      chartTypeChangeHandler(widget2.chart().chartType());
      PriceChartService.saveChartLayout(data);
      if ((_a2 = useTradeviewUserChartsStore()) == null ? void 0 : _a2.areTradingviewUserTemplatesEnabled) {
        widget2.saveChartToServer();
      }
    });
  });
}
function autoRescale(widget2) {
  widget2.activeChart().getPanes().forEach((pane) => {
    const mainSourcePriceScale = pane.getMainSourcePriceScale();
    if (!mainSourcePriceScale || mainSourcePriceScale.isAutoScale()) {
      return;
    }
    mainSourcePriceScale.setAutoScale(true);
    setTimeout(() => mainSourcePriceScale.setAutoScale(false), 0);
  });
}
function tradingViewWidget(getUserStateStore, getActiveMarketStore, getMarketsStore, getTradeviewTickersStore, setTimeframeAndResolution, reloadLiveCandle, getLastPriceHistoryBarTime, setLastPriceHistoryBarTime, getIsHiddenState, assetsPath = "/assets/dashboard/") {
  var _a2;
  const activeMarketName = getActiveMarketStore().activeMarket.name;
  const tradeviewThemeStore = useTradeviewThemeStore();
  const tradingviewOptions = new TradingviewOptions(
    () => tradeviewThemeStore.activeTradeviewThemeSettings,
    assetsPath,
    PAGE_CONTEXT.extTradingViewCss
  );
  const widgetOptions = {
    ...tradingviewOptions.options,
    symbol: activeMarketName,
    interval: LocalStorageService.read(constants.LOCAL_STORAGE.TRADING_VIEW_INTERVAL) || "60",
    datafeed: new Datafeed(
      getActiveMarketStore,
      getMarketsStore,
      getTradeviewTickersStore,
      setTimeframeAndResolution,
      reloadLiveCandle,
      getLastPriceHistoryBarTime,
      setLastPriceHistoryBarTime,
      getIsHiddenState
    ),
    "user_id": (_a2 = getUserStateStore().state) == null ? void 0 : _a2.username,
    container: "tradingview_container",
    "auto_save_delay": 1
  };
  const chartLayout = PriceChartService.loadChartLayout(activeMarketName);
  if (chartLayout !== null) {
    widgetOptions["saved_data"] = chartLayout;
  }
  const widgetInternal = new widget(widgetOptions);
  widgetInternal.removeMenuOptions = () => removeMenuOptions(widgetInternal, tradingviewOptions);
  widgetInternal.removeChangeIntervalOption = () => removeChangeIntervalOption(widgetInternal);
  widgetInternal.addAutoSave = (chartTypeChangeHandler) => addAutoSave(widgetInternal, chartTypeChangeHandler);
  widgetInternal.onStudyAdded = (fn2) => onStudyAdded(widgetInternal, fn2);
  widgetInternal.onIntervalChanged = (fn2) => onIntervalChanged(widgetInternal, fn2);
  widgetInternal.onPlusClick = (fn2) => onPlusClick(widgetInternal, fn2);
  widgetInternal.autoRescale = () => autoRescale(widgetInternal);
  return widgetInternal;
}
const _hoisted_1$x = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "28",
  height: "28",
  viewBox: "0 0 28 28"
};
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$x, _cache[0] || (_cache[0] = [
    createBaseVNode("g", { fill: "currentColor" }, [
      createBaseVNode("path", { d: "M23.97 11.5h-1V7h-4.49V6h5.49zm-20 0h-1V6h5.51v1H3.97zm20 10.5h-5.49v-1h4.49v-4.5h1zM8.48 22H2.97v-5.5h1V21h4.51z" }),
      createBaseVNode("path", { d: "m3.127 6.86.707-.707 4.497 4.498-.707.707zm15.5 3.79 4.497-4.497.707.707-4.497 4.497zM3.131 21.145l4.498-4.497.707.707-4.498 4.497zm15.501-3.79.707-.707 4.497 4.497-.707.707z" })
    ], -1)
  ]));
}
const FullScreenOffSVG = { render: render$3 };
const _hoisted_1$w = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "28",
  height: "28",
  viewBox: "0 0 28 28"
};
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$w, _cache[0] || (_cache[0] = [
    createBaseVNode("g", { fill: "currentColor" }, [
      createBaseVNode("path", { d: "M23.47 12h-5.49V6.5h1V11h4.49zM8.98 12H3.47v-1h4.51V6.5h1zm10 9.5h-1V16h5.49v1h-4.49zm-10 0h-1V17H3.47v-1h5.51z" }),
      createBaseVNode("path", { d: "m3.628 7.358.707-.707 4.002 4.002-.707.707zm14.996 3.288 4.003-4.002.707.707-4.002 4.003zM3.629 20.654l4.002-4.002.707.707-4.002 4.002zm14.996-3.302.708-.707 4.002 4.002-.707.708z" })
    ], -1)
  ]));
}
const FullScreenOnSVG = { render: render$2 };
const _hoisted_1$v = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "28",
  height: "28",
  fill: "none",
  viewBox: "0 0 28 28"
};
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$v, _cache[0] || (_cache[0] = [
    createBaseVNode("g", { fill: "currentColor" }, [
      createBaseVNode("path", { d: "M22.2 16H6V6h16.3L20 11zM7 15h13.7l-1.8-4 1.8-4H7z" }),
      createBaseVNode("path", { d: "M6 7h1v16H6zm7 7c-2.2 0-4-1.3-4-3s1.8-3 4-3 4 1.3 4 3-1.8 3-4 3m0-5c-1.6 0-3 .9-3 2s1.4 2 3 2 3-.9 3-2-1.4-2-3-2" }),
      createBaseVNode("path", { d: "M13 12c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1-.5 1-1 1" })
    ], -1)
  ]));
}
const OpenOrdersShowSVG = { render: render$1 };
const _hoisted_1$u = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "28",
  height: "28",
  fill: "none",
  viewBox: "0 0 28 28"
};
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$u, _cache[0] || (_cache[0] = [
    createBaseVNode("g", { fill: "currentColor" }, [
      createBaseVNode("path", { d: "M22.2 16H6V6h16.3L20 11zM7 15h13.7l-1.8-4 1.8-4H7z" }),
      createBaseVNode("path", { d: "M6 7h1v16H6z" })
    ], -1)
  ]));
}
const OpenOrdersHideSVG = { render };
const toggleFullScreen = (isCurrentlyFullScreen, callback) => {
  const fullScreenRequestMethods = [
    "requestFullscreen",
    "webkitRequestFullscreen",
    "mozRequestFullScreen",
    "msRequestFullscreen"
  ];
  if (!fullScreenRequestMethods.some((method) => document.documentElement[method])) {
    callback(!isCurrentlyFullScreen);
    return true;
  }
  if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
    const fsChangeHandler = () => {
      if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
        document.removeEventListener("fullscreenchange", fsChangeHandler);
        document.removeEventListener("webkitfullscreenchange", fsChangeHandler);
        document.removeEventListener("mozfullscreenchange", fsChangeHandler);
        document.removeEventListener("MSFullscreenChange", fsChangeHandler);
        callback(false);
      }
    };
    const i = document.documentElement;
    if (i.requestFullscreen) {
      i.requestFullscreen();
    } else if (i.webkitRequestFullscreen) {
      i.webkitRequestFullscreen();
    } else if (i.mozRequestFullScreen) {
      i.mozRequestFullScreen();
    } else if (i.msRequestFullscreen) {
      i.msRequestFullscreen();
    }
    document.addEventListener("fullscreenchange", fsChangeHandler);
    document.addEventListener("webkitfullscreenchange", fsChangeHandler);
    document.addEventListener("mozfullscreenchange", fsChangeHandler);
    document.addEventListener("MSFullscreenChange", fsChangeHandler);
    callback(true);
  } else if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  }
};
const utils$1 = {
  toggleFullScreen
};
class liveCandleApiConverter {
  /**
   {
     "high": "8638.86",
     "timestamp": "1605830400",
     "volume": "78153.34360524",
     "low": "6182.67",
     "close": "8335.56",
     "open": "8300.00"
   }
   * @param candles
   * @param pair - String ('btcusd')
   * @param {string} resolution - ('1', '15', '60', '1D', '3D', '1W', '1M', ...)
   * @returns Object
   */
  static parse({ data: liveCandle }, pair, resolution) {
    if (_.isEmpty(liveCandle)) {
      throw new TypeError("Expected OHLC data to not be empty.");
    }
    return new priceChartUtils.LiveCandle({
      open: new Decimal(liveCandle.open),
      high: new Decimal(liveCandle.high),
      close: new Decimal(liveCandle.close),
      low: new Decimal(liveCandle.low),
      volume: new Decimal(liveCandle.volume),
      time: parseInt(liveCandle.timestamp) * 1e3,
      pair,
      resolution
    });
  }
}
class LiveCandleApi {
  static getLiveCandle(marketKey, resolution) {
    const url = URLService.buildUrl("currentCandle", { market: marketKey }, true, { resolution });
    return axiosInstance.get(url).then((response) => liveCandleApiConverter.parse(response.data, marketKey, resolution));
  }
}
const storeName$3 = "tradeviewPositionHistoryStore";
const useTradeviewPositionHistoryStore = addStoreHooks(
  defineStore(storeName$3, () => {
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$3 }));
    const activeMarketStore = useActiveMarketStore({ caller: storeName$3 });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$3 }));
    const tradeviewSettingsStore = useTradeviewSettingsStore({ caller: storeName$3 });
    const subAccountStore = useSubAccountStore({ caller: storeName$3 });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$3 }));
    const pollingStore = usePollingStore({ caller: storeName$3 });
    const $errorTracking = useErrorTracking();
    let stopPollingFn = () => {
    };
    const initialized = ref(false);
    const positionHistory = shallowRef([]);
    const page = ref(1);
    const perPage = ref(20);
    const fetchPositionHistory = _.throttle(
      async () => {
        var _a2;
        if (!isLoggedIn.value || activeMarketStore.isSpot || !subAccountStore.doesActiveAccountSupportDerivatives) {
          initialized.value = true;
          return;
        }
        const marketKey = tradeviewSettingsStore.areUserOrdersInAllPairMode ? "" : ((_a2 = activeMarketStore.activeMarket) == null ? void 0 : _a2.key) ?? "";
        try {
          positionHistory.value = await positionsApi.listPositionHistory(
            subAccountStore.activeSubAccountId,
            page.value,
            perPage.value,
            marketKey
          );
        } catch (e) {
          $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        }
      },
      constants$2.TIMERS.THROTTLE_POSITION_HISTORY,
      { leading: false }
    );
    function stopPolling() {
      stopPollingFn();
      stopPollingFn = () => {
      };
    }
    function startPolling() {
      stopPolling();
      const { stop } = pollingStore.startPolling({
        id: constants$2.TIMERS.POLLING_DERIVATIVES_POSITION_HISTORY.ID,
        interval: constants$2.TIMERS.POLLING_DERIVATIVES_POSITION_HISTORY.TIME,
        fn: fetchPositionHistory
      });
      stopPollingFn = stop;
    }
    async function setPage(newPage) {
      page.value = newPage;
      await fetchPositionHistory();
    }
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        positionHistory.value = [];
        stopPolling();
      }
    });
    watch(
      activeMarket,
      async (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
          return;
        }
        fetchPositionHistory();
      },
      { deep: true }
    );
    watch(activeSubAccountId, async () => {
      positionHistory.value = [];
      if (subAccountStore.doesActiveAccountSupportDerivatives) {
        fetchPositionHistory();
      } else {
        stopPolling();
      }
    });
    return {
      positionHistory,
      fetchPositionHistory,
      setPage,
      startPolling,
      stopPolling
    };
  })
);
const storeName$2 = "tradeviewPrivateTradesStore";
const useTradeviewPrivateTradesStore = addStoreHooks(
  defineStore(storeName$2, () => {
    const websocketStore = useWebsocketStore({ caller: storeName$2 });
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$2 }));
    const marketsStore = useMarketsStore({ caller: storeName$2 });
    const { initialized: isMarketsStoreInitialized } = storeToRefs(useMarketsStore({ caller: storeName$2 }));
    const feeScheduleStore = useFeeScheduleStore({ caller: storeName$2 });
    const tradeviewSettingsStore = useTradeviewSettingsStore({ caller: storeName$2 });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$2 }));
    const subAccountStore = useSubAccountStore({ caller: storeName$2 });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$2 }));
    const pollingStore = usePollingStore({ caller: storeName$2 });
    const balancesStore = useBalancesStore({ caller: storeName$2 });
    const tradeviewOrderNotificationsStore = useTradeviewOrderNotificationsStore({ caller: storeName$2 });
    const tradeviewOrderHistoryStore = useTradeviewOrderHistoryStore({ caller: storeName$2 });
    const tradeviewMarginInfoStore = useTradeviewMarginInfoStore({ caller: storeName$2 });
    const tradeviewOpenPositionsStore = useTradeviewOpenPositionsStore({ caller: storeName$2 });
    const tradeviewPositionHistoryStore = useTradeviewPositionHistoryStore({ caller: storeName$2 });
    const $errorTracking = useErrorTracking();
    const $has = useUserPermissions();
    let stopPollingFn = () => {
    };
    let disconnectWsFns = [];
    const isProcessing = ref(false);
    const trades = shallowRef([]);
    const tradesForTrackedOrders = ref({});
    const pendingTrackedOrderTradesToFetch = /* @__PURE__ */ new Set();
    const fetchTradeHistory = _.throttle(async () => {
      var _a2;
      if (isProcessing.value || !isLoggedIn.value || !((_a2 = activeMarket.value) == null ? void 0 : _a2.key)) {
        return;
      }
      const market = activeMarket.value;
      if (market === null) {
        return;
      }
      if (!subAccountStore.activeSubAccount.enabledMarketTypes.includes(market.type)) {
        return;
      }
      isProcessing.value = true;
      try {
        trades.value = await tradeHistoryV2Api.listWithPagination({
          account: subAccountStore.activeSubAccountId,
          market: tradeviewSettingsStore.areUserOrdersInAllPairMode ? null : market.key,
          marketType: market.type
        });
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
      isProcessing.value = false;
    }, constants.TIMERS.TRADES.THROTTLE);
    async function fetchAndTrackTradeHistoryByOrderId(orderId, addToTracking = true) {
      try {
        const trades2 = await tradeHistoryV2Api.listAll({
          orderId,
          account: subAccountStore.activeSubAccountId
        });
        if (addToTracking || tradesForTrackedOrders.value[orderId]) {
          tradesForTrackedOrders.value = {
            ...tradesForTrackedOrders.value,
            [orderId]: trades2
          };
        }
      } catch (e) {
        $errorTracking == null ? void 0 : $errorTracking.trackException(e);
      }
    }
    function stopTrackingTradesForOrder(orderId) {
      delete tradesForTrackedOrders.value[orderId];
      pendingTrackedOrderTradesToFetch.delete(orderId);
    }
    const throttledFetchTradeHistoryByOrderId = _.throttle(
      async () => {
        const orderIdsToFetch = Array.from(pendingTrackedOrderTradesToFetch);
        pendingTrackedOrderTradesToFetch.clear();
        if (orderIdsToFetch.length > 10) {
          return;
        }
        const promises = orderIdsToFetch.map((id) => fetchAndTrackTradeHistoryByOrderId(id, false));
        await Promise.all(promises);
      },
      1e3,
      { leading: false, trailing: true }
    );
    function startPollingTradeHistory() {
      if (!isLoggedIn.value) {
        return;
      }
      const { stop } = pollingStore.startPolling({
        id: constants.TIMERS.POLLING_USER_TRADES.ID,
        interval: constants.TIMERS.POLLING_USER_TRADES.TIME,
        fn: fetchTradeHistory
      });
      stopPollingFn = stop;
    }
    function stopPollingTradeHistory() {
      stopPollingFn();
      stopPollingFn = () => {
      };
    }
    async function connectWs() {
      if (isLoggedIn.value) {
        for (const [key] of Object.entries(marketsStore.visibleMarkets)) {
          const { disconnect } = await websocketStore.subscribeToChannel({
            channel: websocketStore.getPrivateMyTradesChannelName(key),
            event: WSApi.USER_TRADE_EVENT,
            onEvent: async (trade) => {
              var _a2;
              if (trade.trade_account_id === 0 && subAccountStore.activeSubAccountId === "main" || trade.trade_account_id === subAccountStore.activeSubAccountId) {
                fetchTradeHistory();
                balancesStore.fetch();
                tradeviewOrderHistoryStore.fetchOrderHistory();
                tradeviewOrderNotificationsStore.addPendingOrderFillNotification(trade);
                feeScheduleStore.startAggressivePolling();
                if (((_a2 = marketsStore.getMarket(trade.market)) == null ? void 0 : _a2.type) === marketConstants.MARKET_TYPES.PERPETUAL) {
                  tradeviewMarginInfoStore.fetchMarginInfo();
                  tradeviewOpenPositionsStore.fetchOpenPositions();
                  tradeviewPositionHistoryStore.fetchPositionHistory();
                }
                if (tradesForTrackedOrders.value[trade.order_id]) {
                  pendingTrackedOrderTradesToFetch.add(trade.order_id);
                  throttledFetchTradeHistoryByOrderId();
                }
              }
            },
            eventGroupKey: "tradeviewPrivateTradesStore"
          });
          disconnectWsFns.push(disconnect);
        }
      }
    }
    function disconnectWs() {
      disconnectWsFns.forEach((cb) => {
        cb();
      });
      disconnectWsFns = [];
    }
    async function _init() {
      if (!$has("transaction_history_read") || !isLoggedIn.value) {
        return;
      }
      fetchTradeHistory();
      startPollingTradeHistory();
      if (marketsStore.initialized) {
        await connectWs();
      }
      return () => {
        disconnectWs();
        stopPollingTradeHistory();
      };
    }
    watch(isMarketsStoreInitialized, (newValue, prevValue) => {
      if (prevValue && !newValue) {
        return;
      }
      connectWs();
    });
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        trades.value = [];
        stopPollingTradeHistory();
        disconnectWs();
      }
    });
    watch(
      activeMarket,
      async (newMarket, prevMarket) => {
        if ((newMarket == null ? void 0 : newMarket.key) === (prevMarket == null ? void 0 : prevMarket.key)) {
          return;
        }
        if (tradeviewSettingsStore.areUserOrdersInAllPairMode && (newMarket == null ? void 0 : newMarket.type) === (prevMarket == null ? void 0 : prevMarket.type) && prevMarket !== null) {
          return;
        }
        trades.value = [];
        pendingTrackedOrderTradesToFetch.clear();
        fetchTradeHistory();
      },
      {
        deep: true
      }
    );
    watch(activeSubAccountId, () => {
      trades.value = [];
      pendingTrackedOrderTradesToFetch.clear();
      fetchTradeHistory();
    });
    return {
      trades,
      tradesForTrackedOrders,
      fetchAndTrackTradeHistoryByOrderId,
      stopTrackingTradesForOrder,
      fetchTradeHistory,
      _init
    };
  })
);
const _sfc_main$z = {
  name: "ClosePositionModal",
  components: {
    TradeviewModal
  },
  props: {
    /** @type module:openPositionsStore.FormattedOpenPosition */
    position: {
      type: Object,
      required: true
    }
  },
  emits: ["close"],
  setup() {
    return {
      subAccountStore: useSubAccountStore(),
      toastStore: useToastStore()
    };
  },
  methods: {
    async onConfirm() {
      this.closeModal();
      try {
        await positionsApi.close(this.position.id, true);
        this.toastStore.showSuccessToast(`${this.position.marketName} ${this.position.marginModeDisplay} position closed.`);
      } catch (e) {
        this.toastStore.showErrorToast(`Could not close ${this.position.marketName} ${this.position.marginModeDisplay} position.`);
      }
    },
    closeModal() {
      this.$emit("close");
    }
  }
};
const _hoisted_1$t = { class: "mt8" };
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  return openBlock(), createBlock(_component_TradeviewModal, {
    "is-open": "",
    "confirm-text": "Confirm",
    "cancel-text": "Cancel",
    title: "Close position",
    onConfirm: $options.onConfirm,
    onClose: $options.closeModal
  }, {
    body: withCtx(() => [
      createBaseVNode("p", null, [
        _cache[0] || (_cache[0] = createTextVNode("\n        Are you sure you want to close your\n        ")),
        createBaseVNode("strong", null, toDisplayString($props.position.marketName) + " " + toDisplayString($props.position.marginModeDisplay), 1),
        _cache[1] || (_cache[1] = createTextVNode(" position?\n      "))
      ]),
      _cache[6] || (_cache[6] = createTextVNode()),
      createBaseVNode("p", _hoisted_1$t, [
        _cache[2] || (_cache[2] = createTextVNode("\n        Note that this will also close any open ")),
        _cache[3] || (_cache[3] = createBaseVNode("strong", null, "orders", -1)),
        _cache[4] || (_cache[4] = createTextVNode(" on\n        ")),
        createBaseVNode("strong", null, toDisplayString($props.position.marketName) + " " + toDisplayString($props.position.marginModeDisplay), 1),
        _cache[5] || (_cache[5] = createTextVNode(".\n      "))
      ])
    ]),
    _: 1
  }, 8, ["onConfirm", "onClose"]);
}
const ClosePositionModal = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$r]]);
const LINE_STYLE_FULL = 0;
const LINE_STYLE_DASHED = 2;
function useLastPriceHistoryBarTime() {
  const { activeMarket } = storeToRefs(useActiveMarketStore());
  const lastPriceHistoryBarTime = ref(null);
  function setLastPriceHistoryBarTime(time, timeFrame) {
    lastPriceHistoryBarTime.value = { time, timeFrame };
  }
  watch(activeMarket, (newValue, prevValue) => {
    if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
      return;
    }
    lastPriceHistoryBarTime.value = null;
  }, {
    deep: true
  });
  return {
    lastPriceHistoryBarTime,
    setLastPriceHistoryBarTime
  };
}
function useLiveCandle() {
  const liveCandle = ref({});
  const timeFrame = ref(3600);
  const resolution = ref("60");
  const { activeMarket } = storeToRefs(useActiveMarketStore());
  const tradesStore = useTradesStore();
  const toastStore = useToastStore();
  const throttledUpdateLiveCandle = lodashExports.throttle(
    async () => {
      try {
        const trades = tradesStore.activeMarketTrades;
        const lastTradeIdBeforeApiCall = trades.length > 0 ? trades[0].id : null;
        const marketBeforeFetch = activeMarket.value;
        const marketKey = marketBeforeFetch.key;
        const liveCandle2 = await LiveCandleApi.getLiveCandle(marketKey, resolution.value);
        if (marketKey !== activeMarket.value.key) {
          return false;
        }
        liveCandle2.lastTradeId = lastTradeIdBeforeApiCall;
        setLiveCandle(liveCandle2);
      } catch (e) {
        if (e instanceof TypeError) {
          updateLiveCandleFromTrades();
        } else {
          toastStore.showNetworkError();
        }
        return false;
      }
    },
    500,
    {
      leading: true,
      trailing: false
    }
  );
  function updateLiveCandleFromAPI() {
    throttledUpdateLiveCandle();
  }
  function updateLiveCandleFromTrades() {
    const liveBarTime = priceChartUtils.toLiveBarTime(resolution.value);
    const trades = tradesStore.activeMarketTrades;
    const numTrades = trades.length;
    const newLiveCandleTrades = [];
    for (let i = 0; i < numTrades && trades[i].id !== liveCandle.value.lastTradeId && trades[i].date >= liveBarTime; i++) {
      newLiveCandleTrades.push(trades[i]);
    }
    if (newLiveCandleTrades.length > 0) {
      let currentLiveCandle;
      if (liveCandle.value.time !== getTime(liveBarTime)) {
        currentLiveCandle = new priceChartUtils.LiveCandle({
          time: getTime(liveBarTime),
          pair: activeMarket.value.key
        });
      } else {
        currentLiveCandle = liveCandle.value;
      }
      setLiveCandle(
        priceChartUtils.tradesToCandle(currentLiveCandle, newLiveCandleTrades, resolution.value)
      );
    }
  }
  function reloadLiveCandle() {
    liveCandle.value = Object.freeze({ ...liveCandle.value });
  }
  function setLiveCandle(newLiveCandle) {
    if (activeMarket.value.key === newLiveCandle.pair && resolution.value === newLiveCandle.resolution) {
      liveCandle.value = Object.freeze(newLiveCandle);
    }
  }
  function setTimeframeAndResolution(data) {
    timeFrame.value = data.timeFrame;
    resolution.value = data.resolution;
    updateLiveCandleFromAPI();
  }
  watch(activeMarket, (newValue, prevValue) => {
    if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
      return;
    }
    liveCandle.value = Object.freeze({});
  }, {
    deep: true
  });
  return {
    liveCandle,
    resolution,
    timeFrame,
    setTimeframeAndResolution,
    updateLiveCandleFromAPI,
    updateLiveCandleFromTrades,
    reloadLiveCandle
  };
}
let tradingViewOpenOrderLines = [];
const _sfc_main$y = {
  name: "TradingviewContainer",
  components: {
    ClosePositionModal,
    TradingviewLoader
  },
  props: {
    mobile: {
      type: Boolean,
      default: false,
      required: false
    }
  },
  setup() {
    const {
      liveCandle,
      resolution,
      timeFrame,
      setTimeframeAndResolution,
      updateLiveCandleFromAPI,
      updateLiveCandleFromTrades,
      reloadLiveCandle
    } = useLiveCandle();
    const {
      lastPriceHistoryBarTime,
      setLastPriceHistoryBarTime
    } = useLastPriceHistoryBarTime();
    const { setActiveMarket } = useSetActiveMarket();
    return {
      activeMarketStore: useActiveMarketStore(),
      marketsStore: useMarketsStore(),
      visibilityStore: useVisibilityStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      tradeviewThemeStore: useTradeviewThemeStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradesStore: useTradesStore(),
      userStateStore: useUserStateStore(),
      tradeviewUserChartsStore: useTradeviewUserChartsStore(),
      themeStore: useThemeStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore(),
      tradeviewPrivateTradesStore: useTradeviewPrivateTradesStore(),
      liveCandle,
      resolution,
      timeFrame,
      lastPriceHistoryBarTime,
      setTimeframeAndResolution,
      updateLiveCandleFromAPI,
      updateLiveCandleFromTrades,
      reloadLiveCandle,
      setLastPriceHistoryBarTime,
      setActiveMarket
    };
  },
  data() {
    return {
      widget: {
        _ready: false
      },
      crossHair: {
        price: null,
        time: null
      },
      executionShapes: {},
      priceLineShapeId: null,
      // allowDrawingPositionLines is used to prevent createPositionLine errors when the user is changing the symbol
      allowDrawingPositionLines: true,
      openPositionLines: [],
      showTvLoader: true,
      throttledUpdateLiveCandle: this.$minMaxThrottle(
        this.updateLiveCandle,
        constants.TIMERS.PRICECHART.MIN_THROTTLE,
        constants.TIMERS.PRICECHART.MAX_THROTTLE
      ),
      deferredNewLiveCandle: null,
      positionToClose: null,
      isClosePositionModalOpen: false,
      tradingViewButtons: [
        {
          id: "orders",
          sourceToWatch: "areOpenOrdersVisible",
          iconOn: {
            title: `Don't show open orders on chart`,
            component: markRaw(OpenOrdersShowSVG),
            id: "tv-btn-orders-on"
          },
          iconOff: {
            title: "Show open orders on chart",
            component: markRaw(OpenOrdersHideSVG),
            id: "tv-btn-orders-off"
          },
          onClick: () => this.tradeviewSettingsStore.setAreOnChartOrdersEnabled(
            !this.tradeviewSettingsStore.areOnChartOrdersEnabled
          ),
          displayOnIos: true,
          isHiddenOnMobile: false,
          isHiddenOnTablet: false,
          isHiddenForAnonymous: true
        },
        {
          id: "full-screen",
          sourceToWatch: "tradeviewSettingsStore.isFullScreenMode",
          iconOn: {
            title: "Exit full screen chart",
            component: markRaw(FullScreenOnSVG),
            id: "tv-btn-full-screen-on"
          },
          iconOff: {
            title: "Full screen chart",
            component: markRaw(FullScreenOffSVG),
            id: "tv-btn-full-screen-off"
          },
          onClick: () => utils$1.toggleFullScreen(
            this.tradeviewSettingsStore.isFullScreenMode,
            (isFullScreen) => this.tradeviewSettingsStore.setIsFullScreenMode(isFullScreen)
          ),
          displayOnIos: false,
          isHiddenOnMobile: true,
          isHiddenOnTablet: false
        }
      ]
    };
  },
  computed: {
    /**
     * @return module:markets.Market
     */
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    activePairOrders() {
      return this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket;
    },
    buttonIcons() {
      return this.tradingViewButtons.map(({ iconOn, iconOff }) => [iconOn, iconOff]).flat();
    },
    crossHairPrice() {
      var _a2;
      if (!((_a2 = this.crossHair) == null ? void 0 : _a2.price)) {
        return null;
      }
      return new Decimal(this.crossHair.price).toDecimalPlaces(
        this.activeMarket.decimals.counter
      );
    },
    areOpenOrdersVisible() {
      return this.tradeviewSettingsStore.areOnChartOrdersEnabled;
    },
    /** @type {module:openPositionsStore.FormattedOpenPosition[]} */
    openPositions() {
      return this.tradeviewOpenPositionsStore.formattedOpenPositions.filter((position) => position.market === this.activeMarket.key);
    }
  },
  watch: {
    "widget._ready": {
      handler() {
        if (this.widget._ready) {
          this.showTvLoader = false;
          if (this.deferredNewLiveCandle) {
            this.changeLastBar(this.deferredNewLiveCandle, this.activeMarket.name, this.resolution);
            this.deferredNewLiveCandle = null;
          }
          this.changeSymbol();
        }
      }
    },
    "tradesStore.activeMarketTrades": {
      handler() {
        if (this.widget._ready && !this.visibilityStore.isHidden) {
          this.throttledUpdateLiveCandle();
        }
      }
    },
    "visibilityStore.isHidden": {
      handler(isHidden, wasHidden) {
        if (wasHidden && this.widget._ready) {
          this.throttledUpdateLiveCandle();
          const resolution = this.widgetInterval();
          if (this.lastPriceHistoryBarTime && priceChartUtils.getExpectedLastPriceHistoryBarTime(resolution) !== this.lastPriceHistoryBarTime.time) {
            this.widget._options.datafeed.resetCache();
            this.widget.chart().resetData();
          }
        }
      }
    },
    activeMarket(newActiveMarket, prevActiveMarket) {
      if (newActiveMarket.key === prevActiveMarket.key) {
        return;
      }
      if (this.widget._ready) {
        this.clearExecutions();
        this.drawLatestExecutions();
        this.deletePriceLine();
        this.changeSymbol();
        this.allowDrawingPositionLines = false;
      }
    },
    openPositions: {
      handler() {
        if (this.widget._ready) {
          this.redrawOpenPositionLines();
        }
      },
      deep: true
    },
    "tradeviewSettingsStore.areOnChartPositionsEnabled": {
      handler() {
        if (!this.widget._ready) {
          return;
        }
        if (this.tradeviewSettingsStore.areOnChartPositionsEnabled) {
          this.redrawOpenPositionLines();
        } else {
          this.deletePositionLines();
        }
      }
    },
    activePairOrders(orders) {
      if (this.widget._ready) {
        this.reDrawActivePairOrders(orders);
      }
    },
    "tradeviewPrivateTradesStore.trades": {
      handler() {
        this.drawLatestExecutions();
      }
    },
    "tradeviewOrderFormStore.activeOrderFormType": {
      handler(type) {
        if (type === constants$1.ORDER_FORM_TYPE.MARKET) {
          this.deletePriceLine();
        } else {
          this.createPriceLine(this.crossHairPrice);
        }
      }
    },
    "tradeviewTriggerValueStore.priceSetByTrigger": {
      handler(newPrice) {
        if (!this.widget._ready) {
          return;
        }
        if (newPrice !== null && newPrice.gt(0)) {
          this.createPriceLine(newPrice);
        } else {
          this.deletePriceLine();
        }
      },
      immediate: true
    },
    areOpenOrdersVisible: {
      handler() {
        if (!this.widget._ready) {
          return;
        }
        this.reDrawActivePairOrders(this.activePairOrders);
      }
    },
    liveCandle: {
      handler(newLiveCandle) {
        if (!this.widget._ready) {
          this.deferredNewLiveCandle = newLiveCandle;
        } else {
          this.changeLastBar(newLiveCandle, this.activeMarket.name, this.resolution);
        }
      }
    },
    "tradeviewThemeStore.activeTradeviewThemeSettings": {
      handler() {
        this.switchTradingviewTheme();
      }
    },
    "tradeviewThemeStore.activeColorScheme": {
      handler() {
        this.switchTradingviewTheme();
      }
    },
    "tradeviewUserChartsStore.charts": {
      handler(newCharts, prevCharts) {
        if (newCharts.length === 0 && prevCharts.length > 0) {
          this.switchTradingviewTheme();
        }
      },
      deep: true
    }
  },
  async mounted() {
    tradingViewOpenOrderLines = [];
    if (this.tradeviewUserChartsStore.areTradingviewUserTemplatesEnabled) {
      await this.tradeviewUserChartsStore.fetchTradingViewUserCharts();
    }
    this.applyTvSettings();
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.resizeHandler);
  },
  methods: {
    initializeButtons() {
      const isIPhoneOS = isIos();
      for (const settings of this.tradingViewButtons) {
        if (isIPhoneOS && !settings.displayOnIos) {
          continue;
        }
        const tvBtn = this.widget.createButton({ align: "right" });
        tvBtn.classList.add("bts-button-group__button");
        const groupContainer = tvBtn.parentNode.parentNode;
        const groupClasses = ["bts-button-group"];
        if (settings.isHiddenOnMobile) {
          groupClasses.push("bts-button-group--hidden-mobile");
        }
        if (settings.isHiddenOnTablet) {
          groupClasses.push("bts-button-group--hidden-tablet");
        }
        groupContainer.classList.add(...groupClasses);
        const iconOnTemplate = document.getElementById(settings.iconOn.id);
        const iconOffTemplate = document.getElementById(settings.iconOff.id);
        if (!iconOffTemplate || !iconOnTemplate) {
          continue;
        }
        const iconOn = iconOnTemplate.cloneNode(true);
        const iconOff = iconOffTemplate.cloneNode(true);
        const refreshButton = (isActive) => {
          const childSvgs = tvBtn.getElementsByTagName("svg");
          for (const child of childSvgs) {
            tvBtn.removeChild(child);
          }
          if (isActive) {
            tvBtn.appendChild(iconOn);
            tvBtn.setAttribute("title", settings.iconOn.title);
          } else {
            tvBtn.appendChild(iconOff);
            tvBtn.setAttribute("title", settings.iconOff.title);
          }
        };
        if (settings.isHiddenForAnonymous) {
          this.$watch("userStateStore.isLoggedIn", (isLoggedIn) => {
            if (!isLoggedIn) {
              groupContainer.classList.add("bts-hidden");
              groupContainer.previousSibling.classList.add("bts-hidden");
            } else {
              groupContainer.classList.remove("bts-hidden");
              groupContainer.previousSibling.classList.remove("bts-hidden");
            }
          }, { immediate: true });
        }
        tvBtn.addEventListener("click", settings.onClick);
        this.$watch(settings.sourceToWatch, (isNowOn) => refreshButton(isNowOn), { immediate: true });
      }
    },
    /**
     * Process hash parameters
     * - Load time frame via url hash #t=timeFrame [minute,1D,3D]
     *
     * Example: #t=60 [1 hour], #t=720 [12hour], #t=1D [1 Day]
     */
    processHashParameters() {
      const result = {};
      location.hash.substr(1).split("&").forEach((item) => {
        result[item.split("=")[0]] = decodeURIComponent(item.split("=")[1]);
      });
      if (result.t) {
        this.widget.setSymbol(this.activeMarket.name, result.t);
      }
    },
    changeLastBar(newLiveCandle, marketName, resolution) {
      if (newLiveCandle.time) {
        this.widget._options.datafeed.changeLastBar(
          {
            open: +newLiveCandle.open,
            high: +newLiveCandle.high,
            low: +newLiveCandle.low,
            close: +newLiveCandle.close,
            volume: +newLiveCandle.volume,
            time: newLiveCandle.time
          },
          marketName,
          resolution
        );
      }
    },
    resizeHandler(event) {
      if (!this.$refs.tvContainer) {
        return false;
      }
      const condensedClass = "bts-condensed";
      let classList = null;
      const iframeElements = this.$refs.tvContainer.getElementsByTagName(
        "iframe"
      );
      if (iframeElements.length > 0) {
        const htmlElements = iframeElements[0].contentDocument.getElementsByTagName(
          "html"
        );
        if (htmlElements.length > 0) {
          classList = htmlElements[0].classList;
        }
      }
      if (classList && event.target.innerHeight < SCREEN_SIZES.height.small && event.target.innerWidth > SCREEN_SIZES.width.big) {
        classList.add(condensedClass);
      } else if (classList) {
        classList.remove(condensedClass);
      }
    },
    widgetInterval() {
      return this.widget.symbolInterval().interval;
    },
    updateLiveCandle(fromTrades = true) {
      if (fromTrades) {
        this.updateLiveCandleFromTrades();
      } else {
        this.updateLiveCandleFromAPI();
      }
    },
    changeSymbol() {
      this.widget.setSymbol(this.activeMarket.name, this.widgetInterval());
    },
    applyActiveTheme() {
      const widgetRoot = this.widget._iFrame.contentWindow.document.getElementsByTagName("html")[0];
      const activeTheme = this.tradeviewThemeStore.activeTradeviewThemeSettings;
      widgetRoot.classList.remove(
        theme.CLASS,
        // Bitstamp's theme class
        theme$1.CLASS,
        // Bitstamp's theme class
        "theme-dark",
        // TradingView's theme class
        "theme-light",
        // TradingView's theme class
        constants.COLOR_SCHEMES.CLASSIC,
        constants.COLOR_SCHEMES.FUNKY
      );
      widgetRoot.classList.add(
        activeTheme.CLASS,
        activeTheme.CLASS_TRADING_VIEW
      );
      widgetRoot.classList.add(this.tradeviewThemeStore.activeColorScheme);
    },
    createPriceLine(price) {
      var _a2, _b;
      if (!price || !price.isPositive()) {
        return;
      }
      this.deletePriceLine();
      const theme2 = this.tradeviewThemeStore.activeTradeviewThemeSettings;
      try {
        this.priceLineShapeId = (_b = (_a2 = this.widget) == null ? void 0 : _a2.activeChart()) == null ? void 0 : _b.createShape(
          {
            price: price.toNumber()
          },
          {
            shape: "horizontal_line",
            disableSelection: true,
            disableSave: true,
            lock: true,
            overrides: {
              linewidth: 1,
              linecolor: theme2.COLORS.ORDER_LINE_BASE,
              linestyle: LINE_STYLE_DASHED
            },
            zOrder: "bottom"
          }
        );
      } catch (e) {
        return false;
      }
    },
    deletePriceLine() {
      var _a2, _b;
      try {
        if (this.priceLineShapeId) {
          (_b = (_a2 = this.widget) == null ? void 0 : _a2.activeChart()) == null ? void 0 : _b.removeEntity(this.priceLineShapeId);
        }
      } catch (e) {
        return false;
      }
    },
    changePriceLine() {
      this.tradeviewTriggerValueStore.setPriceSetByTrigger(this.crossHairPrice);
    },
    /**
     * @param {module:ordersStore.Order[]} orders
     */
    reDrawActivePairOrders(orders) {
      this.removeActivePairOrders();
      if (!this.areOpenOrdersVisible || !this.allowDrawingPositionLines) {
        return;
      }
      const decimals = this.activeMarket.decimals;
      const theme2 = this.tradeviewThemeStore.activeTradeviewThemeSettings;
      let textColor = theme2.COLORS.TEXT_BRIGHT;
      orders.forEach((order) => {
        let lineColor;
        let currency = this.activeMarket.base;
        if (order.side === constants$1.ORDER_SIDE.BUY) {
          lineColor = theme2.COLORS.TREND_UP;
          if (order.type === constants$1.ORDER_TYPE.STOP_MARKET) {
            currency = this.activeMarket.counter;
          }
          textColor = theme2.COLORS.ORDER_LINE_BUY_TEXT_COLOR;
        } else {
          lineColor = theme2.COLORS.TREND_DOWN;
        }
        const amountRemaining = order.amountAtCreate.sub(order.amountFilled);
        const formattedAmountRemaining = amountRemaining.toFixed(Math.max(amountRemaining.decimalPlaces(), 1));
        if (!order.priceToFillForm) {
          return;
        }
        try {
          tradingViewOpenOrderLines.push(
            this.widget.chart().createOrderLine().setCancelTooltip("Cancel order").onCancel(() => {
              if (this.$has("trade_orders_cancel")) {
                this.tradeviewPrivateOrdersStore.cancelOrder(order.id, order.type);
              }
            }).setPrice(order.priceToFillForm.toFixed(decimals.counter)).setLineColor(lineColor).setBodyBorderColor(theme2.COLORS.ORDER_LINE_BORDER).setBodyBackgroundColor(lineColor).setBodyTextColor(textColor).setQuantityBorderColor(theme2.COLORS.ORDER_LINE_BORDER).setQuantityBackgroundColor(lineColor).setQuantityTextColor(textColor).setCancelButtonBorderColor(theme2.COLORS.ORDER_LINE_BORDER).setCancelButtonBackgroundColor(lineColor).setCancelButtonIconColor(textColor).setText(`${constants$1.ORDER_TYPE_CONFIG[order.type].display} ${order.side}`).setExtendLeft(false).setLineStyle(LINE_STYLE_DASHED).setQuantity(`${formattedAmountRemaining} ${currency}`).setLineLength(40)
          );
        } catch (e) {
          return false;
        }
      });
    },
    removeActivePairOrders() {
      tradingViewOpenOrderLines.forEach((order) => {
        try {
          order.remove();
        } catch (e) {
          return false;
        }
      });
      tradingViewOpenOrderLines = [];
    },
    deletePositionLines() {
      this.openPositionLines.forEach((position) => {
        try {
          position.remove();
        } catch (e) {
          return false;
        }
      });
    },
    redrawOpenPositionLines() {
      if (!this.allowDrawingPositionLines || !this.tradeviewSettingsStore.areOnChartPositionsEnabled) {
        return;
      }
      this.deletePositionLines();
      this.openPositions.forEach((position) => {
        try {
          const theme2 = this.tradeviewThemeStore.activeTradeviewThemeSettings;
          const posLine = this.widget.chart().createPositionLine().setText(`PNL: ${position.pnl} ${position.settlementCurrency} (${position.pnlPercentage})`).setQuantity(`${position.isLong ? "LONG" : "SHORT"}: ${position.amount}`).setPrice(position.avgEntryPriceAsDecimal.toNumber()).setBodyBorderColor(theme2.COLORS.TRADINGVIEW_LINE).setBodyBackgroundColor(theme2.COLORS.TEXT_BRIGHT).setQuantityBorderColor(theme2.COLORS.TRADINGVIEW_LINE).setQuantityBackgroundColor(theme2.COLORS.TRADINGVIEW_LINE).setQuantityTextColor(theme2.COLORS.TEXT_BRIGHT).setLineColor(theme2.COLORS.TRADINGVIEW_LINE).setExtendLeft(true).setLineStyle(LINE_STYLE_FULL).setLineLength(40).setCloseButtonBorderColor(theme2.COLORS.TRADINGVIEW_LINE).setCloseButtonBackgroundColor(theme2.COLORS.TRADINGVIEW_LINE).setCloseButtonIconColor(theme2.COLORS.TEXT_BRIGHT);
          if (position.canClose) {
            posLine.setCloseTooltip("Close position").onClose(() => {
              if (this.$has("trade_orders_create")) {
                this.positionToClose = position;
                this.isClosePositionModalOpen = true;
              }
            });
          }
          this.openPositionLines.push(posLine);
        } catch (e) {
          return false;
        }
      });
    },
    clearExecutions() {
      for (const executionShape of Object.values(this.executionShapes)) {
        try {
          executionShape.remove();
        } catch (e) {
          continue;
        }
      }
      this.executionShapes = {};
    },
    drawLatestExecutions: lodashExports.throttle(
      function() {
        var _a2, _b;
        if (!LocalStorageService.readObject("tv-executions-test", false)) {
          return;
        }
        const activeMarketPrivateTrades = this.tradeviewPrivateTradesStore.trades.filter(
          (t) => t.market === this.activeMarket.key
        );
        if (activeMarketPrivateTrades.length < 1) {
          this.clearExecutions();
          return;
        }
        const theme2 = this.tradeviewThemeStore.activeTradeviewThemeSettings;
        const market = this.activeMarket;
        for (const trade of activeMarketPrivateTrades) {
          if (this.executionShapes[trade.tradeId]) {
            continue;
          }
          const amount = numberFormatter.decimal({
            value: trade.amount,
            decimals: market.decimals.base,
            smartStripTrailingZeros: true
          });
          const price = numberFormatter.decimal({
            value: trade.price,
            decimals: market.decimals.counter
          });
          const isBuy = trade.side === constants$1.ORDER_SIDE.BUY;
          try {
            this.executionShapes[trade.tradeId] = (_b = (_a2 = this.widget) == null ? void 0 : _a2.activeChart()) == null ? void 0 : _b.createExecutionShape().setTooltip(`${isBuy ? "Buy" : "Sell"} ${amount} @ ${price} TID: ${trade.tradeId}`).setArrowColor(isBuy ? theme2.COLORS.TREND_UP : theme2.COLORS.TREND_DOWN).setDirection(isBuy ? "buy" : "sell").setTime(Math.round(trade.datetime.getTime() / 1e3));
          } catch (e) {
            console.error(e);
          }
        }
      },
      400,
      {
        // TODO: Is there a better way to wait for TradingView chart to be ready?
        leading: false,
        trailing: true
      }
    ),
    switchTradingviewTheme() {
      if (this.widget._ready) {
        this.applyTradingviewOverrides();
        this.applyActiveTheme();
      }
    },
    applyTradingviewOverrides() {
      var _a2, _b, _c;
      const tradingviewOptions = new TradingviewOptions(() => this.tradeviewThemeStore.activeTradeviewThemeSettings);
      this.widget.applyOverrides(tradingviewOptions.options.overrides);
      const volumeStudyId = (_b = (_a2 = this.widget.activeChart().getAllStudies()) == null ? void 0 : _a2.find(({ name }) => name === "Volume")) == null ? void 0 : _b.id;
      if (volumeStudyId) {
        (_c = this.widget.activeChart().getStudyById(volumeStudyId)) == null ? void 0 : _c.applyOverrides({
          "volume.color.0": tradingviewOptions.options.studies_overrides["volume.volume.color.0"],
          "volume.color.1": tradingviewOptions.options.studies_overrides["volume.volume.color.1"]
        });
      }
      if (this.tradeviewUserChartsStore.areTradingviewUserTemplatesEnabled) {
        this.widget.saveChartToServer();
      }
    },
    async applyTvSettings() {
      const widget2 = tradingViewWidget(
        () => this.userStateStore,
        () => this.activeMarketStore,
        () => this.marketsStore,
        () => this.tradeviewTickersStore,
        this.setTimeframeAndResolution,
        this.reloadLiveCandle,
        () => this.lastPriceHistoryBarTime,
        this.setLastPriceHistoryBarTime,
        () => this.visibilityStore.isHidden,
        PAGE_CONTEXT.tradeviewAssetRoot || "/assets/dashboard/"
      );
      widget2.onChartReady(() => {
        this.widget = widget2;
        this.applyActiveTheme();
        this.resizeHandler({
          target: {
            innerHeight: document.body.clientHeight,
            innerWidth: document.body.clientWidth
          }
        });
        this.processHashParameters();
        widget2.chart().onDataLoaded().subscribe(this, () => {
          this.updateLiveCandle(false);
          this.allowDrawingPositionLines = true;
          this.reDrawActivePairOrders(this.activePairOrders);
          this.redrawOpenPositionLines();
        });
        widget2.activeChart().onSymbolChanged().subscribe(null, (symbol) => {
          this.setActiveMarket(symbol.base_name);
        });
        widget2.addAutoSave(() => {
        });
        widget2.onIntervalChanged((resolution) => {
          this.setTimeframeAndResolution({
            timeFrame: priceChartUtils.intervalToSeconds(resolution),
            resolution
          });
          LocalStorageService.write(constants.LOCAL_STORAGE.TRADING_VIEW_INTERVAL, resolution);
        });
        widget2.removeChangeIntervalOption();
        widget2.removeMenuOptions();
        widget2.chart().crossHairMoved().subscribe(
          null,
          (crossHair) => {
            this.crossHair = crossHair;
          }
        );
        widget2.onPlusClick(() => {
          var _a2, _b;
          this.createPriceLine(this.crossHairPrice);
          this.tradeviewTriggerValueStore.setPriceSetByTrigger(this.crossHairPrice);
          if (this.tradeviewOrderFormStore.activeOrderFormType === constants$1.ORDER_FORM_TYPE.MARKET) {
            this.tradeviewOrderFormStore.setActiveOrderFormType(constants$1.ORDER_FORM_TYPE.LIMIT);
          }
          this.changePriceLine();
          if (this.tradeviewSettingsStore.isHorizontalLineOnPlusClickEnabled) {
            const theme2 = this.tradeviewThemeStore.activeTradeviewThemeSettings;
            (_b = widget2 == null ? void 0 : widget2.activeChart()) == null ? void 0 : _b.createShape(
              {
                price: (_a2 = this.crossHairPrice) == null ? void 0 : _a2.toNumber()
              },
              {
                shape: "horizontal_line",
                overrides: {
                  linewidth: 1,
                  linecolor: theme2.COLORS.TRADINGVIEW_LINE,
                  linestyle: LINE_STYLE_FULL
                }
              }
            );
          }
        });
        widget2.headerReady().then(this.initializeButtons);
        if (!this.tradeviewUserChartsStore.areTradingviewUserTemplatesEnabled || this.tradeviewUserChartsStore.areTradingviewUserTemplatesEnabled && this.tradeviewUserChartsStore.latestChart && this.tradeviewUserChartsStore.latestChart.darkMode !== this.themeStore.isDarkThemeActive) {
          this.applyTradingviewOverrides();
        }
        widget2.autoRescale();
      });
    }
  }
};
const _hoisted_1$s = { class: "tradingview-wrapper" };
const _hoisted_2$o = {
  id: "tradingview_container",
  ref: "tvContainer",
  "data-test": "tradingviewContainer"
};
const _hoisted_3$l = { style: { "display": "none" } };
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TradingviewLoader = resolveComponent("TradingviewLoader");
  const _component_ClosePositionModal = resolveComponent("ClosePositionModal");
  return openBlock(), createElementBlock("div", _hoisted_1$s, [
    createBaseVNode("div", _hoisted_2$o, null, 512),
    _cache[1] || (_cache[1] = createTextVNode()),
    createVNode(Transition, { name: "tradingview-loader" }, {
      default: withCtx(() => [
        $data.showTvLoader ? (openBlock(), createBlock(_component_TradingviewLoader, { key: 0 })) : createCommentVNode("", true)
      ]),
      _: 1
    }),
    _cache[2] || (_cache[2] = createTextVNode()),
    createBaseVNode("div", _hoisted_3$l, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.buttonIcons, ({ component, id }) => {
        return openBlock(), createBlock(resolveDynamicComponent(component), {
          id,
          key: id
        }, null, 8, ["id"]);
      }), 128))
    ]),
    _cache[3] || (_cache[3] = createTextVNode()),
    $data.isClosePositionModalOpen && $data.positionToClose ? (openBlock(), createBlock(_component_ClosePositionModal, {
      key: 0,
      position: $data.positionToClose,
      onClose: _cache[0] || (_cache[0] = ($event) => $data.isClosePositionModalOpen = false)
    }, null, 8, ["position"])) : createCommentVNode("", true)
  ]);
}
const TradingviewContainer = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$q], ["__scopeId", "data-v-8f5cdd74"]]);
const _sfc_main$x = {
  components: { AppScrollbar: _sfc_main$1g, AppTooltip },
  props: {
    columns: {
      type: Array,
      required: true
    },
    items: {
      type: Array,
      required: true
    },
    /**
     * Display loading indicators inside table
     */
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * Amount of rows that will be displayed when loading is active
     */
    loadingPlaceholderNum: {
      type: Number,
      default: 10
    },
    // Used by QA
    tableTestId: {
      type: String,
      default: "table"
    },
    isSubTable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["yEndReached", "action"],
  data() {
    return {
      isEmptyStateVisible: false,
      emptyStateVisibilityTimeout: null
    };
  },
  watch: {
    items(newItems) {
      clearTimeout(this.emptyStateVisibilityTimeout);
      if (newItems && newItems.length < 1) {
        this.emptyStateVisibilityTimeout = setTimeout(() => {
          this.isEmptyStateVisible = true;
        }, 250);
      } else {
        this.isEmptyStateVisible = false;
      }
    }
  },
  methods: {
    onScrolledToBottom() {
      this.$emit("yEndReached");
    },
    onHeaderAction(action) {
      this.$emit("action", action);
    }
  }
};
const _hoisted_1$r = {
  ref: "table",
  class: "table-layout"
};
const _hoisted_2$n = { class: "table-layout__row table-layout__row--header" };
const _hoisted_3$k = ["onClick"];
const _hoisted_4$j = { class: "header-tooltip-trigger" };
const _hoisted_5$g = { class: "header-tooltip-text" };
const _hoisted_6$f = { key: 2 };
const _hoisted_7$d = { key: 0 };
const _hoisted_8$d = { key: 1 };
const _hoisted_9$b = { class: "table-layout__row table-layout__row--empty" };
const _hoisted_10$b = ["colspan"];
const _hoisted_11$a = ["test-id"];
const _hoisted_12$8 = ["test-id"];
const _hoisted_13$8 = {
  key: 0,
  class: "table-layout__row table-layout__row--sub-row"
};
const _hoisted_14$8 = ["colspan"];
const _hoisted_15$8 = {
  key: 1,
  class: "table-layout__row table-layout__row--sub-table-row"
};
const _hoisted_16$8 = ["colspan"];
const _hoisted_17$8 = {
  key: 2,
  class: "table-layout__row table-layout__row--sub-table-row-spacer"
};
const _hoisted_18$7 = ["colspan"];
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_AppScrollbar = resolveComponent("AppScrollbar");
  return openBlock(), createBlock(_component_AppScrollbar, {
    "x-scroll-disable": false,
    "y-scroll-disable": $props.isSubTable || $data.isEmptyStateVisible,
    "always-visible": !$props.isSubTable,
    class: "table-layout-slider",
    onYEndReached: $options.onScrolledToBottom
  }, {
    default: withCtx(() => [
      createBaseVNode("table", _hoisted_1$r, [
        createBaseVNode("thead", {
          class: normalizeClass(["table-layout__head", { "table-layout__head--is-sub-table": $props.isSubTable }])
        }, [
          createBaseVNode("tr", _hoisted_2$n, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, ({ title, slotKey, textAlignRight, textAlignCenter, stickyLeft, stickyRight, tooltip, headerAction }) => {
              return openBlock(), createElementBlock("th", {
                key: slotKey,
                class: normalizeClass([{
                  "table-layout__cell--align-right": textAlignRight,
                  "table-layout__cell--align-center": textAlignCenter,
                  "sticky sticky--left sticky--no-side-border": stickyLeft,
                  "sticky sticky--right sticky--no-side-border": stickyRight
                }, "table-layout__cell table-layout__cell--head"])
              }, [
                renderSlot(_ctx.$slots, `${slotKey}.header`, {}, () => [
                  headerAction ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: "header-action",
                    onClick: ($event) => $options.onHeaderAction(headerAction)
                  }, toDisplayString(title), 9, _hoisted_3$k)) : tooltip ? (openBlock(), createBlock(_component_AppTooltip, {
                    key: 1,
                    strategy: "fixed",
                    container: "#app"
                  }, {
                    trigger: withCtx(() => [
                      createBaseVNode("span", _hoisted_4$j, toDisplayString(title), 1)
                    ]),
                    default: withCtx(() => [
                      _cache[0] || (_cache[0] = createTextVNode()),
                      createBaseVNode("span", _hoisted_5$g, toDisplayString(tooltip), 1)
                    ]),
                    _: 2
                  }, 1024)) : (openBlock(), createElementBlock("span", _hoisted_6$f, toDisplayString(title), 1))
                ], true)
              ], 2);
            }), 128))
          ])
        ], 2),
        _cache[5] || (_cache[5] = createTextVNode()),
        $props.loading ? (openBlock(), createElementBlock("tbody", _hoisted_7$d, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.loadingPlaceholderNum, (n) => {
            return openBlock(), createElementBlock("tr", {
              key: n,
              class: "table-layout__row"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, ({ slotKey, textAlignRight, textAlignCenter, stickyLeft, stickyRight }) => {
                return openBlock(), createElementBlock("td", {
                  key: slotKey,
                  class: normalizeClass([{
                    "table-layout__cell--align-right": textAlignRight,
                    "table-layout__cell--align-center": textAlignCenter,
                    "sticky sticky--left": stickyLeft,
                    "sticky sticky--right": stickyRight
                  }, "table-layout__cell"])
                }, _cache[1] || (_cache[1] = [
                  createBaseVNode("div", { class: "loading-item" }, null, -1)
                ]), 2);
              }), 128))
            ]);
          }), 128))
        ])) : $data.isEmptyStateVisible ? (openBlock(), createElementBlock("tbody", _hoisted_8$d, [
          createBaseVNode("tr", _hoisted_9$b, [
            createBaseVNode("td", {
              class: "table-layout__cell table-layout__cell--empty",
              colspan: $props.columns.length
            }, [
              renderSlot(_ctx.$slots, "empty", {}, void 0, true)
            ], 8, _hoisted_10$b)
          ])
        ])) : (openBlock(), createBlock(TransitionGroup, {
          key: 2,
          name: "table-layout__group",
          tag: "tbody"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item) => {
              return openBlock(), createElementBlock(Fragment, {
                key: item.key
              }, [
                createBaseVNode("tr", {
                  class: normalizeClass(["table-layout__row", {
                    "table-layout__row--has-sub-row": item.showSubRow,
                    "table-layout__row--error": item.hasError
                  }]),
                  "test-id": `${$props.tableTestId}__row`
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, ({ slotKey, textAlignRight, textAlignCenter, stickyLeft, stickyRight }) => {
                    return openBlock(), createElementBlock("td", {
                      key: slotKey,
                      class: normalizeClass([{
                        "table-layout__cell--align-right": textAlignRight,
                        "table-layout__cell--align-center": textAlignCenter,
                        "sticky sticky--left": stickyLeft,
                        "sticky sticky--right": stickyRight,
                        "table-layout__cell--has-sub-table": item.showSubTable
                      }, "table-layout__cell"]),
                      "test-id": `${$props.tableTestId}__cell`
                    }, [
                      renderSlot(_ctx.$slots, slotKey, { item }, void 0, true)
                    ], 10, _hoisted_12$8);
                  }), 128))
                ], 10, _hoisted_11$a),
                _cache[2] || (_cache[2] = createTextVNode()),
                item.showSubRow ? (openBlock(), createElementBlock("tr", _hoisted_13$8, [
                  createBaseVNode("td", {
                    colspan: $props.columns.length,
                    class: "table-layout__cell table-layout__cell--sub-row"
                  }, [
                    renderSlot(_ctx.$slots, "subRow", { item }, void 0, true)
                  ], 8, _hoisted_14$8)
                ])) : createCommentVNode("", true),
                _cache[3] || (_cache[3] = createTextVNode()),
                item.showSubTable ? (openBlock(), createElementBlock("tr", _hoisted_15$8, [
                  createBaseVNode("td", {
                    class: "table-layout__cell--sub-table",
                    colspan: $props.columns.length
                  }, [
                    renderSlot(_ctx.$slots, "subTable", { item }, void 0, true)
                  ], 8, _hoisted_16$8)
                ])) : createCommentVNode("", true),
                _cache[4] || (_cache[4] = createTextVNode()),
                item.showSubTable ? (openBlock(), createElementBlock("tr", _hoisted_17$8, [
                  createBaseVNode("td", {
                    class: "table-layout__cell--sub-table-spacer",
                    colspan: $props.columns.length
                  }, null, 8, _hoisted_18$7)
                ])) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ]),
          _: 3
        }))
      ], 512)
    ]),
    _: 3
  }, 8, ["y-scroll-disable", "always-visible", "onYEndReached"]);
}
const TableLayout = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$p], ["__scopeId", "data-v-8f24663a"]]);
const _sfc_main$w = {
  name: "ReceiptLink",
  components: { AppIcon },
  props: {
    link: {
      type: String,
      required: true
    },
    size: {
      type: Number,
      default: 13
    }
  }
};
const _hoisted_1$q = ["href"];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppIcon = resolveComponent("AppIcon");
  return openBlock(), createElementBlock("a", {
    href: $props.link,
    class: "receipt-link",
    title: "View receipt",
    target: "_blank"
  }, [
    createVNode(_component_AppIcon, {
      icon: "monochrome/receipt.svg",
      size: $props.size
    }, null, 8, ["size"])
  ], 8, _hoisted_1$q);
}
const ReceiptLink = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$o], ["__scopeId", "data-v-2b512bad"]]);
const _hoisted_1$p = { class: "open-orders-wrapper" };
const _hoisted_2$m = { class: "open-orders__order" };
const _hoisted_3$j = { class: "flex--direction-column" };
const _hoisted_4$i = { "test-id": "open-order__type" };
const _hoisted_5$f = { "test-id": "open-order__side" };
const _hoisted_6$e = ["href", "title", "onClick"];
const _hoisted_7$c = {
  key: 0,
  class: "flex flex--direction-column flex--gap-tiny flex--justify-center"
};
const _hoisted_8$c = { class: "flex flex--direction-row flex--gap-small" };
const _hoisted_9$a = ["title"];
const _hoisted_10$a = { key: 0 };
const _hoisted_11$9 = ["onClick"];
const _hoisted_12$7 = { class: "flex flex--direction-column" };
const _hoisted_13$7 = { class: "tooltip-info-indicator" };
const _hoisted_14$7 = ["onClick"];
const _hoisted_15$7 = { class: "table-layout__text--bright-text" };
const _hoisted_16$7 = {
  key: 0,
  class: "flex flex--direction-column"
};
const _hoisted_17$7 = { class: "table-layout__text--bright-text" };
const _hoisted_18$6 = ["title"];
const _hoisted_19$5 = { key: 0 };
const _hoisted_20$5 = {
  key: 1,
  title: "Good 'til canceled"
};
const _hoisted_21$5 = { "test-id": "open-order__margin-mode" };
const _hoisted_22$5 = { "test-id": "open-order__leverage" };
const _hoisted_23$3 = { class: "flex flex--align-center flex--justify-end flex--gap-tiny" };
const _hoisted_24$3 = ["onClick"];
const _hoisted_25$3 = { class: "mb4" };
const ORDERS_DISPLAYED_STEP = 100;
const _sfc_main$v = {
  __name: "OpenOrders",
  props: {
    activeTab: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const { setActiveMarket } = useSetActiveMarket();
    const tradeviewTriggerValueStore = useTradeviewTriggerValueStore();
    const tradeviewPrivateOrdersStore = useTradeviewPrivateOrdersStore();
    const activeMarketStore = useActiveMarketStore();
    const maxOrdersDisplayed = ref(ORDERS_DISPLAYED_STEP);
    const areOrdersForAllMarketsShown = computed(() => {
      return props.activeTab === constants.MARKET_FILTER.ALL;
    });
    const activeMarketOrders = computed(() => {
      return tradeviewPrivateOrdersStore.openOrdersForActiveMarket;
    });
    const ordersToShow = computed(() => {
      return (areOrdersForAllMarketsShown.value ? tradeviewPrivateOrdersStore.openOrdersForActiveMarketType : activeMarketOrders.value).slice(0, maxOrdersDisplayed.value);
    });
    const { formatOrder } = useOrderFormatter();
    const formattedOrders = computed(() => {
      const orders = ordersToShow.value.map(formatOrder);
      return _.uniqBy(orders, "id");
    });
    const isDisplayingAnActiveTrailingOrder = computed(() => {
      if (activeMarketStore.isSpot) {
        return false;
      }
      for (const order of ordersToShow.value) {
        if (order.status === constants$1.ORDER_STATUS.ACTIVE && constants$1.TRAILING_TYPES.includes(order.type)) {
          return true;
        }
      }
      return false;
    });
    const tradeviewTickersStore = useTradeviewTickersStore();
    const tickerPricesForActiveTrailingOrders = computed(() => {
      if (!isDisplayingAnActiveTrailingOrder.value) {
        return {};
      }
      const prices = {};
      for (const order of ordersToShow.value) {
        prices[order.market] = tradeviewTickersStore.getTicker(order.market).last;
      }
      return prices;
    });
    const throttledOpenOrdersFetcher = _.throttle(
      function() {
        tradeviewPrivateOrdersStore.fetchOpenOrders();
      },
      1e3,
      // We delay updating, so the backend system can have some time to update open orders.
      {
        leading: false,
        trailing: true
      }
    );
    watch(tickerPricesForActiveTrailingOrders, (newPrices, oldPrices) => {
      if (!isDisplayingAnActiveTrailingOrder.value || !newPrices || !oldPrices) {
        return;
      }
      for (const market of Object.keys(newPrices)) {
        if (!newPrices[market].eq(oldPrices[market] ?? 0)) {
          throttledOpenOrdersFetcher();
          return;
        }
      }
    });
    function onScrolledToBottom() {
      const ordersToCheck = areOrdersForAllMarketsShown.value ? tradeviewPrivateOrdersStore.openOrdersForActiveMarketType : activeMarketOrders.value;
      if (ordersToCheck.length > maxOrdersDisplayed.value) {
        maxOrdersDisplayed.value += ORDERS_DISPLAYED_STEP;
      }
    }
    const marketsStore = useMarketsStore();
    const hasAccessToPerpMarkets = computed(() => {
      return Object.keys(marketsStore.perpetualMarkets).length > 0;
    });
    function deleteOrder(order) {
      tradeviewPrivateOrdersStore.cancelOrder(order.id, order.type);
    }
    const isCancelAllVisible = computed(() => {
      return tradeviewPrivateOrdersStore.openOrdersForAllMarkets.length > 0;
    });
    const isModalOpen = ref(false);
    function closeModal() {
      isModalOpen.value = false;
    }
    const subAccountStore = useSubAccountStore();
    function cancelAllOrders() {
      closeModal();
      if (areOrdersForAllMarketsShown.value) {
        tradeviewPrivateOrdersStore.cancelAllOrders(subAccountStore.activeSubAccountId);
      } else {
        tradeviewPrivateOrdersStore.cancelAllOrdersForMarket(
          subAccountStore.activeSubAccountId,
          activeMarketStore.activeMarketKey
        );
      }
    }
    const columnDefinitions = [
      { title: "Order", slotKey: "order", stickyLeft: true },
      { title: "Order time", slotKey: "datetime", textAlignRight: true },
      { title: "Price", slotKey: "price", textAlignRight: true },
      { title: "Filled / Amount", slotKey: "amount", textAlignRight: true },
      { title: "Filled / Value", slotKey: "value", textAlignRight: true },
      { title: "Trigger", slotKey: "trigger", textAlignRight: true },
      {
        title: "Status",
        slotKey: "status",
        tooltip: "Open: An order which has been placed to the Order Book.\n\n Active: A stop order tracking price and ready to trigger. \n\n Inactive: A trailing order whose activation price has not been reached yet."
      },
      { title: "Reduce only", slotKey: "reduceOnly" },
      { title: "TIF", slotKey: "tif" },
      { title: "", slotKey: "actions", textAlignCenter: true, stickyRight: true }
    ];
    const spotColumns = ["order", "datetime", "price", "amount", "value", "tif", "trigger", "actions"];
    const perpetualColumns = ["order", "datetime", "price", "amount", "value", "reduceOnly", "status", "trigger", "tif", "actions"];
    const columns = computed(() => {
      const includedColumns = activeMarketStore.isPerpetual ? perpetualColumns : spotColumns;
      return columnDefinitions.filter((c) => includedColumns.includes(c.slotKey));
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        (openBlock(), createBlock(unref(TableLayout), {
          key: areOrdersForAllMarketsShown.value,
          items: formattedOrders.value,
          columns: columns.value,
          class: "open-orders",
          onYEndReached: onScrolledToBottom
        }, {
          order: withCtx(({ item }) => [
            createBaseVNode("span", {
              class: normalizeClass(["table-layout__strip", {
                "table-layout__strip--buy": item.side === unref(constants$1).ORDER_SIDE.BUY,
                "table-layout__strip--sell": item.side === unref(constants$1).ORDER_SIDE.SELL
              }])
            }, null, 2),
            _cache[6] || (_cache[6] = createTextVNode()),
            createBaseVNode("div", _hoisted_2$m, [
              createBaseVNode("div", _hoisted_3$j, [
                createBaseVNode("div", {
                  class: normalizeClass({
                    "table-layout__text--buy": item.side === unref(constants$1).ORDER_SIDE.BUY,
                    "table-layout__text--sell": item.side === unref(constants$1).ORDER_SIDE.SELL
                  })
                }, [
                  createBaseVNode("span", _hoisted_4$i, toDisplayString(item.typeDisplay), 1),
                  _cache[2] || (_cache[2] = createTextVNode()),
                  createBaseVNode("span", _hoisted_5$f, toDisplayString(item.side === "buy" ? "Buy" : "Sell"), 1)
                ], 2),
                _cache[3] || (_cache[3] = createTextVNode()),
                createBaseVNode("a", {
                  href: item.marketLink,
                  title: `Change active market to ${item.marketName}`,
                  class: "table-layout__text--link",
                  "test-id": "open-order__market",
                  onClick: withModifiers(($event) => unref(setActiveMarket)(item.marketKey), ["prevent"])
                }, toDisplayString(item.marketName), 9, _hoisted_6$e)
              ]),
              _cache[5] || (_cache[5] = createTextVNode()),
              item.isPerpetual ? (openBlock(), createElementBlock("div", _hoisted_7$c, [
                createBaseVNode("div", _hoisted_8$c, [
                  createVNode(unref(MarginSettingTag), {
                    "test-id": "open-order__leverage",
                    text: `${item.leverage}x`
                  }, null, 8, ["text"]),
                  _cache[4] || (_cache[4] = createTextVNode()),
                  createVNode(unref(MarginSettingTag), {
                    "test-id": "open-order__margin-mode",
                    text: item.marginMode
                  }, null, 8, ["text"])
                ])
              ])) : createCommentVNode("", true)
            ])
          ]),
          datetime: withCtx(({ item }) => [
            createBaseVNode("div", {
              title: `Order placed on ${item.tooltipDatetime}`,
              class: "flex flex--direction-column"
            }, [
              createBaseVNode("span", null, toDisplayString(item.time), 1),
              _cache[7] || (_cache[7] = createTextVNode()),
              createBaseVNode("small", null, toDisplayString(item.date), 1)
            ], 8, _hoisted_9$a)
          ]),
          price: withCtx(({ item }) => [
            item.price === null ? (openBlock(), createElementBlock("span", _hoisted_10$a, "/")) : (openBlock(), createElementBlock("span", {
              key: 1,
              title: "Fill order form with this price",
              "data-test": "openOrderPrice",
              class: "table-layout__text--bright-text table-layout__text--clickable",
              onClick: ($event) => unref(tradeviewTriggerValueStore).setPriceSetByTrigger(item.priceToFillForm)
            }, toDisplayString(item.price), 9, _hoisted_11$9))
          ]),
          amount: withCtx(({ item }) => [
            createBaseVNode("div", _hoisted_12$7, [
              createBaseVNode("div", null, [
                item.filledProgress && item.filledProgress > 0 ? (openBlock(), createBlock(unref(AppTooltip), { key: 0 }, {
                  trigger: withCtx(() => [
                    createBaseVNode("div", _hoisted_13$7, "\n                  (" + toDisplayString(item.filledProgress) + "%) " + toDisplayString(item.formattedAmountFilled) + " " + toDisplayString(item.amountCurrency), 1)
                  ]),
                  default: withCtx(() => [
                    _cache[8] || (_cache[8] = createTextVNode("\n              Remaining:\n              ")),
                    createBaseVNode("a", {
                      href: "#",
                      title: "Fill form with this amount",
                      onClick: ($event) => unref(tradeviewTriggerValueStore).setAmountSetByTrigger(item.amountRemaining)
                    }, toDisplayString(item.formattedAmountRemaining), 9, _hoisted_14$7),
                    createTextVNode(" " + toDisplayString(item.amountCurrency), 1)
                  ]),
                  _: 2
                }, 1024)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createBaseVNode("span", null, toDisplayString(item.formattedAmountFilled), 1),
                  _cache[9] || (_cache[9] = createTextVNode()),
                  createBaseVNode("span", null, toDisplayString(item.amountCurrency), 1)
                ], 64))
              ]),
              _cache[11] || (_cache[11] = createTextVNode()),
              createBaseVNode("div", null, [
                createBaseVNode("span", _hoisted_15$7, toDisplayString(item.formattedAmountAtCreate), 1),
                _cache[10] || (_cache[10] = createTextVNode()),
                createBaseVNode("span", null, toDisplayString(item.amountCurrency), 1)
              ])
            ])
          ]),
          value: withCtx(({ item }) => [
            item.formattedEstimatedValueAtCreate ? (openBlock(), createElementBlock("div", _hoisted_16$7, [
              createBaseVNode("div", null, [
                item.estimatedValueFilled.isPositive() ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode("\n              ≈\n            ")
                ], 64)) : createCommentVNode("", true),
                _cache[12] || (_cache[12] = createTextVNode()),
                createBaseVNode("span", null, toDisplayString(item.formattedEstimatedValueFilled), 1),
                createTextVNode(" " + toDisplayString(item.counter), 1)
              ]),
              _cache[14] || (_cache[14] = createTextVNode()),
              createBaseVNode("div", null, [
                _cache[13] || (_cache[13] = createTextVNode("\n            ≈ ")),
                createBaseVNode("span", _hoisted_17$7, toDisplayString(item.formattedEstimatedValueAtCreate), 1),
                createTextVNode(" " + toDisplayString(item.counter), 1)
              ])
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode("\n          /\n        ")
            ], 64))
          ]),
          status: withCtx(({ item }) => [
            createTextVNode(toDisplayString(item.statusDisplay), 1)
          ]),
          reduceOnly: withCtx(({ item }) => [
            createTextVNode(toDisplayString(item.reduceOnly ? "Yes" : "No"), 1)
          ]),
          tif: withCtx(({ item }) => [
            item.tif ? (openBlock(), createElementBlock("span", {
              key: 0,
              title: item.expireTime ? item.expireTimeTitle : ""
            }, [
              createBaseVNode("span", {
                class: normalizeClass({
                  "table-layout__text--capitalize": item.tif === unref(constants$1).TIF.DAILY,
                  "table-layout__text--uppercase": item.tif !== unref(constants$1).TIF.DAILY
                })
              }, toDisplayString(item.tif), 3),
              _cache[16] || (_cache[16] = createTextVNode()),
              item.tif === unref(constants$1).TIF.GTD ? (openBlock(), createElementBlock("span", _hoisted_19$5, [
                _cache[15] || (_cache[15] = createBaseVNode("br", null, null, -1)),
                createTextVNode(toDisplayString(item.expireTime), 1)
              ])) : createCommentVNode("", true)
            ], 8, _hoisted_18$6)) : (openBlock(), createElementBlock("span", _hoisted_20$5, "\n          GTC\n        "))
          ]),
          trigger: withCtx(({ item }) => [
            createVNode(unref(OpenOrdersTriggerField), { order: item }, null, 8, ["order"])
          ]),
          marginMode: withCtx(({ item }) => [
            createBaseVNode("span", _hoisted_21$5, toDisplayString(item.marginMode), 1)
          ]),
          leverage: withCtx(({ item }) => [
            createBaseVNode("span", _hoisted_22$5, toDisplayString(item.leverage) + "x", 1)
          ]),
          "actions.header": withCtx(() => [
            isCancelAllVisible.value && _ctx.$has("trade_orders_cancel") ? (openBlock(), createElementBlock("span", {
              key: 0,
              title: "Cancel all orders",
              class: "open-orders__action open-orders__action--title",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => isModalOpen.value = true, ["stop"]))
            }, [
              createVNode(unref(AppIcon), {
                icon: "monochrome/close.svg",
                size: 12,
                "data-test": "cancelAllOpenOrders"
              })
            ])) : createCommentVNode("", true)
          ]),
          actions: withCtx(({ item }) => [
            createBaseVNode("div", _hoisted_23$3, [
              item.orderReceiptLink && !unref(constants$1).LEGACY_STOP_ORDER_TYPES.includes(item.type) ? (openBlock(), createBlock(unref(ReceiptLink), {
                key: 0,
                link: item.orderReceiptLink
              }, null, 8, ["link"])) : createCommentVNode("", true),
              _cache[17] || (_cache[17] = createTextVNode()),
              createBaseVNode("span", {
                title: "Cancel order",
                class: "open-orders__action",
                onClick: withModifiers(($event) => deleteOrder(item), ["stop"])
              }, [
                item.id && item.type !== unref(constants$1).ORDER_TYPE.INSTANT && item.type !== unref(constants$1).ORDER_TYPE.MARKET && _ctx.$has("trade_orders_cancel") ? (openBlock(), createBlock(unref(AppIcon), {
                  key: 0,
                  icon: "monochrome/close.svg",
                  size: 12,
                  "data-test": "cancelOpenOrder"
                })) : createCommentVNode("", true)
              ], 8, _hoisted_24$3)
            ])
          ]),
          empty: withCtx(() => [
            unref(tradeviewPrivateOrdersStore).initialized ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode("\n          No open orders available" + toDisplayString(areOrdersForAllMarketsShown.value ? "" : " for this market") + ".\n        ", 1)
            ], 64)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["items", "columns"])),
        _cache[40] || (_cache[40] = createTextVNode()),
        createVNode(unref(TradeviewModal), {
          "is-open": isModalOpen.value,
          "onUpdate:isOpen": _cache[1] || (_cache[1] = ($event) => isModalOpen.value = $event),
          "confirm-text": "Confirm",
          "cancel-text": "Cancel",
          onConfirm: cancelAllOrders
        }, {
          title: withCtx(() => [
            createTextVNode("\n        Cancel all " + toDisplayString(!areOrdersForAllMarketsShown.value ? `${unref(activeMarketStore).activeMarket.name} ` : "") + "open orders?\n      ", 1)
          ]),
          body: withCtx(() => [
            createBaseVNode("p", _hoisted_25$3, "\n          Are you sure you want to cancel all\n          " + toDisplayString(!areOrdersForAllMarketsShown.value ? `${unref(activeMarketStore).activeMarket.name} ` : "") + "open orders?\n        ", 1),
            _cache[38] || (_cache[38] = createTextVNode()),
            createBaseVNode("p", null, [
              createTextVNode("\n          This will cancel all open\n          " + toDisplayString(!areOrdersForAllMarketsShown.value ? `${unref(activeMarketStore).activeMarket.name} ` : "") + "orders\n          on " + toDisplayString(unref(subAccountStore).isMainActive ? "your" : "") + " ", 1),
              createBaseVNode("strong", null, toDisplayString(unref(subAccountStore).activeSubAccountDisplayName), 1),
              _cache[36] || (_cache[36] = createTextVNode()),
              areOrdersForAllMarketsShown.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _cache[31] || (_cache[31] = createTextVNode("\n            for ")),
                _cache[32] || (_cache[32] = createBaseVNode("strong", null, "All", -1)),
                _cache[33] || (_cache[33] = createTextVNode(" markets.\n          "))
              ], 64)) : createCommentVNode("", true),
              _cache[37] || (_cache[37] = createTextVNode()),
              hasAccessToPerpMarkets.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                _cache[34] || (_cache[34] = createBaseVNode("br", null, null, -1)),
                _cache[35] || (_cache[35] = createTextVNode("This includes both Spot and Perpetual markets.\n          "))
              ], 64)) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 8, ["is-open"])
      ]);
    };
  }
};
const OpenOrders = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-fcbdb95e"]]);
function parseCollateralChangeImpact(data) {
  return {
    estimatedLiquidationPrice: toDecimal(data.elp),
    imr: toDecimal(data.imr),
    mmr: toDecimal(data.mmr)
  };
}
function parseMinMaxCollateral(data) {
  return {
    min: toDecimal(data.min),
    max: toDecimal(data.max)
  };
}
const adjustCollateralAPI = {
  /**
   * Fetch min and max collateral for a market depending on user's current open positions, orders, margin etc.
   *
   * @param {string} market - btcusd-perp
   * @param {'main'|number} account - accountId
   * @returns {Promise<{min: module:numberUtils.Decimal, max: module:numberUtils.Decimal}>}
   */
  getMinMaxCollateral(market, account) {
    const url = URLService.buildUrl("minMaxCollateralResource", { "unique_id": account, market });
    return axiosInstance.get(url).then((data) => parseMinMaxCollateral(data.data.data));
  },
  /**
   * Fetch impact preview of collateral change
   *
   * @param {string} newCollateral
   * @param {string} market - btcusd-perp
   * @param {'main'|number} account - accountId
   * @returns {Promise<{epl: module:numberUtils.Decimal, imr: module:numberUtils.Decimal, mmr: module:numberUtils.Decimal}>}
   */
  getCollateralChangeImpact(newCollateral, market, account) {
    const url = URLService.buildUrl("collateralChangeImpactResource", { "unique_id": account, market }, true, {
      "new_amount": newCollateral
    });
    return axiosInstance.get(url).then((data) => parseCollateralChangeImpact(data.data.data));
  },
  /**
   * @param {string} newCollateral
   * @param {string} market - btcusd-perp
   * @param {'main'|number} account - accountId
   * @returns {Promise<void>}
   */
  adjustPositionCollateral(newCollateral, market, account) {
    const url = URLService.buildUrl("adjustCollateralResource", { "unique_id": account });
    return axiosInstance.post(url, { "new_amount": newCollateral, market });
  }
};
const _hoisted_1$o = {
  key: 0,
  class: "no-position-error"
};
const _hoisted_2$l = {
  key: 1,
  class: "adjust-collateral"
};
const _hoisted_3$i = { class: "adjust-collateral__text-top" };
const _hoisted_4$h = { class: "flex flex--gap-small" };
const _hoisted_5$e = { class: "adjust-collateral__market" };
const _hoisted_6$d = { class: "adjust-collateral__tag" };
const _hoisted_7$b = { class: "adjust-collateral__row" };
const _hoisted_8$b = { class: "adjust-collateral__row" };
const _hoisted_9$9 = { class: "adjust-collateral__group" };
const _hoisted_10$9 = { class: "adjust-collateral__row adjust-collateral__row--margin-bottom" };
const _hoisted_11$8 = { class: "preview" };
const _hoisted_12$6 = { class: "adjust-collateral__row" };
const _hoisted_13$6 = {
  class: "adjust-collateral__value",
  "test-id": "post-collateral-adjustment-available"
};
const _hoisted_14$6 = { class: "adjust-collateral__row" };
const _hoisted_15$6 = {
  class: "adjust-collateral__value",
  "test-id": "post-collateral-adjustment-imr"
};
const _hoisted_16$6 = { class: "adjust-collateral__row" };
const _hoisted_17$6 = {
  class: "adjust-collateral__value",
  "test-id": "post-collateral-adjustment-mmr"
};
const _hoisted_18$5 = { class: "adjust-collateral__row" };
const _hoisted_19$4 = {
  class: "adjust-collateral__value",
  "test-id": "post-collateral-adjustment-elp"
};
const _hoisted_20$4 = { class: "adjust-collateral__row" };
const _hoisted_21$4 = {
  class: "adjust-collateral__value",
  "test-id": "post-collateral-adjustment-delta"
};
const _hoisted_22$4 = {
  key: 0,
  class: "error"
};
const _sfc_main$u = {
  __name: "AdjustCollateralModal",
  props: {
    market: {
      type: String,
      required: true
    }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const marketsStore = useMarketsStore();
    const subAccountStore = useSubAccountStore();
    const tradeviewOpenPositionsStore = useTradeviewOpenPositionsStore();
    const tradeviewMarginInfoStore = useTradeviewMarginInfoStore();
    const toastStore = useToastStore();
    const balancesStore = useBalancesStore();
    const min = ref(1);
    const max = ref(200);
    const isChangeRequestInFlight = ref(false);
    const isAdjustmentUnavailable = ref(false);
    const postAdjustmentLiqPrice = ref(null);
    const postAdjustmentIMr = ref(null);
    const postAdjustmentMMr = ref(null);
    const position = computed(() => {
      return tradeviewOpenPositionsStore.openPositions.filter(
        (p) => p.market === props.market && p.marginMode === constants$1.MARGIN_MODE.ISOLATED
      )[0];
    });
    const positionCollateralAsNumber = computed(() => position.value.collateral.toNumber());
    const marks = computed(() => [min.value, positionCollateralAsNumber.value, max.value]);
    const formattedPosition = computed(() => {
      return tradeviewOpenPositionsStore.formattedOpenPositions.filter(
        (p) => p.market === props.market && p.marginMode === constants$1.MARGIN_MODE.ISOLATED
      )[0];
    });
    const collateralCurrency = computed(() => {
      return position.value.collateralCurrency;
    });
    const collateralCurrencyDecimals = computed(() => {
      return CURRENCIES[collateralCurrency.value].decimals;
    });
    const interval = computed(() => {
      return 10 ** (-1 * collateralCurrencyDecimals.value);
    });
    const validationSchema = computed(() => {
      return {
        amount: {
          required: true,
          decimal: { decimals: collateralCurrencyDecimals.value },
          min_value: min.value,
          max_value: max.value
        }
      };
    });
    const { meta, defineField, errors } = useForm({ validationSchema });
    const [amount] = defineField("amount");
    amount.value = "0";
    const amountAsNumber = computed(() => {
      return toDecimal(amount.value).toNumber();
    });
    const delta = computed(() => {
      return toDecimal(amount.value).sub(position.value.collateral);
    });
    const deltaFormatted = computed(() => {
      return `${delta.value.isPositive() ? "+" : ""}${numberFormatter.decimal({
        value: delta.value,
        decimals: collateralCurrencyDecimals.value
      })}`;
    });
    const minFormatted = computed(() => {
      return numberFormatter.decimal({
        value: min.value,
        decimals: collateralCurrencyDecimals.value
      });
    });
    const maxFormatted = computed(() => {
      return numberFormatter.decimal({
        value: max.value,
        decimals: collateralCurrencyDecimals.value
      });
    });
    const postAdjustmentAvailableCollateralFormatted = computed(() => {
      var _a2, _b;
      const available = ((_b = (_a2 = tradeviewMarginInfoStore.marginPerCurrency) == null ? void 0 : _a2[collateralCurrency.value]) == null ? void 0 : _b.available) ?? toDecimal(0);
      return numberFormatter.decimal({
        value: available.add(delta.value),
        decimals: collateralCurrencyDecimals.value
      });
    });
    const postAdjustmentLiqPriceFormatted = computed(() => {
      if (!postAdjustmentLiqPrice.value) {
        return "";
      }
      return numberFormatter.decimal({
        value: postAdjustmentLiqPrice.value,
        decimals: marketsStore.getMarket(props.market).decimals.counter
      });
    });
    function setNewAmount(newAmount) {
      amount.value = `${newAmount}`;
    }
    const finishedReloadingInput = ref(false);
    const lastAmountImpactWasFetchedFor = ref(null);
    const isImpactLoading = computed(() => {
      if (!amount.value || !finishedReloadingInput.value) {
        return false;
      }
      return `${amount.value}` !== lastAmountImpactWasFetchedFor.value;
    });
    async function fetchCollateralChangeImpact() {
      try {
        if (!amount.value || !finishedReloadingInput.value) {
          return;
        }
        const payloadAmount = `${amount.value}`;
        const { estimatedLiquidationPrice, mmr, imr } = await adjustCollateralAPI.getCollateralChangeImpact(
          payloadAmount,
          props.market,
          subAccountStore.activeSubAccountId
        );
        postAdjustmentLiqPrice.value = estimatedLiquidationPrice;
        postAdjustmentMMr.value = `${numberFormatter.decimal({
          value: (mmr == null ? void 0 : mmr.mul(100)) ?? 0,
          decimals: 2
        })}%`;
        postAdjustmentIMr.value = `${numberFormatter.decimal({
          value: (imr == null ? void 0 : imr.mul(100)) ?? 0,
          decimals: 2
        })}%`;
        lastAmountImpactWasFetchedFor.value = payloadAmount;
      } catch (e) {
        trackException(e);
      }
    }
    const throttledFetchCollateralChangeImpact = _.throttle(fetchCollateralChangeImpact, 500);
    let pollingInterval = null;
    const initialized = ref(false);
    async function fetchMinMaxCollateral() {
      try {
        const response = await adjustCollateralAPI.getMinMaxCollateral(
          props.market,
          subAccountStore.activeSubAccountId
        );
        min.value = toDecimal(response.min).todp(collateralCurrencyDecimals.value).toNumber();
        max.value = toDecimal(response.max).todp(collateralCurrencyDecimals.value).toNumber();
        isAdjustmentUnavailable.value = false;
      } catch (e) {
        trackException(e);
        isAdjustmentUnavailable.value = true;
      }
    }
    onBeforeMount(async () => {
      await fetchMinMaxCollateral();
      initialized.value = true;
      pollingInterval = setInterval(async () => {
        if (position.value) {
          await Promise.all([fetchMinMaxCollateral(), throttledFetchCollateralChangeImpact()]);
        }
      }, 15e3);
    });
    onMounted(() => {
      setTimeout(() => {
        finishedReloadingInput.value = true;
        amount.value = position.value.collateral.toFixed(collateralCurrencyDecimals.value);
        fetchCollateralChangeImpact();
      }, 100);
    });
    onBeforeUnmount(() => {
      clearInterval(pollingInterval);
    });
    function onUpdateFromSlider(newAmount) {
      amount.value = `${newAmount}`;
      throttledFetchCollateralChangeImpact();
    }
    function closeModal() {
      emit("close");
    }
    async function onConfirm() {
      isChangeRequestInFlight.value = true;
      try {
        await adjustCollateralAPI.adjustPositionCollateral(
          amount.value,
          props.market,
          subAccountStore.activeSubAccountId
        );
        const amountFormatted = numberFormatter.decimal({
          value: amount.value,
          decimals: collateralCurrencyDecimals.value
        });
        toastStore.showSuccessToast(
          `${formattedPosition.value.marketName} ${formattedPosition.value.marginModeDisplay} collateral changed to ${amountFormatted} ${collateralCurrency.value}.`
        );
        tradeviewOpenPositionsStore.fetchOpenPositions();
        balancesStore.fetch();
      } catch (e) {
        return;
      } finally {
        isChangeRequestInFlight.value = false;
      }
      closeModal();
    }
    return (_ctx, _cache) => {
      return initialized.value ? (openBlock(), createBlock(unref(TradeviewModal), {
        key: 0,
        "is-open": "",
        title: "Adjust collateral",
        "cancel-text": "Cancel",
        "confirm-text": !position.value ? void 0 : "Confirm",
        "confirm-disabled": !unref(meta).valid || isChangeRequestInFlight.value || isAdjustmentUnavailable.value,
        "modal-style": !position.value ? "error" : void 0,
        onClose: closeModal,
        onConfirm
      }, {
        body: withCtx(() => [
          !position.value ? (openBlock(), createElementBlock("div", _hoisted_1$o, "\n        Position is no longer available.\n      ")) : (openBlock(), createElementBlock("div", _hoisted_2$l, [
            createBaseVNode("div", _hoisted_3$i, [
              createBaseVNode("div", _hoisted_4$h, [
                createVNode(unref(CurrencyIcon), {
                  currency: formattedPosition.value.baseCurrency,
                  size: "18"
                }, null, 8, ["currency"]),
                _cache[3] || (_cache[3] = createTextVNode()),
                createBaseVNode("span", _hoisted_5$e, toDisplayString(formattedPosition.value.marketName), 1),
                _cache[4] || (_cache[4] = createTextVNode()),
                createBaseVNode("div", _hoisted_6$d, toDisplayString(formattedPosition.value.marginModeDisplay), 1)
              ])
            ]),
            _cache[27] || (_cache[27] = createTextVNode()),
            createBaseVNode("div", _hoisted_7$b, [
              _cache[5] || (_cache[5] = createBaseVNode("span", null, "PNL", -1)),
              _cache[6] || (_cache[6] = createTextVNode()),
              createBaseVNode("span", {
                class: normalizeClass({
                  "adjust-collateral__positive": formattedPosition.value.isPnlPositive,
                  "adjust-collateral__negative": !formattedPosition.value.isPnlPositive
                })
              }, toDisplayString(formattedPosition.value.pnl) + " " + toDisplayString(formattedPosition.value.settlementCurrency), 3)
            ]),
            _cache[28] || (_cache[28] = createTextVNode()),
            createBaseVNode("div", _hoisted_8$b, [
              _cache[7] || (_cache[7] = createBaseVNode("span", null, "Current position collateral", -1)),
              _cache[8] || (_cache[8] = createTextVNode()),
              createBaseVNode("span", null, toDisplayString(formattedPosition.value.collateral) + " " + toDisplayString(formattedPosition.value.collateralCurrency), 1)
            ]),
            _cache[29] || (_cache[29] = createTextVNode()),
            createBaseVNode("div", _hoisted_9$9, [
              createVNode(unref(OrderInputWithValidation), {
                modelValue: unref(amount),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(amount) ? amount.value = $event : null),
                disabled: isChangeRequestInFlight.value || isAdjustmentUnavailable.value,
                "inline-label": position.value.collateralCurrency,
                "custom-error-message": unref(errors).amount,
                label: "New collateral",
                class: "value-input",
                field: "amount",
                "test-id": "margin-adjustment-input"
              }, null, 8, ["modelValue", "disabled", "inline-label", "custom-error-message"])
            ]),
            _cache[30] || (_cache[30] = createTextVNode()),
            createVNode(unref(OrderSlider), {
              value: amountAsNumber.value,
              min: min.value,
              max: max.value,
              "slider-interval": interval.value,
              marks: marks.value,
              disabled: isChangeRequestInFlight.value || isAdjustmentUnavailable.value,
              "pre-change-marker-value": positionCollateralAsNumber.value,
              silent: "",
              "onUpdate:value": onUpdateFromSlider
            }, null, 8, ["value", "min", "max", "slider-interval", "marks", "disabled", "pre-change-marker-value"]),
            _cache[31] || (_cache[31] = createTextVNode()),
            createBaseVNode("div", _hoisted_10$9, [
              createBaseVNode("div", null, [
                _cache[9] || (_cache[9] = createBaseVNode("span", null, "Min:", -1)),
                _cache[10] || (_cache[10] = createTextVNode()),
                createBaseVNode("span", {
                  class: "adjust-collateral__action",
                  "test-id": "collateral-adjustment-min",
                  onClick: _cache[1] || (_cache[1] = ($event) => setNewAmount(min.value))
                }, toDisplayString(minFormatted.value) + " " + toDisplayString(position.value.collateralCurrency), 1)
              ]),
              _cache[13] || (_cache[13] = createTextVNode()),
              createBaseVNode("div", null, [
                _cache[11] || (_cache[11] = createBaseVNode("span", null, "Max:", -1)),
                _cache[12] || (_cache[12] = createTextVNode()),
                createBaseVNode("span", {
                  class: "adjust-collateral__action",
                  "test-id": "collateral-adjustment-max",
                  onClick: _cache[2] || (_cache[2] = ($event) => setNewAmount(max.value))
                }, toDisplayString(maxFormatted.value) + " " + toDisplayString(position.value.collateralCurrency), 1)
              ])
            ]),
            _cache[32] || (_cache[32] = createTextVNode()),
            createBaseVNode("div", _hoisted_11$8, [
              _cache[20] || (_cache[20] = createBaseVNode("div", { class: "adjust-collateral__row" }, [
                createBaseVNode("strong", null, "Post adjustment preview")
              ], -1)),
              _cache[21] || (_cache[21] = createTextVNode()),
              createBaseVNode("div", _hoisted_12$6, [
                _cache[14] || (_cache[14] = createTextVNode("\n            Available collateral\n            ")),
                createBaseVNode("div", _hoisted_13$6, [
                  isImpactLoading.value ? (openBlock(), createBlock(unref(SpinnerInButton), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(postAdjustmentAvailableCollateralFormatted.value) + " " + toDisplayString(collateralCurrency.value), 1)
                  ], 64))
                ])
              ]),
              _cache[22] || (_cache[22] = createTextVNode()),
              createBaseVNode("div", _hoisted_14$6, [
                _cache[15] || (_cache[15] = createTextVNode("\n            IMr\n            ")),
                createBaseVNode("div", _hoisted_15$6, [
                  isImpactLoading.value ? (openBlock(), createBlock(unref(SpinnerInButton), { key: 0 })) : postAdjustmentIMr.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(postAdjustmentIMr.value), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createTextVNode("\n                /\n              ")
                  ], 64))
                ])
              ]),
              _cache[23] || (_cache[23] = createTextVNode()),
              createBaseVNode("div", _hoisted_16$6, [
                _cache[16] || (_cache[16] = createTextVNode("\n            MMr\n            ")),
                createBaseVNode("div", _hoisted_17$6, [
                  isImpactLoading.value ? (openBlock(), createBlock(unref(SpinnerInButton), { key: 0 })) : postAdjustmentMMr.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(postAdjustmentMMr.value), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createTextVNode("\n                /\n              ")
                  ], 64))
                ])
              ]),
              _cache[24] || (_cache[24] = createTextVNode()),
              createBaseVNode("div", _hoisted_18$5, [
                _cache[18] || (_cache[18] = createTextVNode("\n            Est. liquidation price\n            ")),
                createBaseVNode("div", _hoisted_19$4, [
                  isImpactLoading.value ? (openBlock(), createBlock(unref(SpinnerInButton), { key: 0 })) : postAdjustmentLiqPrice.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createBaseVNode("span", null, toDisplayString(postAdjustmentLiqPriceFormatted.value), 1),
                    _cache[17] || (_cache[17] = createTextVNode()),
                    createBaseVNode("span", null, toDisplayString(formattedPosition.value.counterCurrency), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createTextVNode("\n                /\n              ")
                  ], 64))
                ])
              ]),
              _cache[25] || (_cache[25] = createTextVNode()),
              createBaseVNode("div", _hoisted_20$4, [
                _cache[19] || (_cache[19] = createTextVNode("\n            Collateral change\n            ")),
                createBaseVNode("div", _hoisted_21$4, [
                  delta.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(deltaFormatted.value) + " " + toDisplayString(collateralCurrency.value), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode("\n                /\n              ")
                  ], 64))
                ])
              ])
            ]),
            _cache[33] || (_cache[33] = createTextVNode()),
            isAdjustmentUnavailable.value ? (openBlock(), createElementBlock("div", _hoisted_22$4, _cache[26] || (_cache[26] = [
              createBaseVNode("strong", null, "Unable to adjust collateral at the moment. Please wait or try again later.", -1)
            ]))) : createCommentVNode("", true)
          ]))
        ]),
        _: 1
      }, 8, ["confirm-text", "confirm-disabled", "modal-style"])) : createCommentVNode("", true);
    };
  }
};
const AdjustCollateralModal = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-80d18d58"]]);
const _hoisted_1$n = { class: "change-leverage" };
const _hoisted_2$k = { class: "change-leverage__text-top" };
const _hoisted_3$h = { class: "flex flex--gap-small" };
const _hoisted_4$g = { class: "change-leverage__market" };
const _hoisted_5$d = { class: "change-leverage__tag" };
const _hoisted_6$c = { class: "change-leverage__group" };
const _hoisted_7$a = {
  key: 1,
  class: "error"
};
const _hoisted_8$a = {
  key: 2,
  class: "error"
};
const _sfc_main$t = {
  __name: "ChangeLeverageModal",
  props: {
    market: {
      type: String,
      required: true
    },
    marginMode: {
      type: String,
      required: true
    },
    currentLeverage: {
      type: Number,
      required: true
    }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const marketsStore = useMarketsStore();
    const tradeviewMarginSettingsStore = useTradeviewMarginSettingsStore();
    const subAccountStore = useSubAccountStore();
    const tradeviewPrivateOrdersStore = useTradeviewPrivateOrdersStore();
    const tradeviewOpenPositionsStore = useTradeviewOpenPositionsStore();
    const tradeviewOrderFormStore = useTradeviewOrderFormStore();
    const emit = __emit;
    const hasOpenOrders = computed(() => {
      return tradeviewPrivateOrdersStore.openOrdersForActiveMarketType.filter((o) => o.marginMode === props.marginMode).length > 0;
    });
    const initialized = ref(false);
    const isChangeRequestInFlight = ref(false);
    const isLeverageAdjustmentUnavailable = ref(false);
    const minLeverage = ref(1);
    const maxLeverage = ref(3);
    const isInputDisabled = computed(() => {
      return !initialized.value || isChangeRequestInFlight.value || isLeverageAdjustmentUnavailable.value || props.currentLeverage === minLeverage.value && minLeverage.value === maxLeverage.value || hasOpenOrders.value;
    });
    const currentLeverageScaledToRange = computed(() => {
      return Math.min(
        Math.max(
          props.currentLeverage,
          minLeverage.value
        ),
        maxLeverage.value
      );
    });
    const marks = computed(() => {
      return {
        [minLeverage.value]: `${minLeverage.value}x`,
        [maxLeverage.value]: `${maxLeverage.value}x`,
        [currentLeverageScaledToRange.value]: {
          label: `${currentLeverageScaledToRange.value}x`,
          labelStyle: {
            color: "var(--bts-tv-text-color-bright)"
          }
        }
      };
    });
    const validationSchema = computed(() => {
      return {
        leverage: {
          required: true,
          decimal: { decimals: 2 },
          max_value: maxLeverage.value,
          min_value: minLeverage.value
        }
      };
    });
    const { meta, defineField, errors } = useForm({ validationSchema });
    const [newLeverage] = defineField("leverage");
    const marketMeta = computed(() => {
      return marketsStore.getMarket(props.market);
    });
    const isConfirmDisabled = computed(() => {
      return isInputDisabled.value || !meta.value.valid;
    });
    function onUpdateFromSlider(newValue) {
      newLeverage.value = `${newValue}`;
    }
    async function fetchMinMaxLeverage() {
      try {
        const { min, max } = await minMaxLeverageAPI.getMinMaxLeverage(
          props.market,
          subAccountStore.activeSubAccountId,
          props.marginMode
        );
        minLeverage.value = min;
        maxLeverage.value = max;
        isLeverageAdjustmentUnavailable.value = false;
      } catch (e) {
        isLeverageAdjustmentUnavailable.value = true;
        trackException(e);
      }
    }
    let pollingInterval = null;
    onBeforeMount(async () => {
      await fetchMinMaxLeverage();
      pollingInterval = setInterval(fetchMinMaxLeverage, 15e3);
      newLeverage.value = `${currentLeverageScaledToRange.value}`;
      initialized.value = true;
    });
    onBeforeUnmount(() => {
      clearInterval(pollingInterval);
    });
    function closeModal() {
      emit("close");
    }
    async function onConfirm() {
      if (`${newLeverage.value}` === `${props.currentLeverage}`) {
        closeModal();
        return;
      }
      const marginModeParam = props.marginMode;
      const marketParam = props.market;
      const subAccountParam = subAccountStore.activeSubAccountId;
      const newLeverageParam = newLeverage.value;
      isChangeRequestInFlight.value = true;
      await tradeviewMarginSettingsStore.setLeverage(
        newLeverageParam,
        marginModeParam,
        marketParam,
        subAccountParam
      );
      tradeviewOrderFormStore.setOrderFormLeverage(
        marketParam,
        marginModeParam,
        subAccountParam,
        toDecimal(newLeverage).toNumber()
      );
      tradeviewOpenPositionsStore.fetchOpenPositions();
      isChangeRequestInFlight.value = false;
      closeModal();
    }
    const isSliderHidden = computed(() => {
      return minLeverage.value === maxLeverage.value;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(TradeviewModal), {
        "is-open": "",
        "cancel-text": "Cancel",
        "confirm-text": "Confirm",
        "confirm-disabled": isConfirmDisabled.value,
        onClose: closeModal,
        onConfirm
      }, {
        title: withCtx(() => _cache[1] || (_cache[1] = [
          createTextVNode("\n      Modify leverage for open position\n    ")
        ])),
        body: withCtx(() => [
          createBaseVNode("div", _hoisted_1$n, [
            createBaseVNode("div", _hoisted_2$k, [
              createBaseVNode("div", _hoisted_3$h, [
                createVNode(unref(CurrencyIcon), {
                  currency: marketMeta.value.base,
                  size: "18"
                }, null, 8, ["currency"]),
                _cache[2] || (_cache[2] = createTextVNode()),
                createBaseVNode("span", _hoisted_4$g, toDisplayString(marketMeta.value.name), 1),
                _cache[3] || (_cache[3] = createTextVNode()),
                createBaseVNode("div", _hoisted_5$d, toDisplayString(__props.marginMode), 1)
              ])
            ]),
            _cache[6] || (_cache[6] = createTextVNode()),
            createBaseVNode("div", _hoisted_6$c, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Leverage", -1)),
              _cache[5] || (_cache[5] = createTextVNode()),
              createVNode(unref(OrderInputWithValidation), {
                modelValue: unref(newLeverage),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(newLeverage) ? newLeverage.value = $event : null),
                "custom-error-message": unref(errors).leverage,
                disabled: isInputDisabled.value,
                class: "value-input",
                field: "newLeverage"
              }, null, 8, ["modelValue", "custom-error-message", "disabled"])
            ]),
            _cache[7] || (_cache[7] = createTextVNode()),
            initialized.value && !isSliderHidden.value ? (openBlock(), createBlock(unref(OrderSlider), {
              key: 0,
              value: unref(newLeverage),
              min: minLeverage.value,
              max: maxLeverage.value,
              "slider-interval": 0.01,
              marks: marks.value,
              "hide-label": false,
              disabled: isInputDisabled.value,
              "pre-change-marker-value": currentLeverageScaledToRange.value,
              "onUpdate:value": onUpdateFromSlider
            }, null, 8, ["value", "min", "max", "marks", "disabled", "pre-change-marker-value"])) : createCommentVNode("", true),
            _cache[8] || (_cache[8] = createTextVNode()),
            isLeverageAdjustmentUnavailable.value ? (openBlock(), createElementBlock("div", _hoisted_7$a, "\n          Unable to adjust leverage at the moment. Please wait or try again later.\n        ")) : hasOpenOrders.value ? (openBlock(), createElementBlock("div", _hoisted_8$a, "\n          You can not adjust a position's leverage while you have open orders on the same market using the same margin mode.\n        ")) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["confirm-disabled"]);
    };
  }
};
const ChangeLeverageModal = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-e02030e5"]]);
const MODAL_TYPES = {
  CLOSE: "close",
  CLOSE_ALL: "closeAll"
};
const _sfc_main$s = {
  name: "OpenPositions",
  components: {
    MarginRatioStatusIndicator,
    ClosePositionModal,
    ChangeLeverageModal,
    CopyDataIconButton,
    MarginSettingTag,
    AdjustCollateralModal,
    TradeviewModal,
    TableLayout,
    AppIcon,
    AppTooltip
  },
  props: {
    activeTab: {
      type: String,
      required: true
    }
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      currenciesStore: useCurrenciesStore(),
      marketsStore: useMarketsStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore(),
      subAccountStore: useSubAccountStore(),
      toastStore: useToastStore(),
      ordersStore: useOrdersStore()
    };
  },
  data() {
    return {
      positionToClose: null,
      isCloseAllPositionsModalOpen: false,
      isClosePositionModalOpen: false,
      isAdjustCollateralModalOpen: false,
      isAdjustLeverageModalOpen: false,
      marketHavingCollateralAdjusted: null,
      marketHavingLeverageAdjusted: null,
      marginModeHavingLeverageAdjusted: null,
      currentLeverageBeingAdjusted: null,
      MODAL_TYPES
    };
  },
  computed: {
    isCloseAllVisible() {
      return this.tradeviewOpenPositionsStore.formattedOpenPositions.filter((p) => p.canClose).length > 0;
    },
    columns() {
      const settingsKeyMap = Object.groupBy(openPositionColumnDefinitions, ({ slotKey }) => slotKey);
      const configurableColumns = this.tradeviewSettingsStore.openPositionColumnSettings.filter((c) => c.active && settingsKeyMap[c.key]).map((c) => settingsKeyMap[c.key][0]);
      return [
        settingsKeyMap.market[0],
        ...configurableColumns,
        settingsKeyMap.actions[0]
      ];
    },
    formattedPositions() {
      const positions = this.tradeviewOpenPositionsStore.formattedOpenPositions.map((position) => {
        var _a2;
        const ticker = this.tradeviewTickersStore.getTicker(position.market);
        const market = this.marketsStore.getMarket(position.market);
        let markPriceAsDecimal = position.markPriceAsDecimal;
        if (((_a2 = this.activeMarketStore.activeMarket) == null ? void 0 : _a2.key) === position.market && ticker.markPrice) {
          markPriceAsDecimal = ticker.markPrice;
        }
        return {
          ...position,
          displayCollateral: position.marginMode === constants$1.MARGIN_MODE.ISOLATED,
          displayEquity: position.marginMode === constants$1.MARGIN_MODE.ISOLATED,
          markPrice: numberFormatter.decimal({
            value: markPriceAsDecimal,
            decimals: market.decimals.counter
          }),
          markPriceAsDecimal,
          isLiquidating: position.status === constants$1.POSITION_STATUS.LIQUIDATING,
          // For TableLayout.vue
          hasError: position.status === constants$1.POSITION_STATUS.LIQUIDATING
        };
      });
      if (this.activeTab === constants.MARKET_FILTER.CURRENT_MARKET) {
        return positions.filter((p) => p.market === this.activeMarketStore.activeMarket.key);
      }
      return positions;
    }
  },
  methods: {
    /**
     * @param {module:openPositionsStore.FormattedOpenPosition} position
     */
    openClosePositionModal(position) {
      this.positionToClose = position;
      this.isClosePositionModalOpen = true;
    },
    openAdjustLeverageModal(market, marginMode, leverage) {
      this.marketHavingLeverageAdjusted = market;
      this.marginModeHavingLeverageAdjusted = marginMode;
      this.currentLeverageBeingAdjusted = toDecimal(leverage).toNumber();
      this.isAdjustLeverageModalOpen = true;
    },
    onCloseAllPositions() {
      this.isCloseAllPositionsModalOpen = true;
    },
    async closeAllPositions() {
      this.isCloseAllPositionsModalOpen = false;
      try {
        await positionsApi.closeAllPositions(this.subAccountStore.activeSubAccountId, true);
        this.toastStore.showSuccessToast("Closed all positions on current account.");
      } catch (e) {
        this.toastStore.showErrorToast("Could not close positions.");
      }
      await this.cleanUpAfterClose();
    },
    async cleanUpAfterClose() {
      await Promise.all([
        this.tradeviewOpenPositionsStore.fetchOpenPositions(),
        this.ordersStore.fetchOpenOrders()
      ]);
    },
    openAdjustCollateralModal(marketKey) {
      this.marketHavingCollateralAdjusted = marketKey;
      this.isAdjustCollateralModalOpen = true;
    },
    closeAdjustCollateralModal() {
      this.isAdjustCollateralModalOpen = false;
      this.marketHavingCollateralAdjusted = null;
    }
  }
};
const _hoisted_1$m = { class: "positions-wrapper" };
const _hoisted_2$j = { class: "market" };
const _hoisted_3$g = { class: "column" };
const _hoisted_4$f = ["href", "title", "onClick"];
const _hoisted_5$c = { class: "market__type" };
const _hoisted_6$b = { class: "flex flex--direction-column flex--gap-tiny flex--justify-center" };
const _hoisted_7$9 = { class: "flex flex--direction-row flex--gap-small" };
const _hoisted_8$9 = {
  key: 0,
  "test-id": "open-position__liquidating",
  class: "liquidation-tag"
};
const _hoisted_9$8 = { "test-id": "open-position__value" };
const _hoisted_10$8 = { "test-id": "open-position__strike-price" };
const _hoisted_11$7 = ["onClick"];
const _hoisted_12$5 = { "test-id": "open-position__entry-price" };
const _hoisted_13$5 = { "test-id": "open-position__liq_price" };
const _hoisted_14$5 = { "test-id": "open-position__rspnl" };
const _hoisted_15$5 = { "test-id": "open-position__uspnl" };
const _hoisted_16$5 = { "test-id": "open-position__settled-pnl" };
const _hoisted_17$5 = { "test-id": "open-position__in-settlement-pnl" };
const _hoisted_18$4 = { class: "column" };
const _hoisted_19$3 = {
  class: "table-layout__text--small",
  "test-id": "open-position__pnl-percentage"
};
const _hoisted_20$3 = { class: "flex flex--align-center flex--gap-tiny flex--justify-end" };
const _hoisted_21$3 = { "test-id": "open-position__imr" };
const _hoisted_22$3 = { class: "flex flex--align-center flex--gap-tiny flex--justify-end" };
const _hoisted_23$2 = { "test-id": "open-position__mmr" };
const _hoisted_24$2 = {
  key: 0,
  class: "flex flex--justify-end"
};
const _hoisted_25$2 = { "test-id": "open-position__collateral" };
const _hoisted_26$2 = ["title", "onClick"];
const _hoisted_27$1 = {
  key: 1,
  "test-id": "open-position__collateral"
};
const _hoisted_28$1 = { "test-id": "open-position__im" };
const _hoisted_29$1 = { "test-id": "open-position__mm" };
const _hoisted_30$1 = {
  key: 0,
  "test-id": "open-position__equity"
};
const _hoisted_31$1 = { "test-id": "open-position__implied-leverage" };
const _hoisted_32$1 = { class: "copy-id" };
const _hoisted_33$1 = ["title"];
const _hoisted_34$1 = { class: "positions__actions" };
const _hoisted_35$1 = ["onClick"];
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MarginSettingTag = resolveComponent("MarginSettingTag");
  const _component_MarginRatioStatusIndicator = resolveComponent("MarginRatioStatusIndicator");
  const _component_AppIcon = resolveComponent("AppIcon");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_CopyDataIconButton = resolveComponent("CopyDataIconButton");
  const _component_TableLayout = resolveComponent("TableLayout");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  const _component_ClosePositionModal = resolveComponent("ClosePositionModal");
  const _component_AdjustCollateralModal = resolveComponent("AdjustCollateralModal");
  const _component_ChangeLeverageModal = resolveComponent("ChangeLeverageModal");
  return openBlock(), createElementBlock("div", _hoisted_1$m, [
    createVNode(_component_TableLayout, {
      items: $options.formattedPositions,
      columns: $options.columns,
      class: "positions",
      onAction: $options.onCloseAllPositions
    }, {
      market: withCtx(({ item }) => [
        createBaseVNode("span", {
          class: normalizeClass(["table-layout__strip", {
            "table-layout__strip--buy": item.isLong && !item.isLiquidating,
            "table-layout__strip--sell": !item.isLong && !item.isLiquidating
          }])
        }, null, 2),
        _cache[9] || (_cache[9] = createTextVNode()),
        createBaseVNode("div", _hoisted_2$j, [
          createBaseVNode("div", _hoisted_3$g, [
            createBaseVNode("a", {
              href: item.marketLink,
              title: `Change active market to ${item.marketName}`,
              class: "market__name",
              "test-id": "open-position__market",
              onClick: withModifiers(($event) => $setup.setActiveMarket(item.market), ["prevent"])
            }, toDisplayString(item.marketName), 9, _hoisted_4$f),
            _cache[5] || (_cache[5] = createTextVNode()),
            createBaseVNode("span", _hoisted_5$c, toDisplayString(item.marketTypeDisplay), 1)
          ]),
          _cache[8] || (_cache[8] = createTextVNode()),
          createBaseVNode("div", _hoisted_6$b, [
            createBaseVNode("div", _hoisted_7$9, [
              createVNode(_component_MarginSettingTag, {
                "test-id": "open-position__leverage",
                editable: !item.isLiquidating,
                text: `${item.leverage}x`,
                title: `Adjust leverage for your ${item.marginModeDisplay} ${item.marketName} position.`,
                onEdit: ($event) => $options.openAdjustLeverageModal(item.market, item.marginMode, item.leverage)
              }, null, 8, ["editable", "text", "title", "onEdit"]),
              _cache[6] || (_cache[6] = createTextVNode()),
              createVNode(_component_MarginSettingTag, {
                "test-id": "open-position__margin-mode",
                text: item.marginModeDisplay
              }, null, 8, ["text"])
            ]),
            _cache[7] || (_cache[7] = createTextVNode()),
            item.isLiquidating ? (openBlock(), createElementBlock("span", _hoisted_8$9, "\n              In Liquidation\n            ")) : createCommentVNode("", true)
          ])
        ])
      ]),
      amount: withCtx(({ item }) => [
        createBaseVNode("span", {
          class: normalizeClass({
            "table-layout__text--positive": item.isLong,
            "table-layout__text--negative": !item.isLong
          }),
          "test-id": "open-position__amount"
        }, toDisplayString(item.amount), 3)
      ]),
      value: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_9$8, toDisplayString(item.value) + " " + toDisplayString(item.settlementCurrency), 1)
      ]),
      strikePrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_10$8, toDisplayString(item.strikePrice), 1)
      ]),
      markPrice: withCtx(({ item }) => [
        createBaseVNode("span", {
          title: "Fill order form with mark price",
          class: "table-layout__text--bright-text table-layout__text--clickable",
          "test-id": "open-position__mark-price",
          onClick: ($event) => $setup.tradeviewTriggerValueStore.setPriceSetByTrigger(item.markPriceAsDecimal)
        }, toDisplayString(item.markPrice), 9, _hoisted_11$7)
      ]),
      entryPrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_12$5, toDisplayString(item.avgEntryPrice), 1)
      ]),
      estimatedLiquidationPrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_13$5, toDisplayString(item.estimatedLiquidationPrice), 1)
      ]),
      rsPnl: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_14$5, toDisplayString(item.rsPnl), 1)
      ]),
      usPnl: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_15$5, toDisplayString(item.usPnl), 1)
      ]),
      settledPnl: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_16$5, toDisplayString(item.settledPnl), 1)
      ]),
      inSettlementPnl: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_17$5, toDisplayString(item.inSettlementPnl), 1)
      ]),
      pnl: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_18$4, [
          createBaseVNode("span", {
            class: normalizeClass({
              "table-layout__text--positive": item.isPnlPositive,
              "table-layout__text--negative": !item.isPnlPositive
            }),
            "test-id": "open-position__pnl"
          }, toDisplayString(item.pnl) + " " + toDisplayString(item.settlementCurrency), 3),
          _cache[10] || (_cache[10] = createTextVNode()),
          createBaseVNode("span", _hoisted_19$3, toDisplayString(item.pnlPercentage), 1)
        ])
      ]),
      imr: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_20$3, [
          createVNode(_component_MarginRatioStatusIndicator, {
            percentage: item.initialMarginRatioAsDecimal
          }, null, 8, ["percentage"]),
          _cache[11] || (_cache[11] = createTextVNode()),
          createBaseVNode("span", _hoisted_21$3, toDisplayString(item.imr === null ? "n/a" : `${item.imr}%`), 1)
        ])
      ]),
      mmr: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_22$3, [
          createVNode(_component_MarginRatioStatusIndicator, {
            percentage: item.maintenanceMarginRatioAsDecimal
          }, null, 8, ["percentage"]),
          _cache[12] || (_cache[12] = createTextVNode()),
          createBaseVNode("span", _hoisted_23$2, toDisplayString(item.mmr === null ? "n/a" : `${item.mmr}%`), 1)
        ])
      ]),
      collateral: withCtx(({ item }) => [
        item.displayCollateral ? (openBlock(), createElementBlock("div", _hoisted_24$2, [
          createBaseVNode("span", _hoisted_25$2, toDisplayString(item.collateral) + " " + toDisplayString(item.collateralCurrency), 1),
          _cache[13] || (_cache[13] = createTextVNode()),
          item.canAdjustCollateral ? (openBlock(), createElementBlock("span", {
            key: 0,
            title: `Adjust collateral for your ${item.marginModeDisplay} ${item.marketName} position.`,
            class: "positions__action",
            onClick: withModifiers(($event) => $options.openAdjustCollateralModal(item.market), ["stop"])
          }, [
            createVNode(_component_AppIcon, {
              icon: "monochrome/edit-filled.svg",
              size: 12,
              "test-id": "open-position__adjust-collateral"
            })
          ], 8, _hoisted_26$2)) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("span", _hoisted_27$1, "\n          /\n        "))
      ]),
      im: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_28$1, toDisplayString(item.im) + " " + toDisplayString(item.collateralCurrency), 1)
      ]),
      mm: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_29$1, toDisplayString(item.mm) + " " + toDisplayString(item.collateralCurrency), 1)
      ]),
      equity: withCtx(({ item }) => [
        item.equity ? (openBlock(), createElementBlock("span", _hoisted_30$1, [
          item.displayEquity ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(item.equity) + " " + toDisplayString(item.settlementCurrency), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode("\n            /\n          ")
          ], 64))
        ])) : createCommentVNode("", true)
      ]),
      "strikePrice.header": withCtx(() => [
        createVNode(_component_AppTooltip, {
          strategy: "fixed",
          container: "#app"
        }, {
          trigger: withCtx(() => _cache[14] || (_cache[14] = [
            createBaseVNode("span", { class: "header-tooltip-trigger" }, "Strike price", -1)
          ])),
          default: withCtx(() => [
            _cache[15] || (_cache[15] = createTextVNode()),
            _cache[16] || (_cache[16] = createBaseVNode("span", { class: "header-tooltip-text" }, [
              createTextVNode("Entry price reflecting periodic settlement restrikes.\n            "),
              createBaseVNode("a", {
                href: "/docs/perpetuals-trading-information/#periodic-settlement",
                target: "_blank"
              }, "Read more about it.")
            ], -1))
          ]),
          _: 1
        })
      ]),
      "entryPrice.header": withCtx(() => [
        createVNode(_component_AppTooltip, {
          strategy: "fixed",
          container: "#app"
        }, {
          trigger: withCtx(() => _cache[17] || (_cache[17] = [
            createBaseVNode("span", { class: "header-tooltip-trigger" }, "Entry price", -1)
          ])),
          default: withCtx(() => [
            _cache[18] || (_cache[18] = createTextVNode()),
            _cache[19] || (_cache[19] = createBaseVNode("span", { class: "header-tooltip-text" }, [
              createTextVNode("Average Entry Price.\n            "),
              createBaseVNode("a", {
                href: "/docs/perpetuals-trading-information/#periodic-settlement",
                target: "_blank"
              }, "Read more about it.")
            ], -1))
          ]),
          _: 1
        })
      ]),
      "actions.header": withCtx(() => [
        $options.isCloseAllVisible ? (openBlock(), createElementBlock("span", {
          key: 0,
          title: "Close all positions",
          class: "positions__action positions__action--header",
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.onCloseAllPositions && $options.onCloseAllPositions(...args), ["stop"]))
        }, [
          createVNode(_component_AppIcon, {
            icon: "monochrome/close.svg",
            size: 12,
            "data-test": "closeAllPositions"
          })
        ])) : createCommentVNode("", true)
      ]),
      impliedLeverage: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_31$1, toDisplayString(item.impliedLeverage === null ? "n/a" : `${item.impliedLeverage}x`), 1)
      ]),
      id: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_32$1, [
          _cache[20] || (_cache[20] = createBaseVNode("strong", null, "ID:", -1)),
          _cache[21] || (_cache[21] = createTextVNode()),
          createBaseVNode("span", {
            title: item.id
          }, toDisplayString(item.maskedId), 9, _hoisted_33$1),
          _cache[22] || (_cache[22] = createTextVNode()),
          createVNode(_component_CopyDataIconButton, {
            title: "Copy to clipboard",
            size: 14,
            "copy-data": `${item.id}`
          }, null, 8, ["copy-data"])
        ])
      ]),
      actions: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_34$1, [
          item.canClose ? (openBlock(), createElementBlock("span", {
            key: 0,
            title: "Close position",
            class: "positions__action",
            "test-id": "open-position__close",
            onClick: withModifiers(($event) => $options.openClosePositionModal(item), ["stop"])
          }, [
            createVNode(_component_AppIcon, {
              icon: "monochrome/close.svg",
              size: 12,
              "data-test": "closePosition"
            })
          ], 8, _hoisted_35$1)) : createCommentVNode("", true)
        ])
      ]),
      empty: withCtx(() => _cache[23] || (_cache[23] = [
        createTextVNode("\n        No open positions.\n      ")
      ])),
      _: 1
    }, 8, ["items", "columns", "onAction"]),
    _cache[52] || (_cache[52] = createTextVNode()),
    createBaseVNode("div", null, [
      createVNode(_component_TradeviewModal, {
        "is-open": $data.isCloseAllPositionsModalOpen,
        "onUpdate:isOpen": _cache[1] || (_cache[1] = ($event) => $data.isCloseAllPositionsModalOpen = $event),
        title: "Close all positions",
        "confirm-text": "Confirm",
        "cancel-text": "Cancel",
        onConfirm: $options.closeAllPositions,
        onClose: _cache[2] || (_cache[2] = ($event) => $data.isCloseAllPositionsModalOpen = false)
      }, {
        body: withCtx(() => _cache[48] || (_cache[48] = [
          createBaseVNode("p", null, "\n            Are you sure you want to close all open positions?\n          ", -1),
          createTextVNode(),
          createBaseVNode("p", { class: "mt8" }, [
            createTextVNode("\n            Note that this will also cancel any open "),
            createBaseVNode("strong", null, "orders"),
            createTextVNode(" on markets with open positions.\n          ")
          ], -1)
        ])),
        _: 1
      }, 8, ["is-open", "onConfirm"]),
      _cache[49] || (_cache[49] = createTextVNode()),
      $data.isClosePositionModalOpen && $data.positionToClose ? (openBlock(), createBlock(_component_ClosePositionModal, {
        key: 0,
        position: $data.positionToClose,
        onClose: _cache[3] || (_cache[3] = ($event) => $data.isClosePositionModalOpen = false)
      }, null, 8, ["position"])) : createCommentVNode("", true),
      _cache[50] || (_cache[50] = createTextVNode()),
      $data.marketHavingCollateralAdjusted ? (openBlock(), createBlock(_component_AdjustCollateralModal, {
        key: 1,
        "is-open": $data.isAdjustCollateralModalOpen,
        market: $data.marketHavingCollateralAdjusted,
        onClose: $options.closeAdjustCollateralModal
      }, null, 8, ["is-open", "market", "onClose"])) : createCommentVNode("", true),
      _cache[51] || (_cache[51] = createTextVNode()),
      $data.isAdjustLeverageModalOpen ? (openBlock(), createBlock(_component_ChangeLeverageModal, {
        key: 2,
        "margin-mode": $data.marginModeHavingLeverageAdjusted,
        market: $data.marketHavingLeverageAdjusted,
        "current-leverage": $data.currentLeverageBeingAdjusted,
        onClose: _cache[4] || (_cache[4] = ($event) => $data.isAdjustLeverageModalOpen = false)
      }, null, 8, ["margin-mode", "market", "current-leverage"])) : createCommentVNode("", true)
    ])
  ]);
}
const OpenPositions = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$n], ["__scopeId", "data-v-1946d623"]]);
const POSITION_HISTORY_COLUMNS = Object.freeze([
  {
    title: "Market",
    slotKey: "market",
    stickyLeft: true
  },
  {
    title: "Amount Δ",
    slotKey: "amountDelta",
    tooltip: "Max amount range while position was open.",
    textAlignRight: true
  },
  {
    title: "Entry price",
    slotKey: "entryPrice",
    textAlignRight: true
  },
  {
    title: "Entry time",
    slotKey: "entryTime",
    textAlignRight: true
  },
  {
    title: "Close price",
    slotKey: "avgClosePrice",
    textAlignRight: true
  },
  {
    title: "Close time",
    slotKey: "closeTime",
    textAlignRight: true
  },
  {
    title: "RSPnL",
    slotKey: "rsPnl",
    tooltip: "The profits and losses that have been realized since the last settlement by closing a futures position. Futures RSPnL is included in your account equity and can be used as trading margin, but is only available for withdrawal after settlement. At settlement, futures RSPnL will be transferred to your cash balance and reset to 0.",
    textAlignRight: true,
    optional: true
  },
  {
    title: "PnL",
    slotKey: "pnl",
    tooltip: "Total PnL represents the sum of all unsettled and settled profits and losses since position inception.",
    textAlignRight: true
  },
  {
    title: "Settled PnL",
    slotKey: "settledPnl",
    tooltip: "Already settled P&L from the time the position was opened to the last settlement period.",
    textAlignRight: true,
    optional: true
  },
  {
    title: "Closing fee",
    slotKey: "closingFee",
    textAlignRight: true
  },
  {
    title: "Status",
    slotKey: "status"
  },
  {
    title: "ID",
    slotKey: "id"
  }
]);
const tooltipTimeFormatter$4 = new Intl.DateTimeFormat(constants.LOCALE, {
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
const _sfc_main$r = {
  name: "PositionHistory",
  components: {
    MarginSettingTag,
    AppPagination: Pagination,
    CopyDataIconButton,
    TableLayout
  },
  props: {
    activeTab: {
      type: String,
      required: true
    },
    isVisible: {
      type: Boolean,
      required: true
    }
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      currenciesStore: useCurrenciesStore(),
      marketsStore: useMarketsStore(),
      subAccountStore: useSubAccountStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewPositionHistoryStore: useTradeviewPositionHistoryStore()
    };
  },
  computed: {
    activeColumns() {
      return POSITION_HISTORY_COLUMNS.filter(
        (c) => !c.optional || this.tradeviewSettingsStore.positionHistoryOptionalColumnVisibility[c.slotKey]
      );
    },
    itemCountWithPagination() {
      const numEntries = this.tradeviewPositionHistoryStore.positionHistory.length;
      if (numEntries === this.tradeviewPositionHistoryStore.perPage) {
        return this.tradeviewPositionHistoryStore.perPage * this.tradeviewPositionHistoryStore.page + 1;
      }
      return this.tradeviewPositionHistoryStore.perPage * (this.tradeviewPositionHistoryStore.page - 1) + numEntries;
    },
    formattedPositionHistory() {
      let filteredHistory = this.tradeviewPositionHistoryStore.positionHistory;
      if (this.activeTab === constants.MARKET_FILTER.CURRENT_MARKET) {
        filteredHistory = filteredHistory.filter((p) => p.market === this.activeMarketStore.activeMarket.key);
      }
      const formatted = filteredHistory.map((position) => {
        const market = this.marketsStore.getMarket(position.market);
        const settlementCurrency = CURRENCIES[position.settlementCurrency];
        return {
          id: position.id,
          key: position.id,
          maskedId: position.id.length <= 9 ? position.id : `${position.id.substr(0, 3)}...${position.id.substr(-3, 3)}`,
          market: position.market,
          marginMode: position.marginMode,
          marginModeDisplay: constants$1.MARGIN_MODE_DISPLAY[position.marginMode],
          marketName: market.name,
          marketTypeDisplay: market.type.toLowerCase(),
          marketLink: URLService.getPageUrl("proTrade", { market: market.key }),
          statusDisplay: constants$1.POSITION_STATUS_DISPLAY[position.status],
          isFinished: position.status !== constants$1.POSITION_STATUS.WAITING_SETTLEMENT,
          isPending: position.status === constants$1.POSITION_STATUS.WAITING_SETTLEMENT,
          settlementCurrency: settlementCurrency.code,
          isPnlPositive: position.pnl.isPositive(),
          entryTimeTooltip: tooltipTimeFormatter$4.format(position.entryTime),
          entryDateObject: position.entryTime,
          entryDate: formatDate(position.entryTime, constants$4.TRADEVIEW_DATE),
          entryTime: formatDate(position.entryTime, constants$4.TRADEVIEW_TIME),
          closeTimeTooltip: tooltipTimeFormatter$4.format(position.closeTime),
          closeDate: formatDate(position.closeTime, constants$4.TRADEVIEW_DATE),
          closeTime: formatDate(position.closeTime, constants$4.TRADEVIEW_TIME),
          leverage: numberFormatter.decimal({
            value: position.leverage,
            decimals: 2
          }),
          amountDelta: numberFormatter.decimal({
            value: position.amountDelta,
            decimals: market.decimals.base
          }),
          closingFee: numberFormatter.decimal({
            value: position.closingFee,
            decimals: settlementCurrency.decimals
          }),
          avgEntryPrice: numberFormatter.decimal({
            value: position.avgEntryPrice,
            decimal: market.decimals.counter
          }),
          avgClosePrice: numberFormatter.decimal({
            value: position.avgClosePrice,
            decimal: market.decimals.counter
          }),
          pnl: numberFormatter.decimal({
            value: position.pnl,
            decimals: settlementCurrency.decimals
          }),
          rsPnl: numberFormatter.decimal({
            value: position.rsPnl,
            decimals: settlementCurrency.decimals
          }),
          settledPnl: numberFormatter.decimal({
            value: position.settledPnl,
            decimals: settlementCurrency.decimals
          })
        };
      });
      return _.orderBy(formatted, "entryDateObject", "desc");
    }
  },
  watch: {
    isVisible(isNowVisible) {
      if (isNowVisible) {
        this.tradeviewPositionHistoryStore.fetchPositionHistory();
        this.tradeviewPositionHistoryStore.startPolling();
      } else {
        this.tradeviewPositionHistoryStore.stopPolling();
      }
    },
    "subAccountStore.doesActiveAccountSupportDerivatives": {
      handler(supportsDerivatives) {
        if (!supportsDerivatives) {
          this.tradeviewPositionHistoryStore.stopPolling();
        }
      }
    }
  },
  methods: {
    onPageChange(page) {
      var _a2, _b;
      this.tradeviewPositionHistoryStore.setPage(page);
      (_b = (_a2 = this.$refs.positionHistoryWrapper) == null ? void 0 : _a2.firstChild) == null ? void 0 : _b.scrollTo(0, 0);
    }
  }
};
const _hoisted_1$l = {
  ref: "positionHistoryWrapper",
  class: "positions-wrapper"
};
const _hoisted_2$i = { class: "flex flex--gap-small" };
const _hoisted_3$f = { class: "market" };
const _hoisted_4$e = { class: "column" };
const _hoisted_5$b = ["href", "title", "onClick"];
const _hoisted_6$a = { class: "market__type" };
const _hoisted_7$8 = { "test-id": "position__amount-delta" };
const _hoisted_8$8 = ["title"];
const _hoisted_9$7 = { "test-id": "position__entry-price" };
const _hoisted_10$7 = { "test-id": "position__avg-close-price" };
const _hoisted_11$6 = ["title"];
const _hoisted_12$4 = { "test-id": "position__rspnl" };
const _hoisted_13$4 = { "test-id": "position__settled-pnl" };
const _hoisted_14$4 = { "test-id": "position__closing-fee" };
const _hoisted_15$4 = { class: "flex flex--align-center flex--gap-tiny" };
const _hoisted_16$4 = { "test-id": "position__status" };
const _hoisted_17$4 = { class: "copy-id" };
const _hoisted_18$3 = ["title"];
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppPagination = resolveComponent("AppPagination");
  const _component_MarginSettingTag = resolveComponent("MarginSettingTag");
  const _component_CopyDataIconButton = resolveComponent("CopyDataIconButton");
  const _component_TableLayout = resolveComponent("TableLayout");
  return openBlock(), createElementBlock("div", _hoisted_1$l, [
    createVNode(_component_TableLayout, {
      items: $options.formattedPositionHistory,
      columns: $options.activeColumns,
      class: "positions"
    }, {
      "market.header": withCtx(() => [
        createBaseVNode("div", _hoisted_2$i, [
          _cache[0] || (_cache[0] = createTextVNode("\n          Market\n          ")),
          createVNode(_component_AppPagination, {
            page: $setup.tradeviewPositionHistoryStore.page,
            "per-page": $setup.tradeviewPositionHistoryStore.perPage,
            count: $options.itemCountWithPagination,
            "icon-size": 10,
            "display-current-page": "",
            onNewPage: $options.onPageChange
          }, null, 8, ["page", "per-page", "count", "onNewPage"])
        ])
      ]),
      market: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_3$f, [
          createBaseVNode("div", _hoisted_4$e, [
            createBaseVNode("a", {
              href: item.marketLink,
              title: `Change active market to ${item.marketName}`,
              class: "market__name",
              "test-id": "position__market",
              onClick: withModifiers(($event) => $setup.setActiveMarket(item.market), ["prevent"])
            }, toDisplayString(item.marketName), 9, _hoisted_5$b),
            _cache[1] || (_cache[1] = createTextVNode()),
            createBaseVNode("span", _hoisted_6$a, toDisplayString(item.marketTypeDisplay), 1)
          ]),
          _cache[2] || (_cache[2] = createTextVNode()),
          createVNode(_component_MarginSettingTag, {
            "test-id": "open-position__leverage",
            text: `${item.leverage}x`
          }, null, 8, ["text"]),
          _cache[3] || (_cache[3] = createTextVNode()),
          createVNode(_component_MarginSettingTag, {
            "test-id": "open-position__margin-mode",
            text: item.marginModeDisplay
          }, null, 8, ["text"])
        ])
      ]),
      amountDelta: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_7$8, toDisplayString(item.amountDelta), 1)
      ]),
      entryTime: withCtx(({ item }) => [
        createBaseVNode("div", {
          title: `Position opened on ${item.entryTimeTooltip}`,
          class: "flex flex--direction-column"
        }, [
          createBaseVNode("span", null, toDisplayString(item.entryTime), 1),
          _cache[4] || (_cache[4] = createTextVNode()),
          createBaseVNode("small", null, toDisplayString(item.entryDate), 1)
        ], 8, _hoisted_8$8)
      ]),
      entryPrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_9$7, toDisplayString(item.avgEntryPrice), 1)
      ]),
      avgClosePrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_10$7, toDisplayString(item.avgClosePrice), 1)
      ]),
      closeTime: withCtx(({ item }) => [
        createBaseVNode("div", {
          title: `Position closed on ${item.closeTimeTooltip}`,
          class: "flex flex--direction-column"
        }, [
          createBaseVNode("span", null, toDisplayString(item.closeTime), 1),
          _cache[5] || (_cache[5] = createTextVNode()),
          createBaseVNode("small", null, toDisplayString(item.closeDate), 1)
        ], 8, _hoisted_11$6)
      ]),
      rsPnl: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_12$4, toDisplayString(item.rsPnl), 1)
      ]),
      settledPnl: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_13$4, toDisplayString(item.settledPnl), 1)
      ]),
      pnl: withCtx(({ item }) => [
        createBaseVNode("span", {
          class: normalizeClass({
            "table-layout__text--positive": item.isPnlPositive,
            "table-layout__text--negative": !item.isPnlPositive
          }),
          "test-id": "position__pnl"
        }, toDisplayString(item.pnl) + " " + toDisplayString(item.settlementCurrency), 3)
      ]),
      closingFee: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_14$4, toDisplayString(item.closingFee) + " " + toDisplayString(item.settlementCurrency), 1)
      ]),
      status: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_15$4, [
          createBaseVNode("span", {
            class: normalizeClass(["status", {
              "status--finished": item.isFinished,
              "status--pending": item.isPending
            }])
          }, null, 2),
          _cache[6] || (_cache[6] = createTextVNode()),
          createBaseVNode("span", _hoisted_16$4, toDisplayString(item.statusDisplay), 1)
        ])
      ]),
      id: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_17$4, [
          _cache[7] || (_cache[7] = createBaseVNode("strong", null, "ID:", -1)),
          _cache[8] || (_cache[8] = createTextVNode()),
          createBaseVNode("span", {
            title: item.id
          }, toDisplayString(item.maskedId), 9, _hoisted_18$3),
          _cache[9] || (_cache[9] = createTextVNode()),
          createVNode(_component_CopyDataIconButton, {
            title: "Copy to clipboard",
            size: 14,
            "copy-data": `${item.id}`
          }, null, 8, ["copy-data"])
        ])
      ]),
      empty: withCtx(() => _cache[10] || (_cache[10] = [
        createTextVNode("\n        No position history.\n      ")
      ])),
      _: 1
    }, 8, ["items", "columns"])
  ], 512);
}
const PositionHistory = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$m], ["__scopeId", "data-v-eefde0cf"]]);
const storeName$1 = "tradeviewPositionSettlementHistoryStore";
const useTradeviewPositionSettlementHistoryStore = addStoreHooks(
  defineStore(storeName$1, () => {
    const { isLoggedIn } = storeToRefs(useUserStateStore({ caller: storeName$1 }));
    const activeMarketStore = useActiveMarketStore({ caller: storeName$1 });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName$1 }));
    const { areUserOrdersInAllPairMode } = storeToRefs(useTradeviewSettingsStore({ caller: storeName$1 }));
    const subAccountStore = useSubAccountStore({ caller: storeName$1 });
    const { activeSubAccountId } = storeToRefs(useSubAccountStore({ caller: storeName$1 }));
    const balancesStore = useBalancesStore({ caller: storeName$1 });
    const tradeviewMarginInfoStore = useTradeviewMarginInfoStore({ caller: storeName$1 });
    const $errorTracking = useErrorTracking();
    let stopPollingFn = () => {
    };
    const initialized = ref(false);
    const isLoading = ref(false);
    const settlements = shallowRef([]);
    const page = ref(1);
    const perPage = ref(100);
    const _init = async () => {
      return () => {
        stopPolling();
      };
    };
    const fetch = asyncThrottle(
      async () => {
        if (!isLoggedIn.value || activeMarketStore.isSpot || !subAccountStore.doesActiveAccountSupportDerivatives) {
          initialized.value = true;
          return;
        }
        isLoading.value = true;
        const marketKey = areUserOrdersInAllPairMode.value ? "" : activeMarketStore.activeMarketKey ?? "";
        try {
          settlements.value = await positionSettlementHistoryApi.list(
            subAccountStore.activeSubAccountId,
            page.value,
            perPage.value,
            marketKey,
            true
          );
        } catch (e) {
          $errorTracking == null ? void 0 : $errorTracking.trackException(e);
        } finally {
          initialized.value = true;
          isLoading.value = false;
        }
      },
      constants$2.TIMERS.THROTTLE_POSITION_HISTORY,
      { leading: false }
    );
    function stopPolling() {
      stopPollingFn();
      stopPollingFn = () => {
      };
    }
    async function fetchAndRefreshBalances() {
      await fetch();
      balancesStore.fetch();
      tradeviewMarginInfoStore.fetchMarginInfo();
    }
    function startPolling() {
      stopPolling();
      const currentTimestamp = Math.floor(Date.now() / 1e3);
      const settlementPeriod = 15 * 60;
      const remainder = (currentTimestamp + settlementPeriod) % settlementPeriod;
      const secondsToDelayUntilNextInterval = settlementPeriod - remainder;
      const randomDelay = _.random(15e3, 2e4);
      const scheduledFetchTimeoutId = setTimeout(
        fetchAndRefreshBalances,
        secondsToDelayUntilNextInterval * 1e3 + randomDelay
      );
      stopPollingFn = () => clearTimeout(scheduledFetchTimeoutId);
    }
    async function setPage(newPage) {
      page.value = newPage;
      await fetch();
    }
    watch(isLoggedIn, (loggedIn, wasLoggedIn) => {
      if (wasLoggedIn) {
        settlements.value = [];
        stopPolling();
      }
    });
    watch(
      activeMarket,
      async (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key)) {
          return;
        }
        if (activeMarketStore.isPerpetual && subAccountStore.doesActiveAccountSupportDerivatives) {
          await fetch();
          startPolling();
        } else {
          stopPolling();
        }
      },
      { deep: true }
    );
    watch(areUserOrdersInAllPairMode, async () => {
      page.value = 1;
      await fetch();
    });
    watch(activeSubAccountId, async () => {
      settlements.value = [];
      if (activeMarketStore.isPerpetual && subAccountStore.doesActiveAccountSupportDerivatives) {
        await fetch();
        startPolling();
      } else {
        stopPolling();
      }
    });
    return {
      settlements,
      initialized,
      isLoading,
      page,
      perPage,
      _init,
      fetch,
      setPage,
      startPolling,
      stopPolling
    };
  })
);
const POSITION_SETTLEMENT_HISTORY_COLUMNS = Object.freeze([
  {
    title: "Market",
    slotKey: "market",
    stickyLeft: true
  },
  {
    title: "Time",
    slotKey: "settlementTime"
  },
  {
    title: "Amount",
    slotKey: "amount",
    textAlignRight: true
  },
  {
    title: "Strike price",
    slotKey: "strikePrice",
    textAlignRight: true
  },
  {
    title: "Settlement price",
    slotKey: "settlementPrice",
    textAlignRight: true
  },
  {
    title: "Settlement type",
    slotKey: "settlementType",
    textAlignRight: true
  },
  {
    title: "Settled PnL",
    slotKey: "pnlSettled",
    textAlignRight: true
  },
  {
    title: "Transaction ID",
    slotKey: "transactionId",
    textAlignRight: true
  },
  {
    title: "Position ID",
    slotKey: "positionId",
    textAlignRight: true
  },
  {
    title: "Receipt",
    slotKey: "receipt",
    textAlignRight: true
  }
]);
const tooltipTimeFormatter$3 = new Intl.DateTimeFormat(constants.LOCALE, {
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
const _sfc_main$q = {
  name: "PositionSettlementHistory",
  components: {
    ReceiptLink,
    AppTooltip,
    MarginSettingTag,
    AppPagination: Pagination,
    CopyDataIconButton,
    TableLayout
  },
  props: {
    activeTab: {
      type: String,
      required: true
    }
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      currenciesStore: useCurrenciesStore(),
      marketsStore: useMarketsStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewPositionSettlementHistoryStore: useTradeviewPositionSettlementHistoryStore()
    };
  },
  data() {
    return {
      POSITION_SETTLEMENT_HISTORY_COLUMNS,
      isLoadingPlaceholderAllowed: false
    };
  },
  computed: {
    itemCountWithPagination() {
      const numEntries = this.tradeviewPositionSettlementHistoryStore.settlements.length;
      if (numEntries === this.tradeviewPositionSettlementHistoryStore.perPage) {
        return this.tradeviewPositionSettlementHistoryStore.perPage * this.tradeviewPositionSettlementHistoryStore.page + 1;
      }
      return this.tradeviewPositionSettlementHistoryStore.perPage * (this.tradeviewPositionSettlementHistoryStore.page - 1) + numEntries;
    },
    formattedHistory() {
      let filtered = this.tradeviewPositionSettlementHistoryStore.settlements;
      if (this.activeTab === constants.MARKET_FILTER.CURRENT_MARKET) {
        filtered = filtered.filter((s) => s.market === this.activeMarketStore.activeMarket.key);
      }
      const formatted = filtered.map((settlement) => {
        const market = this.marketsStore.getMarket(settlement.market);
        const pnlCurrency = CURRENCIES[settlement.pnlCurrency];
        return {
          positionId: settlement.positionId,
          transactionId: settlement.transactionId,
          key: `${settlement.positionId}-${settlement.transactionId}`,
          maskedPositionId: settlement.positionId.length <= 9 ? settlement.positionId : `${settlement.positionId.substr(0, 3)}...${settlement.positionId.substr(-3, 3)}`,
          maskedTransactionId: settlement.transactionId.length <= 9 ? settlement.transactionId : `${settlement.transactionId.substr(0, 3)}...${settlement.transactionId.substr(-3, 3)}`,
          market: settlement.market,
          marginMode: settlement.marginMode,
          marginModeDisplay: constants$1.MARGIN_MODE_DISPLAY[settlement.marginMode],
          marketName: market.name,
          marketTypeDisplay: market.type.toLowerCase(),
          marketLink: URLService.getPageUrl("proTrade", { market: market.key }),
          pnlCurrency: pnlCurrency.code,
          settlementTypeDisplay: settlement.settlementType,
          isPnlPositive: settlement.pnlSettled.isPositive(),
          entryTimeTooltip: tooltipTimeFormatter$3.format(settlement.settlementTime),
          entryDateObject: settlement.settlementTime,
          entryDate: formatDate(settlement.settlementTime, constants$4.TRADEVIEW_DATE),
          entryTime: formatDate(settlement.settlementTime, constants$4.TRADEVIEW_TIME),
          settlementPrice: numberFormatter.decimal({
            value: settlement.settlementPrice,
            decimals: market.decimals.counter
          }),
          strikePrice: numberFormatter.decimal({
            value: settlement.strikePrice,
            decimals: market.decimals.counter
          }),
          pnlSettled: numberFormatter.decimal({
            value: settlement.pnlSettled,
            decimals: pnlCurrency.decimals
          }),
          pnlComponentPrice: numberFormatter.decimal({
            value: settlement.pnlComponentPrice,
            decimals: pnlCurrency.decimals
          }),
          pnlComponentFees: numberFormatter.decimal({
            value: settlement.pnlComponentFees,
            decimals: pnlCurrency.decimals
          }),
          pnlComponentFunding: numberFormatter.decimal({
            value: settlement.pnlComponentFunding,
            decimals: pnlCurrency.decimals
          }),
          pnlComponentSocializedLoss: !settlement.pnlComponentSocializedLoss.isZero() ? numberFormatter.decimal({
            value: settlement.pnlComponentSocializedLoss,
            decimals: pnlCurrency.decimals
          }) : null,
          size: settlement.size.isZero() && settlement.settlementType === "CLOSED" ? "/" : `${numberFormatter.decimal({
            value: settlement.size,
            decimals: market.decimals.base
          })} ${market.base}`,
          receiptLink: this.$pageContext.enableReceiptsInTradeview ? URLService.getPageUrl("settlementReceipt", {
            settlement_id: settlement.id
          }) : ""
        };
      });
      return _.orderBy(formatted, "entryDateObject", "desc");
    }
  },
  methods: {
    async onPageChange(page) {
      var _a2, _b;
      this.isLoadingPlaceholderAllowed = true;
      await this.tradeviewPositionSettlementHistoryStore.setPage(page);
      this.isLoadingPlaceholderAllowed = false;
      (_b = (_a2 = this.$refs.wrapper) == null ? void 0 : _a2.firstChild) == null ? void 0 : _b.scrollTo(0, 0);
    }
  }
};
const _hoisted_1$k = {
  ref: "wrapper",
  class: "history-wrapper"
};
const _hoisted_2$h = { class: "flex flex--gap-small" };
const _hoisted_3$e = { class: "market" };
const _hoisted_4$d = { class: "column" };
const _hoisted_5$a = ["href", "title", "onClick"];
const _hoisted_6$9 = { class: "market__type" };
const _hoisted_7$7 = ["title"];
const _hoisted_8$7 = { "test-id": "entry__amount" };
const _hoisted_9$6 = { "test-id": "entry__strike-price" };
const _hoisted_10$6 = { "test-id": "entry__settlement-price" };
const _hoisted_11$5 = { "test-id": "entry__settlement-type" };
const _hoisted_12$3 = { class: "pnl-details" };
const _hoisted_13$3 = { class: "pnl-details__header nowrap" };
const _hoisted_14$3 = { class: "text--right" };
const _hoisted_15$3 = { class: "text--right" };
const _hoisted_16$3 = { class: "text--right" };
const _hoisted_17$3 = { key: 0 };
const _hoisted_18$2 = { class: "text--right" };
const _hoisted_19$2 = { class: "copy-id" };
const _hoisted_20$2 = ["title"];
const _hoisted_21$2 = { class: "copy-id" };
const _hoisted_22$2 = ["title"];
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppPagination = resolveComponent("AppPagination");
  const _component_MarginSettingTag = resolveComponent("MarginSettingTag");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_CopyDataIconButton = resolveComponent("CopyDataIconButton");
  const _component_ReceiptLink = resolveComponent("ReceiptLink");
  const _component_TableLayout = resolveComponent("TableLayout");
  return openBlock(), createElementBlock("div", _hoisted_1$k, [
    createVNode(_component_TableLayout, {
      items: $options.formattedHistory,
      columns: $data.POSITION_SETTLEMENT_HISTORY_COLUMNS,
      loading: $data.isLoadingPlaceholderAllowed && $setup.tradeviewPositionSettlementHistoryStore.isLoading,
      class: "history"
    }, {
      "market.header": withCtx(() => [
        createBaseVNode("div", _hoisted_2$h, [
          _cache[0] || (_cache[0] = createTextVNode("\n          Market\n          ")),
          createVNode(_component_AppPagination, {
            page: $setup.tradeviewPositionSettlementHistoryStore.page,
            "per-page": $setup.tradeviewPositionSettlementHistoryStore.perPage,
            count: $options.itemCountWithPagination,
            "icon-size": 10,
            "display-current-page": "",
            onNewPage: $options.onPageChange
          }, null, 8, ["page", "per-page", "count", "onNewPage"])
        ])
      ]),
      market: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_3$e, [
          createBaseVNode("div", _hoisted_4$d, [
            createBaseVNode("a", {
              href: item.marketLink,
              title: `Change active market to ${item.marketName}`,
              class: "market__name",
              "test-id": "position__market",
              onClick: withModifiers(($event) => $setup.setActiveMarket(item.market), ["prevent"])
            }, toDisplayString(item.marketName), 9, _hoisted_5$a),
            _cache[1] || (_cache[1] = createTextVNode()),
            createBaseVNode("span", _hoisted_6$9, toDisplayString(item.marketTypeDisplay), 1)
          ]),
          _cache[2] || (_cache[2] = createTextVNode()),
          createVNode(_component_MarginSettingTag, {
            "test-id": "entry__margin-mode",
            text: item.marginModeDisplay
          }, null, 8, ["text"])
        ])
      ]),
      settlementTime: withCtx(({ item }) => [
        createBaseVNode("div", {
          title: `Settled on ${item.entryTimeTooltip}`,
          class: "flex flex--direction-column"
        }, [
          createBaseVNode("span", null, toDisplayString(item.entryTime), 1),
          _cache[3] || (_cache[3] = createTextVNode()),
          createBaseVNode("small", null, toDisplayString(item.entryDate), 1)
        ], 8, _hoisted_7$7)
      ]),
      amount: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_8$7, toDisplayString(item.size), 1)
      ]),
      strikePrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_9$6, toDisplayString(item.strikePrice), 1)
      ]),
      settlementPrice: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_10$6, toDisplayString(item.settlementPrice), 1)
      ]),
      settlementType: withCtx(({ item }) => [
        createBaseVNode("span", _hoisted_11$5, toDisplayString(item.settlementTypeDisplay), 1)
      ]),
      pnlSettled: withCtx(({ item }) => [
        createVNode(_component_AppTooltip, {
          strategy: "fixed",
          container: "#app",
          "max-width": 500
        }, {
          trigger: withCtx(() => [
            createBaseVNode("span", {
              class: normalizeClass(["settled-pnl", { "settled-pnl--negative": !item.isPnlPositive }])
            }, toDisplayString(item.pnlSettled) + " " + toDisplayString(item.pnlCurrency), 3)
          ]),
          default: withCtx(() => [
            createBaseVNode("table", _hoisted_12$3, [
              createBaseVNode("thead", null, [
                createBaseVNode("tr", null, [
                  _cache[4] || (_cache[4] = createBaseVNode("th", { class: "pnl-details__header" }, "\n                  Settled PnL\n                ", -1)),
                  _cache[5] || (_cache[5] = createTextVNode()),
                  createBaseVNode("th", _hoisted_13$3, toDisplayString(item.pnlSettled) + " " + toDisplayString(item.pnlCurrency), 1)
                ])
              ]),
              _cache[17] || (_cache[17] = createTextVNode()),
              createBaseVNode("tbody", null, [
                createBaseVNode("tr", null, [
                  _cache[6] || (_cache[6] = createBaseVNode("td", null, "Price", -1)),
                  _cache[7] || (_cache[7] = createTextVNode()),
                  createBaseVNode("td", _hoisted_14$3, toDisplayString(item.pnlComponentPrice), 1)
                ]),
                _cache[14] || (_cache[14] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[8] || (_cache[8] = createBaseVNode("td", null, "Fees", -1)),
                  _cache[9] || (_cache[9] = createTextVNode()),
                  createBaseVNode("td", _hoisted_15$3, toDisplayString(item.pnlComponentFees), 1)
                ]),
                _cache[15] || (_cache[15] = createTextVNode()),
                createBaseVNode("tr", null, [
                  _cache[10] || (_cache[10] = createBaseVNode("td", null, "Funding", -1)),
                  _cache[11] || (_cache[11] = createTextVNode()),
                  createBaseVNode("td", _hoisted_16$3, toDisplayString(item.pnlComponentFunding), 1)
                ]),
                _cache[16] || (_cache[16] = createTextVNode()),
                item.pnlComponentSocializedLoss ? (openBlock(), createElementBlock("tr", _hoisted_17$3, [
                  _cache[12] || (_cache[12] = createBaseVNode("td", { class: "nowrap" }, "\n                  Socialized loss\n                ", -1)),
                  _cache[13] || (_cache[13] = createTextVNode()),
                  createBaseVNode("td", _hoisted_18$2, toDisplayString(item.pnlComponentSocializedLoss), 1)
                ])) : createCommentVNode("", true)
              ])
            ]),
            _cache[18] || (_cache[18] = createTextVNode())
          ]),
          _: 2
        }, 1024)
      ]),
      transactionId: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_19$2, [
          createBaseVNode("span", {
            title: item.transactionId
          }, toDisplayString(item.maskedTransactionId), 9, _hoisted_20$2),
          _cache[19] || (_cache[19] = createTextVNode()),
          createVNode(_component_CopyDataIconButton, {
            title: "Copy transaction ID to clipboard",
            size: 14,
            "copy-data": `${item.transactionId}`
          }, null, 8, ["copy-data"])
        ])
      ]),
      positionId: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_21$2, [
          createBaseVNode("span", {
            title: item.positionId
          }, toDisplayString(item.maskedPositionId), 9, _hoisted_22$2),
          _cache[20] || (_cache[20] = createTextVNode()),
          createVNode(_component_CopyDataIconButton, {
            title: "Copy position ID to clipboard",
            size: 14,
            "copy-data": `${item.positionId}`
          }, null, 8, ["copy-data"])
        ])
      ]),
      receipt: withCtx(({ item }) => [
        item.receiptLink ? (openBlock(), createBlock(_component_ReceiptLink, {
          key: 0,
          link: item.receiptLink
        }, null, 8, ["link"])) : createCommentVNode("", true)
      ]),
      empty: withCtx(() => _cache[21] || (_cache[21] = [
        createTextVNode("\n        No settlements.\n      ")
      ])),
      _: 1
    }, 8, ["items", "columns", "loading"])
  ], 512);
}
const PositionSettlementHistory = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$l], ["__scopeId", "data-v-7834aeb9"]]);
const _sfc_main$p = {
  __name: "OpenPositionsSettings",
  setup(__props) {
    const tradeviewSettingsStore = useTradeviewSettingsStore();
    const labels = computed(() => {
      const labelMap = {};
      for (const column of openPositionColumnDefinitions) {
        labelMap[column.slotKey] = column.settingsTitle || column.title;
      }
      return labelMap;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1g), { class: "scrollable-area" }, {
        default: withCtx(() => [
          createVNode(unref(DraggableSettings), {
            title: "Columns",
            "initial-settings": unref(tradeviewSettingsStore).openPositionColumnSettings,
            "key-to-label-map": labels.value,
            onUpdate: unref(tradeviewSettingsStore).setOpenPositionColumnSettings,
            onReset: unref(tradeviewSettingsStore).resetOpenPositionColumnSettings
          }, null, 8, ["initial-settings", "key-to-label-map", "onUpdate", "onReset"])
        ]),
        _: 1
      });
    };
  }
};
const OpenPositionsSettings = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-59d75e7c"]]);
const _sfc_main$o = {
  name: "PositionHistorySettings",
  components: { LabeledSwitch },
  setup() {
    return {
      tradeviewSettingsStore: useTradeviewSettingsStore()
    };
  },
  computed: {
    optionalColumnOptions() {
      return POSITION_HISTORY_COLUMNS.filter((c) => c.optional).map(
        ({ slotKey, title }) => ({
          slotKey,
          title,
          active: this.tradeviewSettingsStore.positionHistoryOptionalColumnVisibility[slotKey]
        })
      );
    }
  },
  methods: {
    toggleColumnVisibility(columnId) {
      this.tradeviewSettingsStore.togglePositionHistoryOptionalColumnVisibility(columnId);
    }
  }
};
const _hoisted_1$j = { class: "position-settings" };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabeledSwitch = resolveComponent("LabeledSwitch");
  return openBlock(), createElementBlock("div", _hoisted_1$j, [
    _cache[0] || (_cache[0] = createBaseVNode("p", null, [
      createBaseVNode("strong", null, "Optional columns")
    ], -1)),
    _cache[1] || (_cache[1] = createTextVNode()),
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.optionalColumnOptions, (column) => {
      return openBlock(), createBlock(_component_LabeledSwitch, {
        key: column.slotKey,
        label: column.title,
        value: column.active,
        compact: "",
        "onUpdate:value": ($event) => $options.toggleColumnVisibility(column.slotKey)
      }, null, 8, ["label", "value", "onUpdate:value"]);
    }), 128))
  ]);
}
const PositionHistorySettings = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$k], ["__scopeId", "data-v-f1076fa0"]]);
const EXPORT_ORDER_HISTORY_MODAL = "export-order-history-modal";
const _sfc_main$n = {
  __name: "OrderHistorySettings",
  setup(__props) {
    const tradeviewModalStore = useTradeviewModalStore();
    function openModal() {
      tradeviewModalStore.requestModalOpening(EXPORT_ORDER_HISTORY_MODAL);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("span", {
          class: "settings-link",
          onClick: openModal
        }, "\n      Export order history\n    ")
      ]);
    };
  }
};
const OrderHistorySettings = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-5e3439b7"]]);
const useTradeviewBalancesSearchStore = addStoreHooks(
  defineStore("tradeviewBalancesSearchStore", () => {
    const searchTerm = ref("");
    function setSearchTerm(term) {
      searchTerm.value = term;
    }
    return {
      searchTerm,
      setSearchTerm
    };
  })
);
const _sfc_main$m = {
  name: "BalancesTableAsset",
  components: {
    ActionMenu,
    CurrencyIcon
  },
  props: {
    asset: {
      type: String,
      default: ""
    },
    assetName: {
      type: String,
      default: ""
    },
    marketOptions: {
      type: Array,
      default: () => []
    },
    marketOptionsOpen: {
      type: Boolean,
      default: false
    }
  },
  emits: ["showAssetMarketOptions"],
  computed: {
    actionMenuOptions() {
      return this.marketOptions ?? [];
    }
  }
};
const _hoisted_1$i = { class: "asset-item" };
const _hoisted_2$g = ["title"];
const _hoisted_3$d = { class: "asset-item__icon" };
const _hoisted_4$c = { class: "asset-item__info-wrapper" };
const _hoisted_5$9 = { class: "asset-item__info" };
const _hoisted_6$8 = { class: "asset-item__name" };
const _hoisted_7$6 = { class: "market-options" };
const _hoisted_8$6 = { class: "asset-item__code" };
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CurrencyIcon = resolveComponent("CurrencyIcon");
  const _component_ActionMenu = resolveComponent("ActionMenu");
  return openBlock(), createElementBlock("div", _hoisted_1$i, [
    createBaseVNode("div", {
      class: "asset-item__container",
      title: $props.assetName
    }, [
      createBaseVNode("div", _hoisted_3$d, [
        createVNode(_component_CurrencyIcon, {
          currency: $props.asset,
          size: "24"
        }, null, 8, ["currency"])
      ]),
      _cache[2] || (_cache[2] = createTextVNode()),
      createBaseVNode("div", _hoisted_4$c, [
        createBaseVNode("div", _hoisted_5$9, [
          createBaseVNode("span", _hoisted_6$8, toDisplayString($props.assetName), 1),
          _cache[1] || (_cache[1] = createTextVNode()),
          createBaseVNode("div", _hoisted_7$6, [
            createBaseVNode("div", _hoisted_8$6, toDisplayString($props.asset), 1),
            _cache[0] || (_cache[0] = createTextVNode()),
            $options.actionMenuOptions.length > 0 ? (openBlock(), createBlock(_component_ActionMenu, {
              key: 0,
              class: "market-options__menu",
              placement: "right",
              "icon-type": "arrow-right",
              shown: $props.marketOptionsOpen,
              options: $options.actionMenuOptions,
              "trigger-callback": () => _ctx.$emit("showAssetMarketOptions", $props.asset)
            }, null, 8, ["shown", "options", "trigger-callback"])) : createCommentVNode("", true)
          ])
        ])
      ])
    ], 8, _hoisted_2$g)
  ]);
}
const BalancesTableAsset = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$j], ["__scopeId", "data-v-e6224d80"]]);
const _sfc_main$l = {
  name: "BalancesTable",
  components: {
    AppIcon,
    BalancesTableAsset,
    TableLayout,
    BtsLink
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      smallBalancesStore: useSmallBalancesStore(),
      tradeviewBalancesSearchStore: useTradeviewBalancesSearchStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      currenciesStore: useCurrenciesStore(),
      marketsStore: useMarketsStore(),
      preferredCurrencyStore: usePreferredCurrencyStore(),
      balancesStore: useBalancesStore(),
      subAccountStore: useSubAccountStore()
    };
  },
  data() {
    return {
      activeMarketSelectionAsset: null,
      isMarketSelectionMenuVisible: false,
      columns: Object.freeze([
        { title: "Asset", slotKey: "asset" },
        { title: "Total", slotKey: "total", textAlignRight: true },
        { title: "Available", slotKey: "available", textAlignRight: true },
        { title: "Reserved", slotKey: "reserved", textAlignRight: true },
        { slotKey: "actions" }
      ])
    };
  },
  computed: {
    /**
     * @returns {AccountBalance[]}
     */
    balances() {
      return this.balancesStore.activeAccountBalances;
    },
    formattedBalances() {
      if (this.balances.length < 1) {
        return [];
      }
      const valueCurrency = this.currenciesStore.getCurrency(this.balances[0].valueCurrencyCode) || {};
      return this.balances.map((assetBalance) => {
        const assetBalanceCurrency = this.currenciesStore.getCurrency(assetBalance.code) || {};
        const amountDecimals = assetBalanceCurrency.decimals ?? 8;
        const isCrypto = assetBalanceCurrency.type === "crypto";
        return {
          key: assetBalance.code,
          assetCode: assetBalance.code,
          assetName: assetBalanceCurrency.name,
          showValue: assetBalance.code !== valueCurrency.code,
          canDeposit: isCrypto ? this.$has("deposits_crypto_read") : this.$has("deposits_bank_transfer_create"),
          canWithdraw: isCrypto ? this.$has("withdrawals_crypto_create") : this.$has("withdrawals_bank_transfer_create"),
          canTransfer: this.$has("sub_accounts_transfer") && this.subAccountStore.hasSubAccounts,
          formattedTotalAmount: numberFormatter.decimal({
            value: assetBalance.balance,
            decimals: amountDecimals
          }),
          formattedAvailableAmount: numberFormatter.decimal({
            value: assetBalance.available,
            decimals: amountDecimals
          }),
          formattedReservedAmount: numberFormatter.decimal({
            value: assetBalance.reserved,
            decimals: amountDecimals
          }),
          totalBalanceValue: assetBalance.balanceValue,
          formattedTotalValue: numberFormatter.price({
            value: assetBalance.balanceValue,
            decimals: valueCurrency.decimals ?? 8,
            currencySymbol: valueCurrency.symbol,
            currencyCode: valueCurrency.code
          }),
          availableValue: assetBalance.availableValue,
          formattedAvailableValue: numberFormatter.price({
            value: assetBalance.availableValue,
            decimals: valueCurrency.decimals ?? 8,
            currencySymbol: valueCurrency.symbol,
            currencyCode: valueCurrency.code
          }),
          reservedValue: assetBalance.reservedValue,
          formattedReservedValue: numberFormatter.price({
            value: assetBalance.reservedValue,
            decimals: valueCurrency.decimals ?? 8,
            currencySymbol: valueCurrency.symbol,
            currencyCode: valueCurrency.code
          })
        };
      });
    },
    filteredAndOrderedBalances() {
      const searchTerm = this.tradeviewBalancesSearchStore.searchTerm.toUpperCase();
      const filtered = this.formattedBalances.filter(({ assetCode, assetName, totalBalanceValue }) => {
        if (!this.tradeviewSettingsStore.areSmallBalancesVisible && totalBalanceValue.lt(this.smallBalancesStore.smallBalanceThresholdInPreferredCurrency)) {
          return false;
        }
        if (searchTerm.length === 0) {
          return true;
        }
        return assetCode.toUpperCase().includes(searchTerm) || assetName.toUpperCase().includes(searchTerm);
      });
      return filtered.sort(this.balanceSorter);
    },
    marketSelectionMenuOptionsPerAssetMap() {
      const optionsPerAsset = {};
      for (const { assetCode } of this.formattedBalances) {
        const options = Object.values(this.marketsStore.visibleMarkets).filter((market) => market.base === assetCode).map((market) => ({
          id: market.key,
          text: market.display,
          link: URLService.getPageUrl("proTrade", { market: market.key }),
          counter: market.counter,
          callback: () => {
            this.setActiveMarket(market.key);
            this.isMarketSelectionMenuVisible = false;
          }
        }));
        optionsPerAsset[assetCode] = options.sort(this.marketOptionSorter);
      }
      return optionsPerAsset;
    }
  },
  mounted() {
    var _a2, _b;
    (_b = (_a2 = this.$refs.balancesTable) == null ? void 0 : _a2.$el) == null ? void 0 : _b.addEventListener("ps-scroll-y", this.marketSelectionMenuVisibilityHandler);
  },
  beforeUnmount() {
    var _a2, _b;
    (_b = (_a2 = this.$refs.balancesTable) == null ? void 0 : _a2.$el) == null ? void 0 : _b.removeEventListener("ps-scroll-y", this.marketSelectionMenuVisibilityHandler);
  },
  methods: {
    onTransferFundsClicked(event, asset) {
      event.preventDefault();
      this.subAccountStore.openTransferFundsModal(asset);
    },
    marketOptionSorter(a, b) {
      const preferredCurrency = this.preferredCurrencyStore.preferredCurrency;
      if (a.counter === preferredCurrency && b.counter !== preferredCurrency) {
        return -1;
      }
      if (b.counter === preferredCurrency && a.counter !== preferredCurrency) {
        return 1;
      }
      return a.text.localeCompare(b.text);
    },
    showMarketSelectionMenu(assetCode) {
      this.activeMarketSelectionAsset = assetCode;
      this.isMarketSelectionMenuVisible = true;
    },
    marketSelectionMenuVisibilityHandler: _.throttle(
      function() {
        this.isMarketSelectionMenuVisible = false;
      },
      1e3
    ),
    /**
     *
     * @param {string} action - deposit|withdraw
     * @param {string} currency - currency code
     * @returns {string} - link to action page
     */
    getActionLink(action, currency) {
      var _a2;
      if (action === "transfer") {
        return URLService.getPageUrl("sub_account_transfer", {}, true, { asset: currency });
      }
      if (((_a2 = this.currenciesStore.getCurrency(currency)) == null ? void 0 : _a2.type) === "crypto") {
        return URLService.getPageUrl(`${action}Crypto`, {}, true, { currency });
      }
      if (action === "deposit") {
        return URLService.getPageUrl("bank_transfer_deposit");
      }
      return URLService.getPageUrl("bank_transfer_withdrawal");
    },
    /**
     * Sort active market's Base and Counter to top, rest by Total Balance Value Desc
     */
    balanceSorter(a, b) {
      const activeBase = this.activeMarketStore.activeMarket.base;
      const activeCounter = this.activeMarketStore.activeMarket.counter;
      if (b.assetCode === activeBase) {
        return 1;
      } else if (a.assetCode === activeBase) {
        return -1;
      }
      if (b.assetCode === activeCounter) {
        return 1;
      } else if (a.assetCode === activeCounter) {
        return -1;
      }
      return b.totalBalanceValue.sub(a.totalBalanceValue).valueOf();
    }
  }
};
const _hoisted_1$h = { class: "balances-wrapper" };
const _hoisted_2$f = { class: "balance__asset" };
const _hoisted_3$c = { class: "balances__row balances__row--amount" };
const _hoisted_4$b = {
  key: 0,
  class: "balances__row balances__row--value"
};
const _hoisted_5$8 = { class: "balances__row balances__row--amount" };
const _hoisted_6$7 = {
  key: 0,
  class: "balances__row balances__row--value"
};
const _hoisted_7$5 = { class: "balances__row balances__row--amount" };
const _hoisted_8$5 = {
  key: 0,
  class: "balances__row balances__row--value"
};
const _hoisted_9$5 = { class: "balances__actions" };
const _hoisted_10$5 = ["href", "onClick"];
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BalancesTableAsset = resolveComponent("BalancesTableAsset");
  const _component_AppIcon = resolveComponent("AppIcon");
  const _component_BtsLink = resolveComponent("BtsLink");
  const _component_TableLayout = resolveComponent("TableLayout");
  return openBlock(), createElementBlock("div", _hoisted_1$h, [
    createVNode(_component_TableLayout, {
      ref: "balancesTable",
      items: $options.filteredAndOrderedBalances,
      columns: $data.columns,
      class: "balances"
    }, {
      asset: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_2$f, [
          createVNode(_component_BalancesTableAsset, {
            asset: item.assetCode,
            "asset-name": item.assetName,
            "market-options": $options.marketSelectionMenuOptionsPerAssetMap[item.assetCode],
            "market-options-open": item.assetCode === $data.activeMarketSelectionAsset && $data.isMarketSelectionMenuVisible,
            onShowAssetMarketOptions: $options.showMarketSelectionMenu
          }, null, 8, ["asset", "asset-name", "market-options", "market-options-open", "onShowAssetMarketOptions"])
        ])
      ]),
      total: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_3$c, toDisplayString(item.formattedTotalAmount), 1),
        _cache[0] || (_cache[0] = createTextVNode()),
        item.showValue ? (openBlock(), createElementBlock("div", _hoisted_4$b, [
          !item.totalBalanceValue.isZero() ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode("\n            ≈\n          ")
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(item.formattedTotalValue), 1)
        ])) : createCommentVNode("", true)
      ]),
      available: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_5$8, toDisplayString(item.formattedAvailableAmount), 1),
        _cache[1] || (_cache[1] = createTextVNode()),
        item.showValue ? (openBlock(), createElementBlock("div", _hoisted_6$7, [
          !item.availableValue.isZero() ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode("\n            ≈\n          ")
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(item.formattedAvailableValue), 1)
        ])) : createCommentVNode("", true)
      ]),
      reserved: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_7$5, toDisplayString(item.formattedReservedAmount), 1),
        _cache[2] || (_cache[2] = createTextVNode()),
        item.showValue ? (openBlock(), createElementBlock("div", _hoisted_8$5, [
          !item.reservedValue.isZero() ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode("\n            ≈\n          ")
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(item.formattedReservedValue), 1)
        ])) : createCommentVNode("", true)
      ]),
      actions: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_9$5, [
          item.canDeposit ? (openBlock(), createBlock(_component_BtsLink, {
            key: 0,
            to: $options.getActionLink("deposit", item.assetCode),
            external: "",
            "new-tab": "",
            title: "Deposit",
            class: "balances__action"
          }, {
            default: withCtx(() => [
              createVNode(_component_AppIcon, {
                icon: "monochrome/deposit.svg",
                size: 20
              })
            ]),
            _: 2
          }, 1032, ["to"])) : createCommentVNode("", true),
          _cache[3] || (_cache[3] = createTextVNode()),
          item.canWithdraw ? (openBlock(), createBlock(_component_BtsLink, {
            key: 1,
            to: $options.getActionLink("withdraw", item.assetCode),
            external: "",
            "new-tab": "",
            title: "Withdraw",
            class: "balances__action"
          }, {
            default: withCtx(() => [
              createVNode(_component_AppIcon, {
                icon: "monochrome/withdraw.svg",
                size: 20
              })
            ]),
            _: 2
          }, 1032, ["to"])) : createCommentVNode("", true),
          _cache[4] || (_cache[4] = createTextVNode()),
          item.canTransfer ? (openBlock(), createElementBlock("a", {
            key: 2,
            class: "balances__action--link",
            title: "Transfer between sub accounts",
            href: $options.getActionLink("transfer", item.assetCode),
            onClick: ($event) => $options.onTransferFundsClicked($event, item.assetCode)
          }, [
            createVNode(_component_AppIcon, {
              icon: "monochrome/arrows-up-down.svg",
              size: 20
            })
          ], 8, _hoisted_10$5)) : createCommentVNode("", true)
        ])
      ]),
      empty: withCtx(() => _cache[5] || (_cache[5] = [
        createTextVNode("\n        No assets.\n      ")
      ])),
      _: 1
    }, 8, ["items", "columns"])
  ]);
}
const BalancesTable = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$i], ["__scopeId", "data-v-7d372d4b"]]);
const _sfc_main$k = {
  name: "BalancesTableSettings",
  components: { LabeledSwitch },
  setup() {
    return {
      tradeviewSettingsStore: useTradeviewSettingsStore()
    };
  },
  methods: {
    toggleSmallBalances() {
      this.tradeviewSettingsStore.setAreSmallBalancesVisible(!this.tradeviewSettingsStore.areSmallBalancesVisible);
    }
  }
};
const _hoisted_1$g = { class: "balances-settings" };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabeledSwitch = resolveComponent("LabeledSwitch");
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createVNode(_component_LabeledSwitch, {
      value: $setup.tradeviewSettingsStore.areSmallBalancesVisible,
      class: "balances-settings__small-balances",
      label: "Show small balances",
      "space-between": false,
      compact: "",
      "onUpdate:value": $options.toggleSmallBalances
    }, null, 8, ["value", "onUpdate:value"])
  ]);
}
const BalancesTableSettings = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$h]]);
const _sfc_main$j = {
  name: "BalancesTableSearch",
  components: { SearchSVG, CrossSVG },
  setup() {
    return {
      tradeviewBalancesSearchStore: useTradeviewBalancesSearchStore()
    };
  },
  data() {
    return {
      searchTerm: ""
    };
  },
  watch: {
    searchTerm(value) {
      this.onSearchInputDebounced(value);
    }
  },
  mounted() {
    this.searchTerm = this.tradeviewBalancesSearchStore.searchTerm;
  },
  methods: {
    clearSearch() {
      this.searchTerm = "";
    },
    onSearchInputDebounced: _.debounce(function(term) {
      this.tradeviewBalancesSearchStore.setSearchTerm(term);
    }, 200)
  }
};
const _hoisted_1$f = { class: "balances-search" };
const _hoisted_2$e = { class: "balances-search__search-wrapper" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SearchSVG = resolveComponent("SearchSVG");
  const _component_CrossSVG = resolveComponent("CrossSVG");
  return openBlock(), createElementBlock("div", _hoisted_1$f, [
    createBaseVNode("div", _hoisted_2$e, [
      withDirectives(createBaseVNode("input", {
        ref: "search",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.searchTerm = $event),
        class: "balances-search__input",
        placeholder: "Search"
      }, null, 512), [
        [vModelText, $data.searchTerm]
      ]),
      _cache[1] || (_cache[1] = createTextVNode()),
      createVNode(_component_SearchSVG, { class: "balances-search__search-icon" }),
      _cache[2] || (_cache[2] = createTextVNode()),
      withDirectives(createVNode(_component_CrossSVG, {
        class: "balances-search__delete-icon",
        onClick: $options.clearSearch
      }, null, 8, ["onClick"]), [
        [vShow, $data.searchTerm]
      ])
    ])
  ]);
}
const BalancesTableSearch = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$g], ["__scopeId", "data-v-67d080ee"]]);
const tooltipTimeFormatter$2 = new Intl.DateTimeFormat(constants.LOCALE, {
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
const _sfc_main$i = {
  name: "TradeHistory",
  components: {
    ReceiptLink,
    MarginSettingTag,
    CopyDataIconButton,
    TableLayout
  },
  props: {
    activeTab: {
      type: String,
      required: true
    }
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      activeMarketStore: useActiveMarketStore(),
      marketsStore: useMarketsStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      currenciesStore: useCurrenciesStore(),
      tradeviewPrivateTradesStore: useTradeviewPrivateTradesStore()
    };
  },
  data() {
    return {
      marketConstants: Object.freeze(marketConstants),
      ordersConstants: constants$1,
      maxRowsDisplayed: 100,
      tableTestId: "trades-table"
    };
  },
  computed: {
    columns() {
      return [
        { title: "Side", slotKey: "type" },
        { title: "Date and time", slotKey: "datetime" },
        { title: "Market", slotKey: "market" },
        { title: "Price", slotKey: "price", textAlignRight: true },
        { title: "Amount", slotKey: "amount", textAlignRight: true },
        { title: "Value", slotKey: "value", textAlignRight: true },
        { title: "Fee", slotKey: "fee", textAlignRight: true },
        { title: "ID", slotKey: "id", textAlignRight: true }
      ];
    },
    areReceiptsEnabled() {
      return PAGE_CONTEXT.enableReceiptsInTradeview ?? false;
    },
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    showTradesForAllMarkets() {
      return this.activeTab === constants.MARKET_FILTER.ALL;
    },
    formattedTrades() {
      var _a2, _b, _c;
      const formatted = [];
      for (const trade of this.tradeviewPrivateTradesStore.trades.slice(0, this.maxRowsDisplayed)) {
        const market = this.marketsStore.getMarket(trade.market);
        if (!market) {
          (_a2 = this.$errorTracking) == null ? void 0 : _a2.track(`Could not find market [${trade.market}] when formatting trades.`);
          continue;
        }
        const decimals = market.decimals;
        const feeSource = trade.isLiquidation ? trade.liquidationFee : trade.fee;
        formatted.push({
          id: trade.tradeId,
          key: trade.tradeId,
          timeShort: formatDate(trade.datetime, constants$4.TRADEVIEW_SHORT_DATE),
          time: tooltipTimeFormatter$2.format(trade.datetime),
          side: trade.side,
          sideDisplay: trade.sideDisplay,
          price: numberFormatter.formatZeroPaddedWithoutRounding({
            value: trade.price,
            minimumDecimals: decimals.counter
          }),
          decimalPrice: trade.price,
          amount: numberFormatter.amount({
            value: trade.amount,
            decimals: decimals.base
          }),
          fee: numberFormatter.formatZeroPaddedWithoutRounding({
            value: feeSource,
            minimumDecimals: ((_b = this.currenciesStore.getCurrency(trade.feeCurrency)) == null ? void 0 : _b.decimals) ?? 2
          }),
          value: numberFormatter.decimal({
            value: trade.price.mul(trade.amount),
            decimals: ((_c = this.currenciesStore.getCurrency(market.counter)) == null ? void 0 : _c.decimals) ?? 8,
            smartStripTrailingZeros: true
          }),
          base: market.base,
          counter: market.counter,
          feeCurrency: trade.feeCurrency,
          marketKey: market.key,
          marketName: market.name,
          marketLink: URLService.getPageUrl("proTrade", { market: market.key }),
          maskedId: trade.tradeId.length <= 9 ? trade.tradeId : `${trade.tradeId.substr(0, 3)}...${trade.tradeId.substr(-3, 3)}`,
          isMarketSelectable: market.visible,
          marginModeDisplay: constants$1.MARGIN_MODE_DISPLAY[trade.marginMode],
          receiptLink: this.areReceiptsEnabled ? trade.receiptUrl : null
        });
      }
      return formatted;
    }
  },
  watch: {
    activeTab() {
      this.tradeviewPrivateTradesStore.fetchTradeHistory();
    }
  }
};
const _hoisted_1$e = ["test-id"];
const _hoisted_2$d = ["title"];
const _hoisted_3$b = { class: "flex flex--justify-flex-start flex--gap-small flex--align-center" };
const _hoisted_4$a = ["href", "title", "onClick"];
const _hoisted_5$7 = {
  key: 1,
  title: "Market not available for trading"
};
const _hoisted_6$6 = ["onClick"];
const _hoisted_7$4 = { "data-test": "table-layoutAmount" };
const _hoisted_8$4 = { "data-test": "table-layoutAmount" };
const _hoisted_9$4 = { "data-test": "table-layoutAmount" };
const _hoisted_10$4 = { class: "copy-id" };
const _hoisted_11$4 = ["title"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MarginSettingTag = resolveComponent("MarginSettingTag");
  const _component_ReceiptLink = resolveComponent("ReceiptLink");
  const _component_CopyDataIconButton = resolveComponent("CopyDataIconButton");
  const _component_TableLayout = resolveComponent("TableLayout");
  return openBlock(), createBlock(_component_TableLayout, {
    items: $options.formattedTrades,
    columns: $options.columns,
    "table-test-id": $data.tableTestId
  }, {
    type: withCtx(({ item }) => [
      createBaseVNode("div", {
        class: normalizeClass(["table-layout__strip", {
          "table-layout__strip--buy": item.side === $data.ordersConstants.ORDER_SIDE.BUY,
          "table-layout__strip--sell": item.side === $data.ordersConstants.ORDER_SIDE.SELL
        }])
      }, null, 2),
      _cache[0] || (_cache[0] = createTextVNode()),
      createBaseVNode("span", {
        class: normalizeClass(["table-layout__text--capitalize", {
          "table-layout__text--buy": item.side === $data.ordersConstants.ORDER_SIDE.BUY,
          "table-layout__text--sell": item.side === $data.ordersConstants.ORDER_SIDE.SELL
        }]),
        "test-id": `${$data.tableTestId}__side`
      }, toDisplayString(item.sideDisplay), 11, _hoisted_1$e)
    ]),
    datetime: withCtx(({ item }) => [
      createBaseVNode("span", {
        title: `Executed on ${item.time}`
      }, toDisplayString(item.timeShort), 9, _hoisted_2$d)
    ]),
    market: withCtx(({ item }) => [
      createBaseVNode("div", _hoisted_3$b, [
        item.isMarketSelectable ? (openBlock(), createElementBlock("a", {
          key: 0,
          href: item.marketLink,
          title: `Change active market to ${item.marketName}`,
          class: "table-layout__text--link",
          "data-test": "tradeHistoryTableRowMarket",
          onClick: withModifiers(($event) => $setup.setActiveMarket(item.marketKey), ["prevent"])
        }, toDisplayString(item.marketName), 9, _hoisted_4$a)) : (openBlock(), createElementBlock("span", _hoisted_5$7, toDisplayString(item.marketName), 1)),
        _cache[1] || (_cache[1] = createTextVNode()),
        item.marginModeDisplay ? (openBlock(), createBlock(_component_MarginSettingTag, {
          key: 2,
          "test-id": "margin-mode",
          text: item.marginModeDisplay
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ])
    ]),
    price: withCtx(({ item }) => [
      createBaseVNode("span", {
        title: "Fill order form with this price",
        "data-test": "tradeHistoryPrice",
        class: "table-layout__text--bright-text table-layout__text--clickable",
        onClick: ($event) => $setup.tradeviewTriggerValueStore.setPriceSetByTrigger(item.decimalPrice)
      }, toDisplayString(item.price), 9, _hoisted_6$6)
    ]),
    amount: withCtx(({ item }) => [
      createBaseVNode("span", _hoisted_7$4, toDisplayString(item.amount), 1)
    ]),
    value: withCtx(({ item }) => [
      createBaseVNode("span", _hoisted_8$4, toDisplayString(item.value) + " " + toDisplayString(item.counter), 1)
    ]),
    fee: withCtx(({ item }) => [
      createBaseVNode("span", _hoisted_9$4, toDisplayString(item.fee) + " " + toDisplayString(item.feeCurrency), 1)
    ]),
    id: withCtx(({ item }) => [
      createBaseVNode("div", _hoisted_10$4, [
        item.receiptLink ? (openBlock(), createBlock(_component_ReceiptLink, {
          key: 0,
          link: item.receiptLink
        }, null, 8, ["link"])) : createCommentVNode("", true),
        _cache[2] || (_cache[2] = createTextVNode()),
        createBaseVNode("span", {
          title: item.id
        }, toDisplayString(item.maskedId), 9, _hoisted_11$4),
        _cache[3] || (_cache[3] = createTextVNode()),
        createVNode(_component_CopyDataIconButton, {
          title: "Copy to clipboard",
          size: 14,
          "copy-data": `${item.id}`
        }, null, 8, ["copy-data"])
      ])
    ]),
    empty: withCtx(() => [
      createTextVNode("\n      No trade history available" + toDisplayString($options.showTradesForAllMarkets ? "" : " for this market") + ".\n    ", 1)
    ]),
    _: 1
  }, 8, ["items", "columns", "table-test-id"]);
}
const TradeHistory = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$f], ["__scopeId", "data-v-f724b6d9"]]);
const tooltipTimeFormatter$1 = new Intl.DateTimeFormat(constants.LOCALE, {
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
const _sfc_main$h = {
  name: "OrderHistoryDetails",
  components: {
    CopyDataIconButton,
    TableLayout
  },
  props: {
    orderId: {
      type: Number,
      required: true
    },
    isBuyOrder: {
      type: Boolean,
      required: true
    }
  },
  setup() {
    return {
      marketsStore: useMarketsStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      tradeviewPrivateTradesStore: useTradeviewPrivateTradesStore(),
      currenciesStore: useCurrenciesStore()
    };
  },
  data() {
    return {
      isLoading: true
    };
  },
  computed: {
    /** @type module:transactions.UserTrade[] */
    trades() {
      return this.tradeviewPrivateTradesStore.tradesForTrackedOrders[this.orderId] ?? [];
    },
    market() {
      var _a2;
      if (this.trades.length < 1) {
        return null;
      }
      const market = this.marketsStore.getMarket(this.trades[0].market);
      if (!market) {
        (_a2 = this.$errorTracking) == null ? void 0 : _a2.track(`Could not find market [${this.trades[0].market}] for order history details.`);
      }
      return market;
    },
    isLiquidation() {
      return this.trades.some((trade) => trade.isLiquidation);
    },
    formattedTrades() {
      var _a2, _b;
      const formatted = [];
      if (!this.market) {
        return formatted;
      }
      const decimals = this.market.decimals;
      for (const trade of this.trades) {
        const feeSource = trade.isLiquidation ? trade.liquidationFee : trade.fee;
        formatted.push({
          id: trade.tradeId,
          key: trade.tradeId,
          timeShort: formatDate(trade.datetime, constants$4.TRADEVIEW_SHORT_DATE),
          time: tooltipTimeFormatter$1.format(trade.datetime),
          price: numberFormatter.formatZeroPaddedWithoutRounding({
            value: trade.price,
            minimumDecimals: decimals.counter
          }),
          decimalPrice: trade.price,
          amount: numberFormatter.amount({
            value: trade.amount,
            decimals: decimals.base
          }),
          fee: numberFormatter.formatZeroPaddedWithoutRounding({
            value: feeSource,
            minimumDecimals: ((_a2 = this.currenciesStore.getCurrency(trade.feeCurrency)) == null ? void 0 : _a2.decimals) ?? 2
          }),
          value: numberFormatter.decimal({
            value: trade.price.mul(trade.amount),
            decimals: ((_b = this.currenciesStore.getCurrency(this.market.counter)) == null ? void 0 : _b.decimals) ?? 8,
            smartStripTrailingZeros: true
          }),
          base: this.market.base,
          counter: this.market.counter,
          feeCurrency: trade.feeCurrency
        });
      }
      return formatted;
    },
    summary() {
      var _a2;
      if (!this.market || this.trades.length < 1) {
        return {};
      }
      let totalFee = new Decimal(0);
      let totalValue = new Decimal(0);
      let totalAmount = new Decimal(0);
      for (const trade of this.trades) {
        const appliedFee = trade.isLiquidation ? trade.liquidationFee : trade.fee;
        totalFee = totalFee.add(appliedFee);
        totalValue = totalValue.add(trade.amount.mul(trade.price));
        totalAmount = totalAmount.add(trade.amount);
      }
      const valueCurrencySettings = this.currenciesStore.getCurrency(this.trades[0].feeCurrency);
      return {
        // NOTE: Checking totalValue on purpose, as totalFee can be 0
        totalFee: totalValue.isZero() ? "" : numberFormatter.formatZeroPaddedWithoutRounding({
          value: totalFee,
          minimumDecimals: ((_a2 = this.currenciesStore.getCurrency(this.trades[0].feeCurrency)) == null ? void 0 : _a2.decimals) ?? 2
        }),
        totalValue: totalValue.isZero() ? "" : numberFormatter.decimal({
          value: totalValue,
          decimals: (valueCurrencySettings == null ? void 0 : valueCurrencySettings.decimals) ?? 8
        }),
        finalTotal: this.market.counter !== this.trades[0].feeCurrency ? "" : numberFormatter.decimal({
          value: this.isBuyOrder ? totalValue.add(totalFee) : totalValue.sub(totalFee),
          decimals: (valueCurrencySettings == null ? void 0 : valueCurrencySettings.decimals) ?? 8
        }),
        avgPrice: totalAmount.isZero() ? "" : numberFormatter.decimal({
          value: totalValue.div(totalAmount),
          decimals: this.market.decimals.counter
        }),
        feeCurrency: this.trades[0].feeCurrency
      };
    }
  },
  async created() {
    await this.tradeviewPrivateTradesStore.fetchAndTrackTradeHistoryByOrderId(this.orderId);
    this.isLoading = false;
  },
  beforeUnmount() {
    this.tradeviewPrivateTradesStore.stopTrackingTradesForOrder(this.orderId);
  }
};
const _hoisted_1$d = { key: 0 };
const _hoisted_2$c = { class: "summary" };
const _hoisted_3$a = {
  key: 0,
  class: "summary__item"
};
const _hoisted_4$9 = { class: "summary__item" };
const _hoisted_5$6 = { class: "copy-order-id" };
const _hoisted_6$5 = {
  key: 1,
  class: "summary__item"
};
const _hoisted_7$3 = {
  key: 2,
  class: "summary__item"
};
const _hoisted_8$3 = {
  key: 3,
  class: "summary__item"
};
const _hoisted_9$3 = {
  key: 4,
  class: "summary__item"
};
const _hoisted_10$3 = ["title"];
const _hoisted_11$3 = ["onClick"];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CopyDataIconButton = resolveComponent("CopyDataIconButton");
  const _component_TableLayout = resolveComponent("TableLayout");
  return !$data.isLoading ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
    createBaseVNode("div", _hoisted_2$c, [
      $options.isLiquidation ? (openBlock(), createElementBlock("div", _hoisted_3$a, _cache[0] || (_cache[0] = [
        createBaseVNode("strong", null, "Reason:", -1),
        createTextVNode("\n        Liquidation\n      ")
      ]))) : createCommentVNode("", true),
      _cache[6] || (_cache[6] = createTextVNode()),
      createBaseVNode("div", _hoisted_4$9, [
        _cache[1] || (_cache[1] = createBaseVNode("strong", null, "Order ID:", -1)),
        _cache[2] || (_cache[2] = createTextVNode()),
        createBaseVNode("div", _hoisted_5$6, [
          createTextVNode(toDisplayString($props.orderId) + " ", 1),
          createVNode(_component_CopyDataIconButton, {
            title: "Copy to clipboard",
            size: 14,
            "copy-data": `${$props.orderId}`
          }, null, 8, ["copy-data"])
        ])
      ]),
      _cache[7] || (_cache[7] = createTextVNode()),
      $options.summary.avgPrice ? (openBlock(), createElementBlock("div", _hoisted_6$5, [
        _cache[3] || (_cache[3] = createBaseVNode("strong", null, "Avg. price:", -1)),
        createTextVNode(" " + toDisplayString($options.summary.avgPrice) + " " + toDisplayString($options.market.counter), 1)
      ])) : createCommentVNode("", true),
      _cache[8] || (_cache[8] = createTextVNode()),
      $options.summary.totalValue ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
        _cache[4] || (_cache[4] = createBaseVNode("strong", null, "Order value:", -1)),
        createTextVNode(" " + toDisplayString($options.summary.totalValue) + " " + toDisplayString($options.market.counter), 1)
      ])) : createCommentVNode("", true),
      _cache[9] || (_cache[9] = createTextVNode()),
      $options.summary.totalFee ? (openBlock(), createElementBlock("div", _hoisted_8$3, [
        _cache[5] || (_cache[5] = createBaseVNode("strong", null, "Order fee:", -1)),
        createTextVNode(" " + toDisplayString($options.summary.totalFee) + " " + toDisplayString($options.summary.feeCurrency), 1)
      ])) : createCommentVNode("", true),
      _cache[10] || (_cache[10] = createTextVNode()),
      $options.summary.finalTotal ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
        createBaseVNode("strong", null, toDisplayString($props.isBuyOrder ? "Spent" : "Received") + ":", 1),
        createTextVNode(" " + toDisplayString($options.summary.finalTotal) + " " + toDisplayString($options.market.counter), 1)
      ])) : createCommentVNode("", true)
    ]),
    _cache[17] || (_cache[17] = createTextVNode()),
    $options.trades.length > 0 ? (openBlock(), createBlock(_component_TableLayout, {
      key: 0,
      columns: [
        { title: "Fill date and time", slotKey: "datetime" },
        { title: "Price", slotKey: "price", textAlignRight: true },
        { title: "Amount", slotKey: "amount", textAlignRight: true },
        { title: "Value", slotKey: "value", textAlignRight: true },
        { title: "Fee", slotKey: "fee", textAlignRight: true }
      ],
      items: $options.formattedTrades,
      "loading-placeholder-num": 1,
      loading: $data.isLoading,
      "is-sub-table": ""
    }, {
      datetime: withCtx(({ item }) => [
        createBaseVNode("span", {
          title: `Executed on ${item.time}`
        }, toDisplayString(item.timeShort), 9, _hoisted_10$3)
      ]),
      price: withCtx(({ item }) => [
        createBaseVNode("span", {
          class: "table-layout__text--bright-text table-layout__text--clickable",
          title: "Fill order form with this price",
          onClick: ($event) => $setup.tradeviewTriggerValueStore.setPriceSetByTrigger(item.decimalPrice)
        }, toDisplayString(item.price), 9, _hoisted_11$3)
      ]),
      amount: withCtx(({ item }) => [
        createBaseVNode("span", null, toDisplayString(item.amount) + " " + toDisplayString(item.base), 1)
      ]),
      value: withCtx(({ item }) => [
        createBaseVNode("span", null, toDisplayString(item.value) + " " + toDisplayString(item.counter), 1)
      ]),
      fee: withCtx(({ item }) => [
        createTextVNode(toDisplayString(item.fee) + " " + toDisplayString(item.feeCurrency), 1)
      ]),
      empty: withCtx(() => _cache[11] || (_cache[11] = [
        createTextVNode("\n        No trades.\n      ")
      ])),
      _: 1
    }, 8, ["items", "loading"])) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
const OrderHistoryDetails = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$e], ["__scopeId", "data-v-ba2af172"]]);
function Wt() {
  const e = useAttrs();
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img",
      ...e
    },
    [
      createBaseVNode("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Wt.compatConfig = {
  MODE: 3
};
function Tn() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      createBaseVNode("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Tn.compatConfig = {
  MODE: 3
};
function Wa() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Wa.compatConfig = {
  MODE: 3
};
function Va() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Va.compatConfig = {
  MODE: 3
};
function ja() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      createBaseVNode("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
ja.compatConfig = {
  MODE: 3
};
function Ka() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Ka.compatConfig = {
  MODE: 3
};
function Ga() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Ga.compatConfig = {
  MODE: 3
};
const et = (e, t) => t ? new Date(e.toLocaleString("en-US", { timeZone: t })) : new Date(e), Qa = (e, t, r) => {
  const a = Fa(e, t, r);
  return a || j();
}, hl = (e, t, r) => {
  const a = t.dateInTz ? et(new Date(e), t.dateInTz) : j(e);
  return r ? We(a, true) : a;
}, Fa = (e, t, r) => {
  if (!e) return null;
  const a = r ? We(j(e), true) : j(e);
  return t ? t.exactMatch ? hl(e, t, r) : et(a, t.timezone) : a;
}, bl = (e) => {
  const r = new Date(e.getFullYear(), 0, 1).getTimezoneOffset();
  return e.getTimezoneOffset() < r;
}, kl = (e, t) => {
  if (!e) return 0;
  const r = /* @__PURE__ */ new Date(), a = new Date(r.toLocaleString("en-US", { timeZone: "UTC" })), n = new Date(r.toLocaleString("en-US", { timeZone: e })), d = (bl(t ?? n) ? n : t ?? n).getTimezoneOffset() / 60;
  return (+a - +n) / (1e3 * 60 * 60) - d;
};
var ut = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(ut || {}), it = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(it || {}), Rt = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(Rt || {}), Ge = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(Ge || {});
const wl = ["timestamp", "date", "iso"];
var Je = /* @__PURE__ */ ((e) => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(Je || {}), Oe = /* @__PURE__ */ ((e) => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(Oe || {}), Nt = /* @__PURE__ */ ((e) => (e.MONTH_AND_YEAR = "MM-yyyy", e.YEAR = "yyyy", e.DATE = "dd-MM-yyyy", e))(Nt || {});
function sn(e) {
  return (t) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`)).slice(0, 2);
}
function Dl(e) {
  return (t) => format(et(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`), "UTC"), "EEEEEE", { locale: e });
}
const Ml = (e, t, r) => {
  const a = [1, 2, 3, 4, 5, 6, 7];
  let n;
  if (e !== null)
    try {
      n = a.map(Dl(e));
    } catch {
      n = a.map(sn(t));
    }
  else
    n = a.map(sn(t));
  const u = n.slice(0, r), d = n.slice(r + 1, n.length);
  return [n[r]].concat(...d).concat(...u);
}, qa = (e, t, r) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: Cn(n, t) });
  return r ? a.reverse() : a;
}, Sn = (e, t, r) => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((u) => {
    const d = u < 10 ? `0${u}` : u;
    return /* @__PURE__ */ new Date(`2017-${d}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const u = r === "long" ? "LLLL" : "LLL";
      return a.map((d, y) => {
        const i = format(et(d, "UTC"), u, { locale: e });
        return {
          text: i.charAt(0).toUpperCase() + i.substring(1),
          value: y
        };
      });
    } catch {
    }
  const n = new Intl.DateTimeFormat(t, { month: r, timeZone: "UTC" });
  return a.map((u, d) => {
    const y = n.format(u);
    return {
      text: y.charAt(0).toUpperCase() + y.substring(1),
      value: d
    };
  });
}, $l = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Le = (e) => {
  const t = unref(e);
  return t != null && t.$el ? t == null ? void 0 : t.$el : t;
}, Al = (e) => ({ type: "dot", ...e ?? {} }), Pn = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : false, Xa = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Ne = (e) => e, un = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, dn = (e) => e === null, Rn = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Tl = (e) => {
  const t = [], r = (a) => a.filter((n) => n);
  for (let a = 0; a < e.length; a += 3) {
    const n = [e[a], e[a + 1], e[a + 2]];
    t.push(r(n));
  }
  return t;
}, Xt = (e, t, r) => {
  const a = r != null, n = t != null;
  if (!a && !n) return false;
  const u = +r, d = +t;
  return a && n ? +e > u || +e < d : a ? +e > u : n ? +e < d : false;
}, zt = (e, t) => Tl(e).map((r) => r.map((a) => {
  const { active: n, disabled: u, isBetween: d, highlighted: y } = t(a);
  return {
    ...a,
    active: n,
    disabled: u,
    className: {
      dp__overlay_cell_active: n,
      dp__overlay_cell: !n,
      dp__overlay_cell_disabled: u,
      dp__overlay_cell_pad: true,
      dp__overlay_cell_active_disabled: u && n,
      dp__cell_in_between: d,
      "dp--highlighted": y
    }
  };
})), Dt = (e, t, r = false) => {
  e && t.allowStopPropagation && (r && e.stopImmediatePropagation(), e.stopPropagation());
}, Sl = () => [
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "[tabindex]:not([tabindex='-1'])",
  "[data-datepicker-instance]"
].join(", ");
function Pl(e, t) {
  let r = [...document.querySelectorAll(Sl())];
  r = r.filter((n) => !e.contains(n) || n.hasAttribute("data-datepicker-instance"));
  const a = r.indexOf(e);
  if (a >= 0 && (t ? a - 1 >= 0 : a + 1 <= r.length))
    return r[a + (t ? -1 : 1)];
}
const La = (e, t) => e == null ? void 0 : e.querySelector(`[data-dp-element="${t}"]`), Cn = (e, t) => new Intl.NumberFormat(t, { useGrouping: false, style: "decimal" }).format(e), Ja = (e, t) => format(e, t ?? Nt.DATE), Ta = (e) => Array.isArray(e), ca = (e, t, r) => t.get(Ja(e, r)), Rl = (e, t) => e ? t ? t instanceof Map ? !!ca(e, t) : t(j(e)) : false : true, Ze = (e, t, r = false, a) => {
  if (e.key === Oe.enter || e.key === Oe.space)
    return r && e.preventDefault(), t();
  if (a) return a(e);
}, Cl = () => "ontouchstart" in window || navigator.maxTouchPoints > 0, Ol = (e, t) => e ? Nt.MONTH_AND_YEAR : t ? Nt.YEAR : Nt.DATE, On = (e) => e < 10 ? `0${e}` : e, cn = (e, t, r, a, n, u) => {
  const d = parse(e, t.slice(0, e.length), /* @__PURE__ */ new Date(), { locale: u });
  return isValid(d) && isDate(d) ? a || n ? d : set(d, {
    hours: +r.hours,
    minutes: +(r == null ? void 0 : r.minutes),
    seconds: +(r == null ? void 0 : r.seconds),
    milliseconds: 0
  }) : null;
}, Bl = (e, t, r, a, n, u) => {
  const d = Array.isArray(r) ? r[0] : r;
  if (typeof t == "string")
    return cn(e, t, d, a, n, u);
  if (Array.isArray(t)) {
    let y = null;
    for (const i of t)
      if (y = cn(e, i, d, a, n, u), y)
        break;
    return y;
  }
  return typeof t == "function" ? t(e) : null;
}, j = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), _l = (e, t, r) => {
  if (t) {
    const n = (e.getMonth() + 1).toString().padStart(2, "0"), u = e.getDate().toString().padStart(2, "0"), d = e.getHours().toString().padStart(2, "0"), y = e.getMinutes().toString().padStart(2, "0"), i = r ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${n}-${u}T${d}:${y}:${i}.000Z`;
  }
  const a = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(a).toISOString();
}, We = (e, t) => {
  const r = j(JSON.parse(JSON.stringify(e))), a = set(r, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  return t ? startOfMonth(a) : a;
}, Mt = (e, t, r, a) => {
  let n = e ? j(e) : j();
  return (t || t === 0) && (n = setHours(n, +t)), (r || r === 0) && (n = setMinutes(n, +r)), (a || a === 0) && (n = setSeconds(n, +a)), setMilliseconds(n, 0);
}, Ye = (e, t) => !e || !t ? false : isBefore(We(e), We(t)), Ae = (e, t) => !e || !t ? false : isEqual(We(e), We(t)), Ee = (e, t) => !e || !t ? false : isAfter(We(e), We(t)), Jt = (e, t, r) => e != null && e[0] && (e != null && e[1]) ? Ee(r, e[0]) && Ye(r, e[1]) : e != null && e[0] && t ? Ee(r, e[0]) && Ye(r, t) || Ye(r, e[0]) && Ee(r, t) : false, dt = (e) => {
  const t = set(new Date(e), { date: 1 });
  return We(t);
}, Sa = (e, t, r) => t && (r || r === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((a) => a === t ? [a, r] : [a, isNaN(+e[a]) ? void 0 : +e[a]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, Ct = (e) => ({
  hours: getHours(e),
  minutes: getMinutes(e),
  seconds: getSeconds(e)
}), Bn = (e, t) => {
  if (t) {
    const r = getYear(j(t));
    if (r > e) return 12;
    if (r === e) return getMonth(j(t));
  }
}, _n = (e, t) => {
  if (t) {
    const r = getYear(j(t));
    return r < e ? -1 : r === e ? getMonth(j(t)) : void 0;
  }
}, Ht = (e) => {
  if (e) return getYear(j(e));
}, Yn = (e, t) => {
  const r = Ee(e, t) ? t : e, a = Ee(t, e) ? t : e;
  return eachDayOfInterval({ start: r, end: a });
}, Yl = (e) => {
  const t = addMonths(e, 1);
  return { month: getMonth(t), year: getYear(t) };
}, pt = (e, t) => {
  const r = startOfWeek(e, { weekStartsOn: +t }), a = endOfWeek(e, { weekStartsOn: +t });
  return [r, a];
}, In = (e, t) => {
  const r = {
    hours: getHours(j()),
    minutes: getMinutes(j()),
    seconds: t ? getSeconds(j()) : 0
  };
  return Object.assign(r, e);
}, wt = (e, t, r) => [set(j(e), { date: 1 }), set(j(), { month: t, year: r, date: 1 })], yt = (e, t, r) => {
  let a = e ? j(e) : j();
  return (t || t === 0) && (a = setMonth(a, t)), r && (a = setYear(a, r)), a;
}, En = (e, t, r, a, n) => {
  if (!a || n && !t || !n && !r) return false;
  const u = n ? addMonths(e, 1) : subMonths(e, 1), d = [getMonth(u), getYear(u)];
  return n ? !El(...d, t) : !Il(...d, r);
}, Il = (e, t, r) => Ye(...wt(r, e, t)) || Ae(...wt(r, e, t)), El = (e, t, r) => Ee(...wt(r, e, t)) || Ae(...wt(r, e, t)), Nn = (e, t, r, a, n, u, d) => {
  if (typeof t == "function" && !d) return t(e);
  const y = r ? { locale: r } : void 0;
  return Array.isArray(e) ? `${format(e[0], u, y)}${n && !e[1] ? "" : a}${e[1] ? format(e[1], u, y) : ""}` : format(e, u, y);
}, Yt = (e) => {
  if (e) return null;
  throw new Error(Xa.prop("partial-range"));
}, ra = (e, t) => {
  if (t) return e();
  throw new Error(Xa.prop("range"));
}, za = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false, Nl = (e, t) => set(t ?? j(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), Pa = (e, t, r, a) => {
  if (!e) return true;
  if (a) {
    const n = r === "max" ? isBefore(e, t) : isAfter(e, t), u = { seconds: 0, milliseconds: 0 };
    return n || isEqual(set(e, u), set(t, u));
  }
  return r === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime();
}, Ra = (e, t, r) => e ? Nl(e, t) : j(r ?? t), fn = (e, t, r, a, n) => {
  if (Array.isArray(a)) {
    const d = Ra(e, a[0], t), y = Ra(e, a[1], t);
    return Pa(a[0], d, r, !!t) && Pa(a[1], y, r, !!t) && n;
  }
  const u = Ra(e, a, t);
  return Pa(a, u, r, !!t) && n;
}, Ca = (e) => set(j(), Ct(e)), Fl = (e, t, r) => {
  if (e instanceof Map) {
    const a = `${On(r + 1)}-${t}`;
    return e.size ? e.has(a) : false;
  }
  return false;
}, Ll = (e, t, r) => {
  if (e instanceof Map) {
    const a = `${On(r + 1)}-${t}`;
    return e.size ? e.has(a) : true;
  }
  return true;
}, Fn = (e, t, r) => typeof e == "function" ? e({ month: t, year: r }) : !!e.months.find((a) => a.month === t && a.year === r), Za = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t), Ha = (e) => `dp-${format(e, "yyyy-MM-dd")}`, vn = (e, t) => {
  const r = subDays(We(t), e), a = addDays(We(t), e);
  return { before: r, after: a };
}, jt = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
}), Ln = () => {
  const e = (a) => {
    jt.menuFocused = a;
  }, t = (a) => {
    jt.shiftKeyInMenu !== a && (jt.shiftKeyInMenu = a);
  };
  return {
    control: computed(() => ({ shiftKeyInMenu: jt.shiftKeyInMenu, menuFocused: jt.menuFocused })),
    setMenuFocused: e,
    setShiftKey: t
  };
}, Ce = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Oa = ref(null), oa = ref(false), Ba = ref(false), _a = ref(false), Ya = ref(false), Ke = ref(0), Ie = ref(0), At = () => {
  const e = computed(() => oa.value ? [...Ce.selectionGrid, Ce.actionRow].filter((f) => f.length) : Ba.value ? [
    ...Ce.timePicker[0],
    ...Ce.timePicker[1],
    Ya.value ? [] : [Oa.value],
    Ce.actionRow
  ].filter((f) => f.length) : _a.value ? [...Ce.monthPicker, Ce.actionRow] : [Ce.monthYear, ...Ce.calendar, Ce.time, Ce.actionRow].filter((f) => f.length)), t = (f) => {
    Ke.value = f ? Ke.value + 1 : Ke.value - 1;
    let I = null;
    e.value[Ie.value] && (I = e.value[Ie.value][Ke.value]), !I && e.value[Ie.value + (f ? 1 : -1)] ? (Ie.value = Ie.value + (f ? 1 : -1), Ke.value = f ? 0 : e.value[Ie.value].length - 1) : I || (Ke.value = f ? Ke.value - 1 : Ke.value + 1);
  }, r = (f) => {
    if (Ie.value === 0 && !f || Ie.value === e.value.length && f) return;
    Ie.value = f ? Ie.value + 1 : Ie.value - 1, e.value[Ie.value] ? e.value[Ie.value] && !e.value[Ie.value][Ke.value] && Ke.value !== 0 && (Ke.value = e.value[Ie.value].length - 1) : Ie.value = f ? Ie.value - 1 : Ie.value + 1;
  }, a = (f) => {
    let I = null;
    e.value[Ie.value] && (I = e.value[Ie.value][Ke.value]), I ? I.focus({ preventScroll: !oa.value }) : Ke.value = f ? Ke.value - 1 : Ke.value + 1;
  }, n = () => {
    t(true), a(true);
  }, u = () => {
    t(false), a(false);
  }, d = () => {
    r(false), a(true);
  }, y = () => {
    r(true), a(true);
  }, i = (f, I) => {
    Ce[I] = f;
  }, _2 = (f, I) => {
    Ce[I] = f;
  }, c = () => {
    Ke.value = 0, Ie.value = 0;
  };
  return {
    buildMatrix: i,
    buildMultiLevelMatrix: _2,
    setTimePickerBackRef: (f) => {
      Oa.value = f;
    },
    setSelectionGrid: (f) => {
      oa.value = f, c(), f || (Ce.selectionGrid = []);
    },
    setTimePicker: (f, I = false) => {
      Ba.value = f, Ya.value = I, c(), f || (Ce.timePicker[0] = [], Ce.timePicker[1] = []);
    },
    setTimePickerElements: (f, I = 0) => {
      Ce.timePicker[I] = f;
    },
    arrowRight: n,
    arrowLeft: u,
    arrowUp: d,
    arrowDown: y,
    clearArrowNav: () => {
      Ce.monthYear = [], Ce.calendar = [], Ce.time = [], Ce.actionRow = [], Ce.selectionGrid = [], Ce.timePicker[0] = [], Ce.timePicker[1] = [], oa.value = false, Ba.value = false, Ya.value = false, _a.value = false, c(), Oa.value = null;
    },
    setMonthPicker: (f) => {
      _a.value = f, c();
    },
    refSets: Ce
    // exposed for testing
  };
}, mn = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), zl = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (t) => `Increment ${t}`,
  decrementValue: (t) => `Decrement ${t}`,
  openTpOverlay: (t) => `Open ${t} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  clearInput: "Clear value",
  calendarIcon: "Calendar icon",
  timePicker: "Time picker",
  monthPicker: (t) => `Month picker${t ? " overlay" : ""}`,
  yearPicker: (t) => `Year picker${t ? " overlay" : ""}`,
  timeOverlay: (t) => `${t} overlay`,
  ...e ?? {}
}), pn = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, Hl = (e) => {
  const t = typeof e == "object" && e, r = {
    static: true,
    solo: false
  };
  if (!e) return { ...r, count: pn(false) };
  const a = t ? e : {}, n = t ? a.count ?? true : e, u = pn(n);
  return Object.assign(r, a, { count: u });
}, Ul = (e, t, r) => e || (typeof r == "string" ? r : t), Wl = (e) => typeof e == "boolean" ? e ? mn({}) : false : mn(e), Vl = (e) => {
  const t = {
    enterSubmit: true,
    tabSubmit: true,
    openMenu: "open",
    selectOnFocus: false,
    rangeSeparator: " - ",
    escClose: true
  };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: true } : { ...t, enabled: e };
}, jl = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), Kl = (e) => ({
  showSelect: true,
  showCancel: true,
  showNow: false,
  showPreview: true,
  ...e ?? {}
}), Gl = (e) => {
  const t = { input: false };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: true } : {
    enabled: e,
    ...t
  };
}, Ql = (e) => ({ ...{
  allowStopPropagation: true,
  closeOnScroll: false,
  modeHeight: 255,
  allowPreventDefault: false,
  closeOnClearValue: true,
  closeOnAutoApply: true,
  noSwipe: false,
  keepActionRow: false,
  onClickOutside: void 0,
  tabOutClosesMenu: true,
  arrowLeft: void 0,
  keepViewOnOffsetClick: false,
  timeArrowHoldThreshold: 0,
  shadowDom: false,
  mobileBreakpoint: 600,
  setDateOnMenuClose: false
}, ...e ?? {} }), ql = (e) => {
  const t = {
    dates: Array.isArray(e) ? e.map((r) => j(r)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: [],
    options: { highlightDisabled: false }
  };
  return typeof e == "function" ? e : { ...t, ...e ?? {} };
}, Xl = (e) => typeof e == "object" ? {
  type: (e == null ? void 0 : e.type) ?? "local",
  hideOnOffsetDates: (e == null ? void 0 : e.hideOnOffsetDates) ?? false
} : {
  type: e,
  hideOnOffsetDates: false
}, Jl = (e) => {
  const t = {
    noDisabledRange: false,
    showLastInRange: true,
    minMaxRawRange: false,
    partialRange: true,
    disableTimeRangeValidation: false,
    maxRange: void 0,
    minRange: void 0,
    autoRange: void 0,
    fixedStart: false,
    fixedEnd: false
  };
  return typeof e == "object" ? { enabled: true, ...t, ...e } : {
    enabled: e,
    ...t
  };
}, Zl = (e) => e ? typeof e == "string" ? {
  timezone: e,
  exactMatch: false,
  dateInTz: void 0,
  emitTimezone: void 0,
  convertModel: true
} : {
  timezone: e.timezone,
  exactMatch: e.exactMatch ?? false,
  dateInTz: e.dateInTz ?? void 0,
  emitTimezone: e.emitTimezone ?? void 0,
  convertModel: e.convertModel ?? true
} : { timezone: void 0, exactMatch: false, emitTimezone: void 0 }, Ia = (e, t, r, a) => new Map(
  e.map((n) => {
    const u = Qa(n, t, a);
    return [Ja(u, r), u];
  })
), xl = (e, t) => e.length ? new Map(
  e.map((r) => {
    const a = Qa(r.date, t);
    return [Ja(a, Nt.DATE), r];
  })
) : null, er = (e) => {
  var r;
  const t = Ol(e.isMonthPicker, e.isYearPicker);
  return {
    minDate: Fa(e.minDate, e.timezone, e.isSpecific),
    maxDate: Fa(e.maxDate, e.timezone, e.isSpecific),
    disabledDates: Ta(e.disabledDates) ? Ia(e.disabledDates, e.timezone, t, e.isSpecific) : e.disabledDates,
    allowedDates: Ta(e.allowedDates) ? Ia(e.allowedDates, e.timezone, t, e.isSpecific) : null,
    highlight: typeof e.highlight == "object" && Ta((r = e.highlight) == null ? void 0 : r.dates) ? Ia(e.highlight.dates, e.timezone, t) : e.highlight,
    markers: xl(e.markers, e.timezone)
  };
}, tr = (e) => typeof e == "boolean" ? { enabled: e, dragSelect: true, limit: null } : {
  enabled: !!e,
  limit: e.limit ? +e.limit : null,
  dragSelect: e.dragSelect ?? true
}, ar = (e) => ({
  ...Object.fromEntries(
    Object.keys(e).map((r) => {
      const a = r, n = e[a], u = typeof e[a] == "string" ? { [n]: true } : Object.fromEntries(n.map((d) => [d, true]));
      return [r, u];
    })
  )
}), _e = (e) => {
  const t = () => {
    const ee = e.enableSeconds ? ":ss" : "", x = e.enableMinutes ? ":mm" : "";
    return e.is24 ? `HH${x}${ee}` : `hh${x}${ee} aa`;
  }, r = () => {
    var ee;
    return e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${((ee = H.value) == null ? void 0 : ee.type) === "iso" ? "II" : "ww"}-RR` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy";
  }, a = (ee) => In(ee, e.enableSeconds), n = () => z.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [a(e.startTime[0]), a(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? a(e.startTime) : null, u = computed(() => Hl(e.multiCalendars)), d = computed(() => n()), y = computed(() => zl(e.ariaLabels)), i = computed(() => jl(e.filters)), _2 = computed(() => Wl(e.transitions)), c = computed(() => Kl(e.actionRow)), C = computed(
    () => Ul(e.previewFormat, e.format, r())
  ), m = computed(() => Vl(e.textInput)), P = computed(() => Gl(e.inline)), U = computed(() => Ql(e.config)), N = computed(() => ql(e.highlight)), H = computed(() => Xl(e.weekNumbers)), f = computed(() => Zl(e.timezone)), I = computed(() => tr(e.multiDates)), k = computed(
    () => er({
      minDate: e.minDate,
      maxDate: e.maxDate,
      disabledDates: e.disabledDates,
      allowedDates: e.allowedDates,
      highlight: N.value,
      markers: e.markers,
      timezone: f.value,
      isSpecific: e.monthPicker || e.yearPicker || e.quarterPicker,
      isMonthPicker: e.monthPicker,
      isYearPicker: e.yearPicker
    })
  ), z = computed(() => Jl(e.range)), q = computed(() => ar(e.ui));
  return {
    defaultedTransitions: _2,
    defaultedMultiCalendars: u,
    defaultedStartTime: d,
    defaultedAriaLabels: y,
    defaultedFilters: i,
    defaultedActionRow: c,
    defaultedPreviewFormat: C,
    defaultedTextInput: m,
    defaultedInline: P,
    defaultedConfig: U,
    defaultedHighlight: N,
    defaultedWeekNumbers: H,
    defaultedRange: z,
    propDates: k,
    defaultedTz: f,
    defaultedMultiDates: I,
    defaultedUI: q,
    getDefaultPattern: r,
    getDefaultStartTime: n
  };
}, nr = (e, t, r) => {
  const a = ref(), { defaultedTextInput: n, defaultedRange: u, defaultedTz: d, defaultedMultiDates: y, getDefaultPattern: i } = _e(t), _2 = ref(""), c = toRef(t, "format"), C = toRef(t, "formatLocale");
  watch(
    a,
    () => {
      typeof t.onInternalModelChange == "function" && e("internal-model-change", a.value, R(true));
    },
    { deep: true }
  ), watch(u, (l, D) => {
    l.enabled !== D.enabled && (a.value = null);
  }), watch(c, () => {
    W();
  });
  const m = (l) => d.value.timezone && d.value.convertModel ? et(l, d.value.timezone) : l, P = (l) => {
    if (d.value.timezone && d.value.convertModel) {
      const D = kl(d.value.timezone, l);
      return addHours(l, D);
    }
    return l;
  }, U = (l, D, ue = false) => Nn(
    l,
    t.format,
    t.formatLocale,
    n.value.rangeSeparator,
    t.modelAuto,
    D ?? i(),
    ue
  ), N = (l) => l ? t.modelType ? oe(l) : {
    hours: getHours(l),
    minutes: getMinutes(l),
    seconds: t.enableSeconds ? getSeconds(l) : 0
  } : null, H = (l) => t.modelType ? oe(l) : { month: getMonth(l), year: getYear(l) }, f = (l) => Array.isArray(l) ? y.value.enabled ? l.map((D) => I(D, setYear(j(), D))) : ra(
    () => [
      setYear(j(), l[0]),
      l[1] ? setYear(j(), l[1]) : Yt(u.value.partialRange)
    ],
    u.value.enabled
  ) : setYear(j(), +l), I = (l, D) => (typeof l == "string" || typeof l == "number") && t.modelType ? T(l) : D, k = (l) => Array.isArray(l) ? [
    I(
      l[0],
      Mt(null, +l[0].hours, +l[0].minutes, l[0].seconds)
    ),
    I(
      l[1],
      Mt(null, +l[1].hours, +l[1].minutes, l[1].seconds)
    )
  ] : I(l, Mt(null, l.hours, l.minutes, l.seconds)), z = (l) => {
    const D = set(j(), { date: 1 });
    return Array.isArray(l) ? y.value.enabled ? l.map((ue) => I(ue, yt(D, +ue.month, +ue.year))) : ra(
      () => [
        I(l[0], yt(D, +l[0].month, +l[0].year)),
        I(
          l[1],
          l[1] ? yt(D, +l[1].month, +l[1].year) : Yt(u.value.partialRange)
        )
      ],
      u.value.enabled
    ) : I(l, yt(D, +l.month, +l.year));
  }, q = (l) => {
    if (Array.isArray(l))
      return l.map((D) => T(D));
    throw new Error(Xa.dateArr("multi-dates"));
  }, ee = (l) => {
    if (Array.isArray(l) && u.value.enabled) {
      const D = l[0], ue = l[1];
      return [
        j(Array.isArray(D) ? D[0] : null),
        Array.isArray(ue) && ue.length ? j(ue[0]) : null
      ];
    }
    return j(l[0]);
  }, x = (l) => t.modelAuto ? Array.isArray(l) ? [T(l[0]), T(l[1])] : t.autoApply ? [T(l)] : [T(l), null] : Array.isArray(l) ? ra(
    () => l[1] ? [
      T(l[0]),
      l[1] ? T(l[1]) : Yt(u.value.partialRange)
    ] : [T(l[0])],
    u.value.enabled
  ) : T(l), S = () => {
    Array.isArray(a.value) && u.value.enabled && a.value.length === 1 && a.value.push(Yt(u.value.partialRange));
  }, X = () => {
    const l = a.value;
    return [
      oe(l[0]),
      l[1] ? oe(l[1]) : Yt(u.value.partialRange)
    ];
  }, O = () => a.value[1] ? X() : oe(Ne(a.value[0])), K = () => (a.value || []).map((l) => oe(l)), fe = (l = false) => (l || S(), t.modelAuto ? O() : y.value.enabled ? K() : Array.isArray(a.value) ? ra(() => X(), u.value.enabled) : oe(Ne(a.value))), me = (l) => !l || Array.isArray(l) && !l.length ? null : t.timePicker ? k(Ne(l)) : t.monthPicker ? z(Ne(l)) : t.yearPicker ? f(Ne(l)) : y.value.enabled ? q(Ne(l)) : t.weekPicker ? ee(Ne(l)) : x(Ne(l)), v = (l) => {
    const D = me(l);
    za(Ne(D)) ? (a.value = Ne(D), W()) : (a.value = null, _2.value = "");
  }, L = () => {
    const l = (D) => format(D, n.value.format);
    return `${l(a.value[0])} ${n.value.rangeSeparator} ${a.value[1] ? l(a.value[1]) : ""}`;
  }, ne = () => r.value && a.value ? Array.isArray(a.value) ? L() : format(a.value, n.value.format) : U(a.value), p = () => a.value ? y.value.enabled ? a.value.map((l) => U(l)).join("; ") : n.value.enabled && typeof n.value.format == "string" ? ne() : U(a.value) : "", W = () => {
    !t.format || typeof t.format == "string" || n.value.enabled && typeof n.value.format == "string" ? _2.value = p() : _2.value = t.format(a.value);
  }, T = (l) => {
    if (t.utc) {
      const D = new Date(l);
      return t.utc === "preserve" ? new Date(D.getTime() + D.getTimezoneOffset() * 6e4) : D;
    }
    return t.modelType ? wl.includes(t.modelType) ? m(new Date(l)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? m(
      parse(l, i(), /* @__PURE__ */ new Date(), { locale: C.value })
    ) : m(
      parse(l, t.modelType, /* @__PURE__ */ new Date(), { locale: C.value })
    ) : m(new Date(l));
  }, oe = (l) => l ? t.utc ? _l(l, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +P(l) : t.modelType === "iso" ? P(l).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? U(P(l)) : U(P(l), t.modelType, true) : P(l) : "", $ = (l, D = false, ue = false) => {
    if (ue) return l;
    if (e("update:model-value", l), d.value.emitTimezone && D) {
      const M = Array.isArray(l) ? l.map((he) => et(Ne(he), d.value.emitTimezone)) : et(Ne(l), d.value.emitTimezone);
      e("update:model-timezone-value", M);
    }
  }, Y = (l) => Array.isArray(a.value) ? y.value.enabled ? a.value.map((D) => l(D)) : [
    l(a.value[0]),
    a.value[1] ? l(a.value[1]) : Yt(u.value.partialRange)
  ] : l(Ne(a.value)), g = () => {
    if (Array.isArray(a.value)) {
      const l = pt(a.value[0], t.weekStart), D = a.value[1] ? pt(a.value[1], t.weekStart) : [];
      return [l.map((ue) => j(ue)), D.map((ue) => j(ue))];
    }
    return pt(a.value, t.weekStart).map((l) => j(l));
  }, Z = (l, D) => $(Ne(Y(l)), false, D), se = (l) => {
    const D = g();
    return l ? D : e("update:model-value", g());
  }, R = (l = false) => (l || W(), t.monthPicker ? Z(H, l) : t.timePicker ? Z(N, l) : t.yearPicker ? Z(getYear, l) : t.weekPicker ? se(l) : $(fe(l), true, l));
  return {
    inputValue: _2,
    internalModelValue: a,
    checkBeforeEmit: () => a.value ? u.value.enabled ? u.value.partialRange ? a.value.length >= 1 : a.value.length === 2 : !!a.value : false,
    parseExternalModelValue: v,
    formatInputValue: W,
    emitModelValue: R
  };
}, lr = (e, t) => {
  const { defaultedFilters: r, propDates: a } = _e(e), { validateMonthYearInRange: n } = Tt(e), u = (c, C) => {
    let m = c;
    return r.value.months.includes(getMonth(m)) ? (m = C ? addMonths(c, 1) : subMonths(c, 1), u(m, C)) : m;
  }, d = (c, C) => {
    let m = c;
    return r.value.years.includes(getYear(m)) ? (m = C ? addYears(c, 1) : subYears(c, 1), d(m, C)) : m;
  }, y = (c, C = false) => {
    const m = set(j(), { month: e.month, year: e.year });
    let P = c ? addMonths(m, 1) : subMonths(m, 1);
    e.disableYearSelect && (P = setYear(P, e.year));
    let U = getMonth(P), N = getYear(P);
    r.value.months.includes(U) && (P = u(P, c), U = getMonth(P), N = getYear(P)), r.value.years.includes(N) && (P = d(P, c), N = getYear(P)), n(U, N, c, e.preventMinMaxNavigation) && i(U, N, C);
  }, i = (c, C, m) => {
    t("update-month-year", { month: c, year: C, fromNav: m });
  }, _2 = computed(() => (c) => En(
    set(j(), { month: e.month, year: e.year }),
    a.value.maxDate,
    a.value.minDate,
    e.preventMinMaxNavigation,
    c
  ));
  return { handleMonthYearChange: y, isDisabled: _2, updateMonthYear: i };
}, va = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: [Boolean, String], default: true },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: [String, Object], default: null },
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  disableYearSelect: { type: Boolean, default: false },
  dayClass: {
    type: Function,
    default: null
  },
  yearRange: { type: Array, default: () => [1900, 2100] },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: false },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: false },
  preventMinMaxNavigation: { type: Boolean, default: false },
  reverseYears: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  highlight: {
    type: [Function, Object],
    default: null
  },
  teleport: { type: [Boolean, String, Object], default: null },
  teleportCenter: { type: Boolean, default: false },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function, Object],
    default: null
  },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: [Object, Boolean], default: false },
  ignoreTimeValidation: { type: Boolean, default: false },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  alwaysClearable: { type: Boolean, default: false },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  timePicker: { type: Boolean, default: false },
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: [Boolean, Object], default: false },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  inline: { type: [Boolean, Object], default: false },
  textInput: { type: [Boolean, Object], default: false },
  sixWeeks: { type: [Boolean, String], default: false },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: false },
  disabledTimes: { type: [Function, Array], default: void 0 },
  timePickerInline: { type: Boolean, default: false },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: false },
  yearFirst: { type: Boolean, default: false },
  loading: { type: Boolean, default: false },
  onInternalModelChange: { type: [Function, Object], default: null },
  enableMinutes: { type: Boolean, default: true },
  ui: { type: Object, default: () => ({}) }
}, ct = {
  ...va,
  shadow: { type: Boolean, default: false },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  noOverlayFocus: { type: Boolean, default: false },
  collapse: { type: Boolean, default: false },
  menuWrapRef: { type: Object, default: null },
  getInputRect: { type: Function, default: () => ({}) },
  isTextInputDate: { type: Boolean, default: false },
  isMobile: { type: Boolean, default: void 0 }
}, rr = ["title"], or = ["disabled"], sr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: false },
    calendarWidth: { type: Number, default: 0 },
    ...ct
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: t }) {
    const r = t, a = e, {
      defaultedActionRow: n,
      defaultedPreviewFormat: u,
      defaultedMultiCalendars: d,
      defaultedTextInput: y,
      defaultedInline: i,
      defaultedRange: _2,
      defaultedMultiDates: c
    } = _e(a), { isTimeValid: C, isMonthValid: m } = Tt(a), { buildMatrix: P } = At(), U = ref(null), N = ref(null), H = ref(false), f = ref({}), I = ref(null), k = ref(null);
    onMounted(() => {
      a.arrowNavigation && P([Le(U), Le(N)], "actionRow"), z(), window.addEventListener("resize", z);
    }), onUnmounted(() => {
      window.removeEventListener("resize", z);
    });
    const z = () => {
      H.value = false, setTimeout(() => {
        var ne, p;
        const v = (ne = I.value) == null ? void 0 : ne.getBoundingClientRect(), L = (p = k.value) == null ? void 0 : p.getBoundingClientRect();
        v && L && (f.value.maxWidth = `${L.width - v.width - 20}px`), H.value = true;
      }, 0);
    }, q = computed(() => _2.value.enabled && !_2.value.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : true), ee = computed(
      () => !C.value(a.internalModelValue) || !m.value(a.internalModelValue) || !q.value
    ), x = () => {
      const v = u.value;
      return a.timePicker || a.monthPicker, v(Ne(a.internalModelValue));
    }, S = () => {
      const v = a.internalModelValue;
      return d.value.count > 0 ? `${X(v[0])} - ${X(v[1])}` : [X(v[0]), X(v[1])];
    }, X = (v) => Nn(
      v,
      u.value,
      a.formatLocale,
      y.value.rangeSeparator,
      a.modelAuto,
      u.value
    ), O = computed(() => !a.internalModelValue || !a.menuMount ? "" : typeof u.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? S() : c.value.enabled ? a.internalModelValue.map((v) => `${X(v)}`) : a.modelAuto ? `${X(a.internalModelValue[0])}` : `${X(a.internalModelValue[0])} -` : X(a.internalModelValue) : x()), K = () => c.value.enabled ? "; " : " - ", fe = computed(
      () => Array.isArray(O.value) ? O.value.join(K()) : O.value
    ), me = () => {
      C.value(a.internalModelValue) && m.value(a.internalModelValue) && q.value ? r("select-date") : r("invalid-select");
    };
    return (v, L) => (openBlock(), createElementBlock("div", {
      ref_key: "actionRowRef",
      ref: k,
      class: "dp__action_row"
    }, [
      v.$slots["action-row"] ? renderSlot(v.$slots, "action-row", normalizeProps(mergeProps({ key: 0 }, {
        internalModelValue: v.internalModelValue,
        disabled: ee.value,
        selectDate: () => v.$emit("select-date"),
        closePicker: () => v.$emit("close-picker")
      }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        unref(n).showPreview ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dp__selection_preview",
          title: fe.value,
          style: normalizeStyle(f.value)
        }, [
          v.$slots["action-preview"] && H.value ? renderSlot(v.$slots, "action-preview", {
            key: 0,
            value: v.internalModelValue
          }) : createCommentVNode("", true),
          !v.$slots["action-preview"] && H.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(fe.value), 1)
          ], 64)) : createCommentVNode("", true)
        ], 12, rr)) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "actionBtnContainer",
          ref: I,
          class: "dp__action_buttons",
          "data-dp-element": "action-row"
        }, [
          v.$slots["action-buttons"] ? renderSlot(v.$slots, "action-buttons", {
            key: 0,
            value: v.internalModelValue
          }) : createCommentVNode("", true),
          v.$slots["action-buttons"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !unref(i).enabled && unref(n).showCancel ? (openBlock(), createElementBlock("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: U,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: L[0] || (L[0] = (ne) => v.$emit("close-picker")),
              onKeydown: L[1] || (L[1] = (ne) => unref(Ze)(ne, () => v.$emit("close-picker")))
            }, toDisplayString(v.cancelText), 545)) : createCommentVNode("", true),
            unref(n).showNow ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: L[2] || (L[2] = (ne) => v.$emit("select-now")),
              onKeydown: L[3] || (L[3] = (ne) => unref(Ze)(ne, () => v.$emit("select-now")))
            }, toDisplayString(v.nowButtonLabel), 33)) : createCommentVNode("", true),
            unref(n).showSelect ? (openBlock(), createElementBlock("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: N,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: ee.value,
              "data-test-id": "select-button",
              onKeydown: L[4] || (L[4] = (ne) => unref(Ze)(ne, () => me())),
              onClick: me
            }, toDisplayString(v.selectText), 41, or)) : createCommentVNode("", true)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
}), ur = ["role", "aria-label", "tabindex"], ir = { class: "dp__selection_grid_header" }, dr = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"], cr = ["aria-label"], ea = /* @__PURE__ */ defineComponent({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    ariaLabels: {},
    overlayLabel: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: t, emit: r }) {
    const { setSelectionGrid: a, buildMultiLevelMatrix: n, setMonthPicker: u } = At(), d = r, y = e, { defaultedAriaLabels: i, defaultedTextInput: _2, defaultedConfig: c } = _e(
      y
    ), { hideNavigationButtons: C } = ya(), m = ref(false), P = ref(null), U = ref(null), N = ref([]), H = ref(), f = ref(null), I = ref(0), k = ref(null);
    onBeforeUpdate(() => {
      P.value = null;
    }), onMounted(() => {
      nextTick().then(() => K()), y.noOverlayFocus || q(), z(true);
    }), onUnmounted(() => z(false));
    const z = (Y) => {
      var g;
      y.arrowNavigation && ((g = y.headerRefs) != null && g.length ? u(Y) : a(Y));
    }, q = () => {
      var g;
      const Y = Le(U);
      Y && (_2.value.enabled || (P.value ? (g = P.value) == null || g.focus({ preventScroll: true }) : Y.focus({ preventScroll: true })), m.value = Y.clientHeight < Y.scrollHeight);
    }, ee = computed(
      () => ({
        dp__overlay: true,
        "dp--overlay-absolute": !y.useRelative,
        "dp--overlay-relative": y.useRelative
      })
    ), x = computed(
      () => y.useRelative ? { height: `${y.height}px`, width: "var(--dp-menu-min-width)" } : void 0
    ), S = computed(() => ({
      dp__overlay_col: true
    })), X = computed(
      () => ({
        dp__btn: true,
        dp__button: true,
        dp__overlay_action: true,
        dp__over_action_scroll: m.value,
        dp__button_bottom: y.isLast
      })
    ), O = computed(() => {
      var Y, g;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((Y = y.items) == null ? void 0 : Y.length) <= 6,
        dp__container_block: ((g = y.items) == null ? void 0 : g.length) > 6
      };
    });
    watch(
      () => y.items,
      () => K(false),
      { deep: true }
    );
    const K = (Y = true) => {
      nextTick().then(() => {
        const g = Le(P), Z = Le(U), se = Le(f), R = Le(k), ae = se ? se.getBoundingClientRect().height : 0;
        Z && (Z.getBoundingClientRect().height ? I.value = Z.getBoundingClientRect().height - ae : I.value = c.value.modeHeight - ae), g && R && Y && (R.scrollTop = g.offsetTop - R.offsetTop - (I.value / 2 - g.getBoundingClientRect().height) - ae);
      });
    }, fe = (Y) => {
      Y.disabled || d("selected", Y.value);
    }, me = () => {
      d("toggle"), d("reset-flow");
    }, v = () => {
      y.escClose && me();
    }, L = (Y, g, Z, se) => {
      Y && ((g.active || g.value === y.focusValue) && (P.value = Y), y.arrowNavigation && (Array.isArray(N.value[Z]) ? N.value[Z][se] = Y : N.value[Z] = [Y], ne()));
    }, ne = () => {
      var g, Z;
      const Y = (g = y.headerRefs) != null && g.length ? [y.headerRefs].concat(N.value) : N.value.concat([y.skipButtonRef ? [] : [f.value]]);
      n(Ne(Y), (Z = y.headerRefs) != null && Z.length ? "monthPicker" : "selectionGrid");
    }, p = (Y) => {
      y.arrowNavigation || Dt(Y, c.value, true);
    }, W = (Y) => {
      H.value = Y, d("hover-value", Y);
    }, T = () => {
      if (me(), !y.isLast) {
        const Y = La(y.menuWrapRef ?? null, "action-row");
        if (Y) {
          const g = Rn(Y);
          g == null || g.focus();
        }
      }
    }, oe = (Y) => {
      switch (Y.key) {
        case Oe.esc:
          return v();
        case Oe.arrowLeft:
          return p(Y);
        case Oe.arrowRight:
          return p(Y);
        case Oe.arrowUp:
          return p(Y);
        case Oe.arrowDown:
          return p(Y);
        default:
          return;
      }
    }, $ = (Y) => {
      if (Y.key === Oe.enter) return me();
      if (Y.key === Oe.tab) return T();
    };
    return t({ focusGrid: q }), (Y, g) => {
      var Z;
      return openBlock(), createElementBlock("div", {
        ref_key: "gridWrapRef",
        ref: U,
        class: normalizeClass(ee.value),
        style: normalizeStyle(x.value),
        role: Y.useRelative ? void 0 : "dialog",
        "aria-label": Y.overlayLabel,
        tabindex: Y.useRelative ? void 0 : "0",
        onKeydown: oe,
        onClick: g[0] || (g[0] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", {
          ref_key: "containerRef",
          ref: k,
          class: normalizeClass(O.value),
          style: normalizeStyle({ "--dp-overlay-height": `${I.value}px` }),
          role: "grid"
        }, [
          createBaseVNode("div", ir, [
            renderSlot(Y.$slots, "header")
          ]),
          Y.$slots.overlay ? renderSlot(Y.$slots, "overlay", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(Y.items, (se, R) => (openBlock(), createElementBlock("div", {
            key: R,
            class: normalizeClass(["dp__overlay_row", { dp__flex_row: Y.items.length >= 3 }]),
            role: "row"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(se, (ae, l) => (openBlock(), createElementBlock("div", {
              key: ae.value,
              ref_for: true,
              ref: (D) => L(D, ae, R, l),
              role: "gridcell",
              class: normalizeClass(S.value),
              "aria-selected": ae.active || void 0,
              "aria-disabled": ae.disabled || void 0,
              tabindex: "0",
              "data-test-id": ae.text,
              onClick: withModifiers((D) => fe(ae), ["prevent"]),
              onKeydown: (D) => unref(Ze)(D, () => fe(ae), true),
              onMouseover: (D) => W(ae.value)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(ae.className)
              }, [
                Y.$slots.item ? renderSlot(Y.$slots, "item", {
                  key: 0,
                  item: ae
                }) : createCommentVNode("", true),
                Y.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(ae.text), 1)
                ], 64))
              ], 2)
            ], 42, dr))), 128))
          ], 2))), 128))
        ], 6),
        Y.$slots["button-icon"] ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: f,
          type: "button",
          "aria-label": (Z = unref(i)) == null ? void 0 : Z.toggleOverlay,
          class: normalizeClass(X.value),
          tabindex: "0",
          onClick: me,
          onKeydown: $
        }, [
          renderSlot(Y.$slots, "button-icon")
        ], 42, cr)), [
          [vShow, !unref(C)(Y.hideNavigation, Y.type)]
        ]) : createCommentVNode("", true)
      ], 46, ur);
    };
  }
}), fr = ["data-dp-mobile"], ma = /* @__PURE__ */ defineComponent({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean },
    collapse: { type: Boolean },
    isMobile: { type: Boolean }
  },
  setup(e) {
    const t = e, r = computed(
      () => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]
    ), a = computed(() => ({
      dp__instance_calendar: t.multiCalendars > 0
    }));
    return (n, u) => (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        dp__menu_inner: !n.stretch,
        "dp--menu--inner-stretched": n.stretch,
        dp__flex_display: n.multiCalendars > 0,
        "dp--flex-display-collapsed": n.collapse
      }),
      "data-dp-mobile": n.isMobile
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (d, y) => (openBlock(), createElementBlock("div", {
        key: d,
        class: normalizeClass(a.value)
      }, [
        renderSlot(n.$slots, "default", {
          instance: d,
          index: y
        })
      ], 2))), 128))
    ], 10, fr));
  }
}), vr = ["data-dp-element", "aria-label", "aria-disabled"], Kt = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    elName: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: t }) {
    const r = t, a = ref(null);
    return onMounted(() => r("set-ref", a)), (n, u) => (openBlock(), createElementBlock("button", {
      ref_key: "elRef",
      ref: a,
      type: "button",
      "data-dp-element": n.elName,
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": n.ariaLabel,
      "aria-disabled": n.disabled || void 0,
      onClick: u[0] || (u[0] = (d) => n.$emit("activate")),
      onKeydown: u[1] || (u[1] = (d) => unref(Ze)(d, () => n.$emit("activate"), true))
    }, [
      createBaseVNode("span", {
        class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: n.disabled }])
      }, [
        renderSlot(n.$slots, "default")
      ], 2)
    ], 40, vr));
  }
}), mr = ["aria-label", "data-test-id"], zn = /* @__PURE__ */ defineComponent({
  __name: "YearModePicker",
  props: {
    ...ct,
    showYearPicker: { type: Boolean, default: false },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => false }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e, { emit: t }) {
    const r = t, a = e, { showRightIcon: n, showLeftIcon: u } = ya(), { defaultedConfig: d, defaultedMultiCalendars: y, defaultedAriaLabels: i, defaultedTransitions: _2, defaultedUI: c } = _e(a), { showTransition: C, transitionName: m } = ta(_2), P = ref(false), U = (f = false, I) => {
      P.value = !P.value, r("toggle-year-picker", { flow: f, show: I });
    }, N = (f) => {
      P.value = false, r("year-select", f);
    }, H = (f = false) => {
      r("handle-year", f);
    };
    return (f, I) => {
      var k, z, q, ee, x;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          class: normalizeClass(["dp--year-mode-picker", { "dp--hidden-el": P.value }])
        }, [
          unref(u)(unref(y), e.instance) ? (openBlock(), createBlock(Kt, {
            key: 0,
            ref: "mpPrevIconRef",
            "aria-label": (k = unref(i)) == null ? void 0 : k.prevYear,
            disabled: e.isDisabled(false),
            class: normalizeClass((z = unref(c)) == null ? void 0 : z.navBtnPrev),
            onActivate: I[0] || (I[0] = (S) => H(false))
          }, {
            default: withCtx(() => [
              f.$slots["arrow-left"] ? renderSlot(f.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
              f.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wa), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
          createBaseVNode("button", {
            ref: "mpYearButtonRef",
            class: "dp__btn dp--year-select",
            type: "button",
            "aria-label": `${e.year}-${(q = unref(i)) == null ? void 0 : q.openYearsOverlay}`,
            "data-test-id": `year-mode-btn-${e.instance}`,
            onClick: I[1] || (I[1] = () => U(false)),
            onKeydown: I[2] || (I[2] = withKeys(() => U(false), ["enter"]))
          }, [
            f.$slots.year ? renderSlot(f.$slots, "year", {
              key: 0,
              year: e.year
            }) : createCommentVNode("", true),
            f.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(e.year), 1)
            ], 64))
          ], 40, mr),
          unref(n)(unref(y), e.instance) ? (openBlock(), createBlock(Kt, {
            key: 1,
            ref: "mpNextIconRef",
            "aria-label": (ee = unref(i)) == null ? void 0 : ee.nextYear,
            disabled: e.isDisabled(true),
            class: normalizeClass((x = unref(c)) == null ? void 0 : x.navBtnNext),
            onActivate: I[3] || (I[3] = (S) => H(true))
          }, {
            default: withCtx(() => [
              f.$slots["arrow-right"] ? renderSlot(f.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
              f.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Va), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true)
        ], 2),
        createVNode(Transition, {
          name: unref(m)(e.showYearPicker),
          css: unref(C)
        }, {
          default: withCtx(() => {
            var S, X;
            return [
              e.showYearPicker ? (openBlock(), createBlock(ea, {
                key: 0,
                items: e.items,
                "text-input": f.textInput,
                "esc-close": f.escClose,
                config: f.config,
                "is-last": f.autoApply && !unref(d).keepActionRow,
                "hide-navigation": f.hideNavigation,
                "aria-labels": f.ariaLabels,
                "overlay-label": (X = (S = unref(i)) == null ? void 0 : S.yearPicker) == null ? void 0 : X.call(S, true),
                type: "year",
                onToggle: U,
                onSelected: I[4] || (I[4] = (O) => N(O))
              }, createSlots({
                "button-icon": withCtx(() => [
                  f.$slots["calendar-icon"] ? renderSlot(f.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                  f.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wt), { key: 1 }))
                ]),
                _: 2
              }, [
                f.$slots["year-overlay-value"] ? {
                  name: "item",
                  fn: withCtx(({ item: O }) => [
                    renderSlot(f.$slots, "year-overlay-value", {
                      text: O.text,
                      value: O.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 64);
    };
  }
}), xa = (e, t, r) => {
  if (t.value && Array.isArray(t.value))
    if (t.value.some((a) => Ae(e, a))) {
      const a = t.value.filter((n) => !Ae(n, e));
      t.value = a.length ? a : null;
    } else (r && +r > t.value.length || !r) && t.value.push(e);
  else
    t.value = [e];
}, en = (e, t, r) => {
  let a = e.value ? e.value.slice() : [];
  return a.length === 2 && a[1] !== null && (a = []), a.length ? (Ye(t, a[0]) ? a.unshift(t) : a[1] = t, r("range-end", t)) : (a = [t], r("range-start", t)), a;
}, pa = (e, t, r, a) => {
  e && (e[0] && e[1] && r && t("auto-apply"), e[0] && !e[1] && a && r && t("auto-apply"));
}, Hn = (e) => {
  Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map((t) => et(j(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = et(j(e.value), e.timezone));
}, Un = (e, t, r, a) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && a.value.partialRange) ? a.value.fixedStart && (Ee(e, t.value[0]) || Ae(e, t.value[0])) ? [t.value[0], e] : a.value.fixedEnd && (Ye(e, t.value[1]) || Ae(e, t.value[1])) ? [e, t.value[1]] : (r("invalid-fixed-range", e), t.value) : [], Wn = ({
  multiCalendars: e,
  range: t,
  highlight: r,
  propDates: a,
  calendars: n,
  modelValue: u,
  props: d,
  filters: y,
  year: i,
  month: _2,
  emit: c
}) => {
  const C = computed(() => qa(d.yearRange, d.locale, d.reverseYears)), m = ref([false]), P = computed(() => (O, K) => {
    const fe = set(dt(/* @__PURE__ */ new Date()), {
      month: _2.value(O),
      year: i.value(O)
    }), me = K ? endOfYear(fe) : startOfYear(fe);
    return En(
      me,
      a.value.maxDate,
      a.value.minDate,
      d.preventMinMaxNavigation,
      K
    );
  }), U = () => Array.isArray(u.value) && e.value.solo && u.value[1], N = () => {
    for (let O = 0; O < e.value.count; O++)
      if (O === 0)
        n.value[O] = n.value[0];
      else if (O === e.value.count - 1 && U())
        n.value[O] = {
          month: getMonth(u.value[1]),
          year: getYear(u.value[1])
        };
      else {
        const K = set(j(), n.value[O - 1]);
        n.value[O] = { month: getMonth(K), year: getYear(addYears(K, 1)) };
      }
  }, H = (O) => {
    if (!O) return N();
    const K = set(j(), n.value[O]);
    return n.value[0].year = getYear(subYears(K, e.value.count - 1)), N();
  }, f = (O, K) => {
    const fe = differenceInYears(K, O);
    return t.value.showLastInRange && fe > 1 ? K : O;
  }, I = (O) => d.focusStartDate || e.value.solo ? O[0] : O[1] ? f(O[0], O[1]) : O[0], k = () => {
    if (u.value) {
      const O = Array.isArray(u.value) ? I(u.value) : u.value;
      n.value[0] = { month: getMonth(O), year: getYear(O) };
    }
  }, z = () => {
    k(), e.value.count && N();
  };
  watch(u, (O, K) => {
    d.isTextInputDate && JSON.stringify(O ?? {}) !== JSON.stringify(K ?? {}) && z();
  }), onMounted(() => {
    z();
  });
  const q = (O, K) => {
    n.value[K].year = O, c("update-month-year", { instance: K, year: O, month: n.value[K].month }), e.value.count && !e.value.solo && H(K);
  }, ee = computed(() => (O) => zt(C.value, (K) => {
    var L;
    const fe = i.value(O) === K.value, me = Xt(
      K.value,
      Ht(a.value.minDate),
      Ht(a.value.maxDate)
    ) || ((L = y.value.years) == null ? void 0 : L.includes(i.value(O))), v = Za(r.value, K.value);
    return { active: fe, disabled: me, highlighted: v };
  })), x = (O, K) => {
    q(O, K), X(K);
  }, S = (O, K = false) => {
    if (!P.value(O, K)) {
      const fe = K ? i.value(O) + 1 : i.value(O) - 1;
      q(fe, O);
    }
  }, X = (O, K = false, fe) => {
    K || c("reset-flow"), fe !== void 0 ? m.value[O] = fe : m.value[O] = !m.value[O], m.value[O] ? c("overlay-toggle", { open: true, overlay: Ge.year }) : (c("overlay-closed"), c("overlay-toggle", { open: false, overlay: Ge.year }));
  };
  return {
    isDisabled: P,
    groupedYears: ee,
    showYearPicker: m,
    selectYear: q,
    toggleYearPicker: X,
    handleYearSelect: x,
    handleYear: S
  };
}, pr = (e, t) => {
  const {
    defaultedMultiCalendars: r,
    defaultedAriaLabels: a,
    defaultedTransitions: n,
    defaultedConfig: u,
    defaultedRange: d,
    defaultedHighlight: y,
    propDates: i,
    defaultedTz: _2,
    defaultedFilters: c,
    defaultedMultiDates: C
  } = _e(e), m = () => {
    e.isTextInputDate && z(getYear(j(e.startDate)), 0);
  }, { modelValue: P, year: U, month: N, calendars: H } = aa(e, t, m), f = computed(() => Sn(e.formatLocale, e.locale, e.monthNameFormat)), I = ref(null), { checkMinMaxRange: k } = Tt(e), {
    selectYear: z,
    groupedYears: q,
    showYearPicker: ee,
    toggleYearPicker: x,
    handleYearSelect: S,
    handleYear: X,
    isDisabled: O
  } = Wn({
    modelValue: P,
    multiCalendars: r,
    range: d,
    highlight: y,
    calendars: H,
    year: U,
    propDates: i,
    month: N,
    filters: c,
    props: e,
    emit: t
  });
  onMounted(() => {
    e.startDate && (P.value && e.focusStartDate || !P.value) && z(getYear(j(e.startDate)), 0);
  });
  const K = (R) => R ? { month: getMonth(R), year: getYear(R) } : { month: null, year: null }, fe = () => P.value ? Array.isArray(P.value) ? P.value.map((R) => K(R)) : K(P.value) : K(), me = (R, ae) => {
    const l = H.value[R], D = fe();
    return Array.isArray(D) ? D.some((ue) => ue.year === (l == null ? void 0 : l.year) && ue.month === ae) : (l == null ? void 0 : l.year) === D.year && ae === D.month;
  }, v = (R, ae, l) => {
    var ue, M;
    const D = fe();
    return Array.isArray(D) ? U.value(ae) === ((ue = D[l]) == null ? void 0 : ue.year) && R === ((M = D[l]) == null ? void 0 : M.month) : false;
  }, L = (R, ae) => {
    if (d.value.enabled) {
      const l = fe();
      if (Array.isArray(P.value) && Array.isArray(l)) {
        const D = v(R, ae, 0) || v(R, ae, 1), ue = yt(dt(j()), R, U.value(ae));
        return Jt(P.value, I.value, ue) && !D;
      }
      return false;
    }
    return false;
  }, ne = computed(() => (R) => zt(f.value, (ae) => {
    var he;
    const l = me(R, ae.value), D = Xt(
      ae.value,
      Bn(U.value(R), i.value.minDate),
      _n(U.value(R), i.value.maxDate)
    ) || Fl(i.value.disabledDates, U.value(R), ae.value) || ((he = c.value.months) == null ? void 0 : he.includes(ae.value)) || !Ll(i.value.allowedDates, U.value(R), ae.value), ue = L(ae.value, R), M = Fn(y.value, ae.value, U.value(R));
    return { active: l, disabled: D, isBetween: ue, highlighted: M };
  })), p = (R, ae) => yt(dt(j()), R, U.value(ae)), W = (R, ae) => {
    const l = P.value ? P.value : dt(/* @__PURE__ */ new Date());
    P.value = yt(l, R, U.value(ae)), t("auto-apply"), t("update-flow-step");
  }, T = (R, ae) => {
    const l = p(R, ae);
    d.value.fixedEnd || d.value.fixedStart ? P.value = Un(l, P, t, d) : P.value ? k(l, P.value) && (P.value = en(P, p(R, ae), t)) : P.value = [p(R, ae)], nextTick().then(() => {
      pa(P.value, t, e.autoApply, e.modelAuto);
    });
  }, oe = (R, ae) => {
    xa(p(R, ae), P, C.value.limit), t("auto-apply", true);
  }, $ = (R, ae) => (H.value[ae].month = R, g(ae, H.value[ae].year, R), C.value.enabled ? oe(R, ae) : d.value.enabled ? T(R, ae) : W(R, ae)), Y = (R, ae) => {
    z(R, ae), g(ae, R, null);
  }, g = (R, ae, l) => {
    let D = l;
    if (!D && D !== 0) {
      const ue = fe();
      D = Array.isArray(ue) ? ue[R].month : ue.month;
    }
    t("update-month-year", { instance: R, year: ae, month: D });
  };
  return {
    groupedMonths: ne,
    groupedYears: q,
    year: U,
    isDisabled: O,
    defaultedMultiCalendars: r,
    defaultedAriaLabels: a,
    defaultedTransitions: n,
    defaultedConfig: u,
    showYearPicker: ee,
    modelValue: P,
    presetDate: (R, ae) => {
      Hn({
        value: R,
        modelValue: P,
        range: d.value.enabled,
        timezone: ae ? void 0 : _2.value.timezone
      }), t("auto-apply");
    },
    setHoverDate: (R, ae) => {
      I.value = p(R, ae);
    },
    selectMonth: $,
    selectYear: Y,
    toggleYearPicker: x,
    handleYearSelect: S,
    handleYear: X,
    getModelMonthYear: fe
  };
}, yr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year",
    "update-flow-step",
    "mount",
    "invalid-fixed-range",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = useSlots(), u = tt(n, "yearMode"), d = e;
    onMounted(() => {
      d.shadow || a("mount", null);
    });
    const {
      groupedMonths: y,
      groupedYears: i,
      year: _2,
      isDisabled: c,
      defaultedMultiCalendars: C,
      defaultedConfig: m,
      showYearPicker: P,
      modelValue: U,
      presetDate: N,
      setHoverDate: H,
      selectMonth: f,
      selectYear: I,
      toggleYearPicker: k,
      handleYearSelect: z,
      handleYear: q,
      getModelMonthYear: ee
    } = pr(d, a);
    return t({ getSidebarProps: () => ({
      modelValue: U,
      year: _2,
      getModelMonthYear: ee,
      selectMonth: f,
      selectYear: I,
      handleYear: q
    }), presetDate: N, toggleYearPicker: (S) => k(0, S) }), (S, X) => (openBlock(), createBlock(ma, {
      "multi-calendars": unref(C).count,
      collapse: S.collapse,
      stretch: "",
      "is-mobile": S.isMobile
    }, {
      default: withCtx(({ instance: O }) => [
        S.$slots["top-extra"] ? renderSlot(S.$slots, "top-extra", {
          key: 0,
          value: S.internalModelValue
        }) : createCommentVNode("", true),
        S.$slots["month-year"] ? renderSlot(S.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
          year: unref(_2),
          months: unref(y)(O),
          years: unref(i)(O),
          selectMonth: unref(f),
          selectYear: unref(I),
          instance: O
        }))) : (openBlock(), createBlock(ea, {
          key: 2,
          items: unref(y)(O),
          "arrow-navigation": S.arrowNavigation,
          "is-last": S.autoApply && !unref(m).keepActionRow,
          "esc-close": S.escClose,
          height: unref(m).modeHeight,
          config: S.config,
          "no-overlay-focus": !!(S.noOverlayFocus || S.textInput),
          "use-relative": "",
          type: "month",
          onSelected: (K) => unref(f)(K, O),
          onHoverValue: (K) => unref(H)(K, O)
        }, createSlots({
          header: withCtx(() => [
            createVNode(zn, mergeProps(S.$props, {
              items: unref(i)(O),
              instance: O,
              "show-year-picker": unref(P)[O],
              year: unref(_2)(O),
              "is-disabled": (K) => unref(c)(O, K),
              onHandleYear: (K) => unref(q)(O, K),
              onYearSelect: (K) => unref(z)(K, O),
              onToggleYearPicker: (K) => unref(k)(O, K == null ? void 0 : K.flow, K == null ? void 0 : K.show)
            }), createSlots({ _: 2 }, [
              renderList(unref(u), (K, fe) => ({
                name: K,
                fn: withCtx((me) => [
                  renderSlot(S.$slots, K, normalizeProps(guardReactiveProps(me)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, [
          S.$slots["month-overlay-value"] ? {
            name: "item",
            fn: withCtx(({ item: K }) => [
              renderSlot(S.$slots, "month-overlay-value", {
                text: K.text,
                value: K.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), gr = (e, t) => {
  const r = () => {
    e.isTextInputDate && (c.value = getYear(j(e.startDate)));
  }, { modelValue: a } = aa(e, t, r), n = ref(null), { defaultedHighlight: u, defaultedMultiDates: d, defaultedFilters: y, defaultedRange: i, propDates: _2 } = _e(e), c = ref();
  onMounted(() => {
    e.startDate && (a.value && e.focusStartDate || !a.value) && (c.value = getYear(j(e.startDate)));
  });
  const C = (k) => Array.isArray(a.value) ? a.value.some((z) => getYear(z) === k) : a.value ? getYear(a.value) === k : false, m = (k) => i.value.enabled && Array.isArray(a.value) ? Jt(a.value, n.value, H(k)) : false, P = (k) => _2.value.allowedDates instanceof Map ? _2.value.allowedDates.size ? _2.value.allowedDates.has(`${k}`) : false : true, U = (k) => _2.value.disabledDates instanceof Map ? _2.value.disabledDates.size ? _2.value.disabledDates.has(`${k}`) : false : true, N = computed(() => zt(qa(e.yearRange, e.locale, e.reverseYears), (k) => {
    const z = C(k.value), q = Xt(
      k.value,
      Ht(_2.value.minDate),
      Ht(_2.value.maxDate)
    ) || y.value.years.includes(k.value) || !P(k.value) || U(k.value), ee = m(k.value) && !z, x = Za(u.value, k.value);
    return { active: z, disabled: q, isBetween: ee, highlighted: x };
  })), H = (k) => setYear(dt(startOfYear(/* @__PURE__ */ new Date())), k);
  return {
    groupedYears: N,
    modelValue: a,
    focusYear: c,
    setHoverValue: (k) => {
      n.value = setYear(dt(/* @__PURE__ */ new Date()), k);
    },
    selectYear: (k) => {
      var z;
      if (t("update-month-year", { instance: 0, year: k }), d.value.enabled)
        return a.value ? Array.isArray(a.value) && (((z = a.value) == null ? void 0 : z.map((ee) => getYear(ee))).includes(k) ? a.value = a.value.filter((ee) => getYear(ee) !== k) : a.value.push(setYear(We(j()), k))) : a.value = [setYear(We(startOfYear(j())), k)], t("auto-apply", true);
      i.value.enabled ? (a.value = en(a, H(k), t), nextTick().then(() => {
        pa(a.value, t, e.autoApply, e.modelAuto);
      })) : (a.value = H(k), t("auto-apply"));
    }
  };
}, hr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { groupedYears: u, modelValue: d, focusYear: y, selectYear: i, setHoverValue: _2 } = gr(n, a), { defaultedConfig: c } = _e(n);
    return t({ getSidebarProps: () => ({
      modelValue: d,
      selectYear: i
    }) }), (m, P) => (openBlock(), createElementBlock("div", null, [
      m.$slots["top-extra"] ? renderSlot(m.$slots, "top-extra", {
        key: 0,
        value: m.internalModelValue
      }) : createCommentVNode("", true),
      m.$slots["month-year"] ? renderSlot(m.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
        years: unref(u),
        selectYear: unref(i)
      }))) : (openBlock(), createBlock(ea, {
        key: 2,
        items: unref(u),
        "is-last": m.autoApply && !unref(c).keepActionRow,
        height: unref(c).modeHeight,
        config: m.config,
        "no-overlay-focus": !!(m.noOverlayFocus || m.textInput),
        "focus-value": unref(y),
        type: "year",
        "use-relative": "",
        onSelected: unref(i),
        onHoverValue: unref(_2)
      }, createSlots({ _: 2 }, [
        m.$slots["year-overlay-value"] ? {
          name: "item",
          fn: withCtx(({ item: U }) => [
            renderSlot(m.$slots, "year-overlay-value", {
              text: U.text,
              value: U.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
}), br = {
  key: 0,
  class: "dp__time_input"
}, kr = ["data-compact", "data-collapsed"], wr = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], Dr = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"], Mr = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], $r = { key: 0 }, Ar = ["aria-label", "data-compact"], Tr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => false },
    ...ct
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "overlay-opened",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { setTimePickerElements: u, setTimePickerBackRef: d } = At(), {
      defaultedAriaLabels: y,
      defaultedTransitions: i,
      defaultedFilters: _2,
      defaultedConfig: c,
      defaultedRange: C,
      defaultedMultiCalendars: m
    } = _e(n), { transitionName: P, showTransition: U } = ta(i), N = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), H = ref("AM"), f = ref(null), I = ref([]), k = ref(), z = ref(false);
    onMounted(() => {
      a("mounted");
    });
    const q = (o) => set(/* @__PURE__ */ new Date(), {
      hours: o.hours,
      minutes: o.minutes,
      seconds: n.enableSeconds ? o.seconds : 0,
      milliseconds: 0
    }), ee = computed(
      () => (o) => T(o, n[o]) || S(o, n[o])
    ), x = computed(() => ({ hours: n.hours, minutes: n.minutes, seconds: n.seconds })), S = (o, E) => C.value.enabled && !C.value.disableTimeRangeValidation ? !n.validateTime(o, E) : false, X = (o, E) => {
      if (C.value.enabled && !C.value.disableTimeRangeValidation) {
        const ce = E ? +n[`${o}Increment`] : -+n[`${o}Increment`], B = n[o] + ce;
        return !n.validateTime(o, B);
      }
      return false;
    }, O = computed(() => (o) => !Z(+n[o] + +n[`${o}Increment`], o) || X(o, true)), K = computed(() => (o) => !Z(+n[o] - +n[`${o}Increment`], o) || X(o, false)), fe = (o, E) => add(set(j(), o), E), me = (o, E) => sub(set(j(), o), E), v = computed(
      () => ({
        dp__time_col: true,
        dp__time_col_block: !n.timePickerInline,
        dp__time_col_reg_block: !n.enableSeconds && n.is24 && !n.timePickerInline,
        dp__time_col_reg_inline: !n.enableSeconds && n.is24 && n.timePickerInline,
        dp__time_col_reg_with_button: !n.enableSeconds && !n.is24,
        dp__time_col_sec: n.enableSeconds && n.is24,
        dp__time_col_sec_with_button: n.enableSeconds && !n.is24
      })
    ), L = computed(
      () => n.timePickerInline && C.value.enabled && !m.value.count
    ), ne = computed(() => {
      const o = [{ type: "hours" }];
      return n.enableMinutes && o.push({ type: "", separator: true }, {
        type: "minutes"
      }), n.enableSeconds && o.push({ type: "", separator: true }, {
        type: "seconds"
      }), o;
    }), p = computed(() => ne.value.filter((o) => !o.separator)), W = computed(() => (o) => {
      if (o === "hours") {
        const E = ue(+n.hours);
        return { text: E < 10 ? `0${E}` : `${E}`, value: E };
      }
      return { text: n[o] < 10 ? `0${n[o]}` : `${n[o]}`, value: n[o] };
    }), T = (o, E) => {
      var B;
      if (!n.disabledTimesConfig) return false;
      const ce = n.disabledTimesConfig(n.order, o === "hours" ? E : void 0);
      return ce[o] ? !!((B = ce[o]) != null && B.includes(E)) : true;
    }, oe = (o, E) => E !== "hours" || H.value === "AM" ? o : o + 12, $ = (o) => {
      const E = n.is24 ? 24 : 12, ce = o === "hours" ? E : 60, B = +n[`${o}GridIncrement`], Me = o === "hours" && !n.is24 ? B : 0, be = [];
      for (let Se = Me; Se < ce; Se += B)
        be.push({ value: n.is24 ? Se : oe(Se, o), text: Se < 10 ? `0${Se}` : `${Se}` });
      return o === "hours" && !n.is24 && be.unshift({ value: H.value === "PM" ? 12 : 0, text: "12" }), zt(be, (Se) => ({ active: false, disabled: _2.value.times[o].includes(Se.value) || !Z(Se.value, o) || T(o, Se.value) || S(o, Se.value) }));
    }, Y = (o) => o >= 0 ? o : 59, g = (o) => o >= 0 ? o : 23, Z = (o, E) => {
      const ce = n.minTime ? q(Sa(n.minTime)) : null, B = n.maxTime ? q(Sa(n.maxTime)) : null, Me = q(
        Sa(
          x.value,
          E,
          E === "minutes" || E === "seconds" ? Y(o) : g(o)
        )
      );
      return ce && B ? (isBefore(Me, B) || isEqual(Me, B)) && (isAfter(Me, ce) || isEqual(Me, ce)) : ce ? isAfter(Me, ce) || isEqual(Me, ce) : B ? isBefore(Me, B) || isEqual(Me, B) : true;
    }, se = (o) => n[`no${o[0].toUpperCase() + o.slice(1)}Overlay`], R = (o) => {
      se(o) || (N[o] = !N[o], N[o] ? (z.value = true, a("overlay-opened", o)) : (z.value = false, a("overlay-closed", o)));
    }, ae = (o) => o === "hours" ? getHours : o === "minutes" ? getMinutes : getSeconds, l = () => {
      k.value && clearTimeout(k.value);
    }, D = (o, E = true, ce) => {
      const B = E ? fe : me, Me = E ? +n[`${o}Increment`] : -+n[`${o}Increment`];
      Z(+n[o] + Me, o) && a(
        `update:${o}`,
        ae(o)(B({ [o]: +n[o] }, { [o]: +n[`${o}Increment`] }))
      ), !(ce != null && ce.keyboard) && c.value.timeArrowHoldThreshold && (k.value = setTimeout(() => {
        D(o, E);
      }, c.value.timeArrowHoldThreshold));
    }, ue = (o) => n.is24 ? o : (o >= 12 ? H.value = "PM" : H.value = "AM", $l(o)), M = () => {
      H.value === "PM" ? (H.value = "AM", a("update:hours", n.hours - 12)) : (H.value = "PM", a("update:hours", n.hours + 12)), a("am-pm-change", H.value);
    }, he = (o) => {
      N[o] = true;
    }, pe = (o, E, ce) => {
      if (o && n.arrowNavigation) {
        Array.isArray(I.value[E]) ? I.value[E][ce] = o : I.value[E] = [o];
        const B = I.value.reduce(
          (Me, be) => be.map((Se, b) => [...Me[b] || [], be[b]]),
          []
        );
        d(n.closeTimePickerBtn), f.value && (B[1] = B[1].concat(f.value)), u(B, n.order);
      }
    }, re = (o, E) => (R(o), a(`update:${o}`, E));
    return t({ openChildCmp: he }), (o, E) => {
      var ce;
      return o.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", br, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(ne.value, (B, Me) => {
          var be, Se, b;
          return openBlock(), createElementBlock("div", {
            key: Me,
            class: normalizeClass(v.value),
            "data-compact": L.value && !o.enableSeconds,
            "data-collapsed": L.value && o.enableSeconds
          }, [
            B.separator ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              z.value ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(":")
              ], 64))
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("button", {
                ref_for: true,
                ref: (F2) => pe(F2, Me, 0),
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !o.timePickerInline,
                  dp__inc_dec_button_inline: o.timePickerInline,
                  dp__tp_inline_btn_top: o.timePickerInline,
                  dp__inc_dec_button_disabled: O.value(B.type),
                  "dp--hidden-el": z.value
                }),
                "data-test-id": `${B.type}-time-inc-btn-${n.order}`,
                "aria-label": (be = unref(y)) == null ? void 0 : be.incrementValue(B.type),
                tabindex: "0",
                onKeydown: (F2) => unref(Ze)(F2, () => D(B.type, true, { keyboard: true }), true),
                onClick: (F2) => unref(c).timeArrowHoldThreshold ? void 0 : D(B.type, true),
                onMousedown: (F2) => unref(c).timeArrowHoldThreshold ? D(B.type, true) : void 0,
                onMouseup: l
              }, [
                n.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  o.$slots["tp-inline-arrow-up"] ? renderSlot(o.$slots, "tp-inline-arrow-up", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    E[2] || (E[2] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    E[3] || (E[3] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  o.$slots["arrow-up"] ? renderSlot(o.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                  o.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
                ], 64))
              ], 42, wr),
              createBaseVNode("button", {
                ref_for: true,
                ref: (F2) => pe(F2, Me, 1),
                type: "button",
                "aria-label": `${W.value(B.type).text}-${(Se = unref(y)) == null ? void 0 : Se.openTpOverlay(B.type)}`,
                class: normalizeClass({
                  dp__time_display: true,
                  dp__time_display_block: !o.timePickerInline,
                  dp__time_display_inline: o.timePickerInline,
                  "dp--time-invalid": ee.value(B.type),
                  "dp--time-overlay-btn": !ee.value(B.type),
                  "dp--hidden-el": z.value
                }),
                disabled: se(B.type),
                tabindex: "0",
                "data-test-id": `${B.type}-toggle-overlay-btn-${n.order}`,
                onKeydown: (F2) => unref(Ze)(F2, () => R(B.type), true),
                onClick: (F2) => R(B.type)
              }, [
                o.$slots[B.type] ? renderSlot(o.$slots, B.type, {
                  key: 0,
                  text: W.value(B.type).text,
                  value: W.value(B.type).value
                }) : createCommentVNode("", true),
                o.$slots[B.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(W.value(B.type).text), 1)
                ], 64))
              ], 42, Dr),
              createBaseVNode("button", {
                ref_for: true,
                ref: (F2) => pe(F2, Me, 2),
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !o.timePickerInline,
                  dp__inc_dec_button_inline: o.timePickerInline,
                  dp__tp_inline_btn_bottom: o.timePickerInline,
                  dp__inc_dec_button_disabled: K.value(B.type),
                  "dp--hidden-el": z.value
                }),
                "data-test-id": `${B.type}-time-dec-btn-${n.order}`,
                "aria-label": (b = unref(y)) == null ? void 0 : b.decrementValue(B.type),
                tabindex: "0",
                onKeydown: (F2) => unref(Ze)(F2, () => D(B.type, false, { keyboard: true }), true),
                onClick: (F2) => unref(c).timeArrowHoldThreshold ? void 0 : D(B.type, false),
                onMousedown: (F2) => unref(c).timeArrowHoldThreshold ? D(B.type, false) : void 0,
                onMouseup: l
              }, [
                n.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  o.$slots["tp-inline-arrow-down"] ? renderSlot(o.$slots, "tp-inline-arrow-down", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    E[4] || (E[4] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    E[5] || (E[5] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  o.$slots["arrow-down"] ? renderSlot(o.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                  o.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ga), { key: 1 }))
                ], 64))
              ], 42, Mr)
            ], 64))
          ], 10, kr);
        }), 128)),
        o.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", $r, [
          o.$slots["am-pm-button"] ? renderSlot(o.$slots, "am-pm-button", {
            key: 0,
            toggle: M,
            value: H.value
          }) : createCommentVNode("", true),
          o.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: f,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (ce = unref(y)) == null ? void 0 : ce.amPmButton,
            tabindex: "0",
            "data-compact": L.value,
            onClick: M,
            onKeydown: E[0] || (E[0] = (B) => unref(Ze)(B, () => M(), true))
          }, toDisplayString(H.value), 41, Ar))
        ])),
        (openBlock(true), createElementBlock(Fragment, null, renderList(p.value, (B, Me) => (openBlock(), createBlock(Transition, {
          key: Me,
          name: unref(P)(N[B.type]),
          css: unref(U)
        }, {
          default: withCtx(() => {
            var be, Se;
            return [
              N[B.type] ? (openBlock(), createBlock(ea, {
                key: 0,
                items: $(B.type),
                "is-last": o.autoApply && !unref(c).keepActionRow,
                "esc-close": o.escClose,
                type: B.type,
                "text-input": o.textInput,
                config: o.config,
                "arrow-navigation": o.arrowNavigation,
                "aria-labels": o.ariaLabels,
                "overlay-label": (Se = (be = unref(y)).timeOverlay) == null ? void 0 : Se.call(be, B.type),
                onSelected: (b) => re(B.type, b),
                onToggle: (b) => R(B.type),
                onResetFlow: E[1] || (E[1] = (b) => o.$emit("reset-flow"))
              }, createSlots({
                "button-icon": withCtx(() => [
                  o.$slots["clock-icon"] ? renderSlot(o.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                  o.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(o.timePickerInline ? unref(Wt) : unref(ja)), { key: 1 }))
                ]),
                _: 2
              }, [
                o.$slots[`${B.type}-overlay-value`] ? {
                  name: "item",
                  fn: withCtx(({ item: b }) => [
                    renderSlot(o.$slots, `${B.type}-overlay-value`, {
                      text: b.text,
                      value: b.value
                    })
                  ]),
                  key: "0"
                } : void 0,
                o.$slots[`${B.type}-overlay-header`] ? {
                  name: "header",
                  fn: withCtx(() => [
                    renderSlot(o.$slots, `${B.type}-overlay-header`, {
                      toggle: () => R(B.type)
                    })
                  ]),
                  key: "1"
                } : void 0
              ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
            ];
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Sr = ["data-dp-mobile"], Pr = ["aria-label", "tabindex"], Rr = ["role", "aria-label", "tabindex"], Cr = ["aria-label"], Vn = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => false
    },
    ...ct
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { buildMatrix: u, setTimePicker: d } = At(), y = useSlots(), { defaultedTransitions: i, defaultedAriaLabels: _2, defaultedTextInput: c, defaultedConfig: C, defaultedRange: m } = _e(n), { transitionName: P, showTransition: U } = ta(i), { hideNavigationButtons: N } = ya(), H = ref(null), f = ref(null), I = ref([]), k = ref(null), z = ref(false);
    onMounted(() => {
      a("mount"), !n.timePicker && n.arrowNavigation ? u([Le(H.value)], "time") : d(true, n.timePicker);
    });
    const q = computed(() => m.value.enabled && n.modelAuto ? Pn(n.internalModelValue) : true), ee = ref(false), x = (T) => ({
      hours: Array.isArray(n.hours) ? n.hours[T] : n.hours,
      minutes: Array.isArray(n.minutes) ? n.minutes[T] : n.minutes,
      seconds: Array.isArray(n.seconds) ? n.seconds[T] : n.seconds
    }), S = computed(() => {
      const T = [];
      if (m.value.enabled)
        for (let oe = 0; oe < 2; oe++)
          T.push(x(oe));
      else
        T.push(x(0));
      return T;
    }), X = (T, oe = false, $ = "") => {
      oe || a("reset-flow"), ee.value = T, a(T ? "overlay-opened" : "overlay-closed", Ge.time), n.arrowNavigation && d(T), nextTick(() => {
        $ !== "" && I.value[0] && I.value[0].openChildCmp($);
      });
    }, O = computed(() => ({
      dp__btn: true,
      dp__button: true,
      dp__button_bottom: n.autoApply && !C.value.keepActionRow
    })), K = tt(y, "timePicker"), fe = (T, oe, $) => m.value.enabled ? oe === 0 ? [T, S.value[1][$]] : [S.value[0][$], T] : T, me = (T) => {
      a("update:hours", T);
    }, v = (T) => {
      a("update:minutes", T);
    }, L = (T) => {
      a("update:seconds", T);
    }, ne = () => {
      if (k.value && !c.value.enabled && !n.noOverlayFocus) {
        const T = Rn(k.value);
        T && T.focus({ preventScroll: true });
      }
    }, p = (T) => {
      z.value = false, a("overlay-closed", T);
    }, W = (T) => {
      z.value = true, a("overlay-opened", T);
    };
    return t({ toggleTimePicker: X }), (T, oe) => {
      var $;
      return openBlock(), createElementBlock("div", {
        class: "dp--tp-wrap",
        "data-dp-mobile": T.isMobile
      }, [
        !T.timePicker && !T.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: H,
          type: "button",
          class: normalizeClass({ ...O.value, "dp--hidden-el": ee.value }),
          "aria-label": ($ = unref(_2)) == null ? void 0 : $.openTimePicker,
          tabindex: T.noOverlayFocus ? void 0 : 0,
          "data-test-id": "open-time-picker-btn",
          onKeydown: oe[0] || (oe[0] = (Y) => unref(Ze)(Y, () => X(true))),
          onClick: oe[1] || (oe[1] = (Y) => X(true))
        }, [
          T.$slots["clock-icon"] ? renderSlot(T.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
          T.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(ja), { key: 1 }))
        ], 42, Pr)), [
          [vShow, !unref(N)(T.hideNavigation, "time")]
        ]) : createCommentVNode("", true),
        createVNode(Transition, {
          name: unref(P)(ee.value),
          css: unref(U) && !T.timePickerInline
        }, {
          default: withCtx(() => {
            var Y, g;
            return [
              ee.value || T.timePicker || T.timePickerInline ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref_key: "overlayRef",
                ref: k,
                role: T.timePickerInline ? void 0 : "dialog",
                class: normalizeClass({
                  dp__overlay: !T.timePickerInline,
                  "dp--overlay-absolute": !n.timePicker && !T.timePickerInline,
                  "dp--overlay-relative": n.timePicker
                }),
                style: normalizeStyle(T.timePicker ? { height: `${unref(C).modeHeight}px` } : void 0),
                "aria-label": (Y = unref(_2)) == null ? void 0 : Y.timePicker,
                tabindex: T.timePickerInline ? void 0 : 0
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(
                    T.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  T.$slots["time-picker-overlay"] ? renderSlot(T.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: me,
                    setMinutes: v,
                    setSeconds: L
                  }) : createCommentVNode("", true),
                  T.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(T.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(S.value, (Z, se) => withDirectives((openBlock(), createBlock(Tr, mergeProps({
                      key: se,
                      ref_for: true
                    }, {
                      ...T.$props,
                      order: se,
                      hours: Z.hours,
                      minutes: Z.minutes,
                      seconds: Z.seconds,
                      closeTimePickerBtn: f.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: se === 0 ? unref(m).fixedStart : unref(m).fixedEnd
                    }, {
                      ref_for: true,
                      ref_key: "timeInputRefs",
                      ref: I,
                      "validate-time": (R, ae) => e.validateTime(R, fe(ae, se, R)),
                      "onUpdate:hours": (R) => me(fe(R, se, "hours")),
                      "onUpdate:minutes": (R) => v(fe(R, se, "minutes")),
                      "onUpdate:seconds": (R) => L(fe(R, se, "seconds")),
                      onMounted: ne,
                      onOverlayClosed: p,
                      onOverlayOpened: W,
                      onAmPmChange: oe[2] || (oe[2] = (R) => T.$emit("am-pm-change", R))
                    }), createSlots({ _: 2 }, [
                      renderList(unref(K), (R, ae) => ({
                        name: R,
                        fn: withCtx((l) => [
                          renderSlot(T.$slots, R, mergeProps({ ref_for: true }, l))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [vShow, se === 0 ? true : q.value]
                    ])), 128))
                  ], 2)),
                  !T.timePicker && !T.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: f,
                    type: "button",
                    class: normalizeClass({ ...O.value, "dp--hidden-el": z.value }),
                    "aria-label": (g = unref(_2)) == null ? void 0 : g.closeTimePicker,
                    tabindex: "0",
                    onKeydown: oe[3] || (oe[3] = (Z) => unref(Ze)(Z, () => X(false))),
                    onClick: oe[4] || (oe[4] = (Z) => X(false))
                  }, [
                    T.$slots["calendar-icon"] ? renderSlot(T.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    T.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wt), { key: 1 }))
                  ], 42, Cr)), [
                    [vShow, !unref(N)(T.hideNavigation, "time")]
                  ]) : createCommentVNode("", true)
                ], 2)
              ], 14, Rr)) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 8, Sr);
    };
  }
}), jn = (e, t, r, a) => {
  const { defaultedRange: n } = _e(e), u = (k, z) => Array.isArray(t[k]) ? t[k][z] : t[k], d = (k) => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[k] : t.seconds : 0, y = (k, z) => k ? z !== void 0 ? Mt(k, u("hours", z), u("minutes", z), d(z)) : Mt(k, t.hours, t.minutes, d()) : setSeconds(j(), d(z)), i = (k, z) => {
    t[k] = z;
  }, _2 = computed(() => e.modelAuto && n.value.enabled ? Array.isArray(r.value) ? r.value.length > 1 : false : n.value.enabled), c = (k, z) => {
    const q = Object.fromEntries(
      Object.keys(t).map((ee) => ee === k ? [ee, z] : [ee, t[ee]].slice())
    );
    if (_2.value && !n.value.disableTimeRangeValidation) {
      const ee = (S) => r.value ? Mt(
        r.value[S],
        q.hours[S],
        q.minutes[S],
        q.seconds[S]
      ) : null, x = (S) => setMilliseconds(r.value[S], 0);
      return !(Ae(ee(0), ee(1)) && (isAfter(ee(0), x(1)) || isBefore(ee(1), x(0))));
    }
    return true;
  }, C = (k, z) => {
    c(k, z) && (i(k, z), a && a());
  }, m = (k) => {
    C("hours", k);
  }, P = (k) => {
    C("minutes", k);
  }, U = (k) => {
    C("seconds", k);
  }, N = (k, z, q, ee) => {
    z && m(k), !z && !q && P(k), q && U(k), r.value && ee(r.value);
  }, H = (k) => {
    if (k) {
      const z = Array.isArray(k), q = z ? [+k[0].hours, +k[1].hours] : +k.hours, ee = z ? [+k[0].minutes, +k[1].minutes] : +k.minutes, x = z ? [+k[0].seconds, +k[1].seconds] : +k.seconds;
      i("hours", q), i("minutes", ee), e.enableSeconds && i("seconds", x);
    }
  }, f = (k, z) => {
    const q = {
      hours: Array.isArray(t.hours) ? t.hours[k] : t.hours,
      disabledArr: []
    };
    return (z || z === 0) && (q.hours = z), Array.isArray(e.disabledTimes) && (q.disabledArr = n.value.enabled && Array.isArray(e.disabledTimes[k]) ? e.disabledTimes[k] : e.disabledTimes), q;
  }, I = computed(() => (k, z) => {
    var q;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: ee, hours: x } = f(k, z), S = ee.filter((X) => +X.hours === x);
      return ((q = S[0]) == null ? void 0 : q.minutes) === "*" ? { hours: [x], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (S == null ? void 0 : S.map((X) => +X.minutes)) ?? [],
        seconds: (S == null ? void 0 : S.map((X) => X.seconds ? +X.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: i,
    updateHours: m,
    updateMinutes: P,
    updateSeconds: U,
    getSetDateTime: y,
    updateTimeValues: N,
    getSecondsValue: d,
    assignStartTime: H,
    validateTime: c,
    disabledTimesConfig: I
  };
}, Or = (e, t) => {
  const r = () => {
    e.isTextInputDate && z();
  }, { modelValue: a, time: n } = aa(e, t, r), { defaultedStartTime: u, defaultedRange: d, defaultedTz: y } = _e(e), { updateTimeValues: i, getSetDateTime: _2, setTime: c, assignStartTime: C, disabledTimesConfig: m, validateTime: P } = jn(e, n, a, U);
  function U() {
    t("update-flow-step");
  }
  const N = (x) => {
    const { hours: S, minutes: X, seconds: O } = x;
    return { hours: +S, minutes: +X, seconds: O ? +O : 0 };
  }, H = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const S = N(e.startTime[0]), X = N(e.startTime[1]);
        return [set(j(), S), set(j(), X)];
      }
      const x = N(e.startTime);
      return set(j(), x);
    }
    return d.value.enabled ? [null, null] : null;
  }, f = () => {
    if (d.value.enabled) {
      const [x, S] = H();
      a.value = [
        et(_2(x, 0), y.value.timezone),
        et(_2(S, 1), y.value.timezone)
      ];
    } else
      a.value = et(_2(H()), y.value.timezone);
  }, I = (x) => Array.isArray(x) ? [Ct(j(x[0])), Ct(j(x[1]))] : [Ct(x ?? j())], k = (x, S, X) => {
    c("hours", x), c("minutes", S), c("seconds", e.enableSeconds ? X : 0);
  }, z = () => {
    const [x, S] = I(a.value);
    return d.value.enabled ? k(
      [x.hours, S.hours],
      [x.minutes, S.minutes],
      [x.seconds, S.seconds]
    ) : k(x.hours, x.minutes, x.seconds);
  };
  onMounted(() => {
    if (!e.shadow)
      return C(u.value), a.value ? z() : f();
  });
  const q = () => {
    Array.isArray(a.value) ? a.value = a.value.map((x, S) => x && _2(x, S)) : a.value = _2(a.value), t("time-update");
  };
  return {
    modelValue: a,
    time: n,
    disabledTimesConfig: m,
    updateTime: (x, S = true, X = false) => {
      i(x, S, X, q);
    },
    validateTime: P
  };
}, Br = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "time-update",
    "am-pm-change",
    "mount",
    "reset-flow",
    "update-flow-step",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, u = useSlots(), d = tt(u, "timePicker"), y = ref(null), { time: i, modelValue: _2, disabledTimesConfig: c, updateTime: C, validateTime: m } = Or(n, a);
    return onMounted(() => {
      n.shadow || a("mount", null);
    }), t({ getSidebarProps: () => ({
      modelValue: _2,
      time: i,
      updateTime: C
    }), toggleTimePicker: (N, H = false, f = "") => {
      var I;
      (I = y.value) == null || I.toggleTimePicker(N, H, f);
    } }), (N, H) => (openBlock(), createBlock(ma, {
      "multi-calendars": 0,
      stretch: "",
      "is-mobile": N.isMobile
    }, {
      default: withCtx(() => [
        createVNode(Vn, mergeProps({
          ref_key: "tpRef",
          ref: y
        }, N.$props, {
          hours: unref(i).hours,
          minutes: unref(i).minutes,
          seconds: unref(i).seconds,
          "internal-model-value": N.internalModelValue,
          "disabled-times-config": unref(c),
          "validate-time": unref(m),
          "onUpdate:hours": H[0] || (H[0] = (f) => unref(C)(f)),
          "onUpdate:minutes": H[1] || (H[1] = (f) => unref(C)(f, false)),
          "onUpdate:seconds": H[2] || (H[2] = (f) => unref(C)(f, false, true)),
          onAmPmChange: H[3] || (H[3] = (f) => N.$emit("am-pm-change", f)),
          onResetFlow: H[4] || (H[4] = (f) => N.$emit("reset-flow")),
          onOverlayClosed: H[5] || (H[5] = (f) => N.$emit("overlay-toggle", { open: false, overlay: f })),
          onOverlayOpened: H[6] || (H[6] = (f) => N.$emit("overlay-toggle", { open: true, overlay: f }))
        }), createSlots({ _: 2 }, [
          renderList(unref(d), (f, I) => ({
            name: f,
            fn: withCtx((k) => [
              renderSlot(N.$slots, f, normalizeProps(guardReactiveProps(k)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }, 8, ["is-mobile"]));
  }
}), _r = { class: "dp--header-wrap" }, Yr = {
  key: 0,
  class: "dp__month_year_wrap"
}, Ir = { key: 0 }, Er = { class: "dp__month_year_wrap" }, Nr = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"], Fr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...ct
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, {
      defaultedTransitions: u,
      defaultedAriaLabels: d,
      defaultedMultiCalendars: y,
      defaultedFilters: i,
      defaultedConfig: _2,
      defaultedHighlight: c,
      propDates: C,
      defaultedUI: m
    } = _e(n), { transitionName: P, showTransition: U } = ta(u), { buildMatrix: N } = At(), { handleMonthYearChange: H, isDisabled: f, updateMonthYear: I } = lr(n, a), { showLeftIcon: k, showRightIcon: z } = ya(), q = ref(false), ee = ref(false), x = ref(false), S = ref([null, null, null, null]);
    onMounted(() => {
      a("mount");
    });
    const X = (g) => ({
      get: () => n[g],
      set: (Z) => {
        const se = g === ut.month ? ut.year : ut.month;
        a("update-month-year", { [g]: Z, [se]: n[se] }), g === ut.month ? p(true) : W(true);
      }
    }), O = computed(X(ut.month)), K = computed(X(ut.year)), fe = computed(() => (g) => ({
      month: n.month,
      year: n.year,
      items: g === ut.month ? n.months : n.years,
      instance: n.instance,
      updateMonthYear: I,
      toggle: g === ut.month ? p : W
    })), me = computed(() => {
      const g = n.months.find((Z) => Z.value === n.month);
      return g || { text: "", value: 0 };
    }), v = computed(() => zt(n.months, (g) => {
      const Z = n.month === g.value, se = Xt(
        g.value,
        Bn(n.year, C.value.minDate),
        _n(n.year, C.value.maxDate)
      ) || i.value.months.includes(g.value), R = Fn(c.value, g.value, n.year);
      return { active: Z, disabled: se, highlighted: R };
    })), L = computed(() => zt(n.years, (g) => {
      const Z = n.year === g.value, se = Xt(
        g.value,
        Ht(C.value.minDate),
        Ht(C.value.maxDate)
      ) || i.value.years.includes(g.value), R = Za(c.value, g.value);
      return { active: Z, disabled: se, highlighted: R };
    })), ne = (g, Z, se) => {
      se !== void 0 ? g.value = se : g.value = !g.value, g.value ? (x.value = true, a("overlay-opened", Z)) : (x.value = false, a("overlay-closed", Z));
    }, p = (g = false, Z) => {
      T(g), ne(q, Ge.month, Z);
    }, W = (g = false, Z) => {
      T(g), ne(ee, Ge.year, Z);
    }, T = (g) => {
      g || a("reset-flow");
    }, oe = (g, Z) => {
      n.arrowNavigation && (S.value[Z] = Le(g), N(S.value, "monthYear"));
    }, $ = computed(() => {
      var g, Z, se, R, ae, l;
      return [
        {
          type: ut.month,
          index: 1,
          toggle: p,
          modelValue: O.value,
          updateModelValue: (D) => O.value = D,
          text: me.value.text,
          showSelectionGrid: q.value,
          items: v.value,
          ariaLabel: (g = d.value) == null ? void 0 : g.openMonthsOverlay,
          overlayLabel: ((se = (Z = d.value).monthPicker) == null ? void 0 : se.call(Z, true)) ?? void 0
        },
        {
          type: ut.year,
          index: 2,
          toggle: W,
          modelValue: K.value,
          updateModelValue: (D) => K.value = D,
          text: Cn(n.year, n.locale),
          showSelectionGrid: ee.value,
          items: L.value,
          ariaLabel: (R = d.value) == null ? void 0 : R.openYearsOverlay,
          overlayLabel: ((l = (ae = d.value).yearPicker) == null ? void 0 : l.call(ae, true)) ?? void 0
        }
      ];
    }), Y = computed(() => n.disableYearSelect ? [$.value[0]] : n.yearFirst ? [...$.value].reverse() : $.value);
    return t({
      toggleMonthPicker: p,
      toggleYearPicker: W,
      handleMonthYearChange: H
    }), (g, Z) => {
      var se, R, ae, l, D, ue;
      return openBlock(), createElementBlock("div", _r, [
        g.$slots["month-year"] ? (openBlock(), createElementBlock("div", Yr, [
          renderSlot(g.$slots, "month-year", normalizeProps(guardReactiveProps({
            month: e.month,
            year: e.year,
            months: e.months,
            years: e.years,
            updateMonthYear: unref(I),
            handleMonthYearChange: unref(H),
            instance: e.instance,
            isDisabled: unref(f)
          })))
        ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          g.$slots["top-extra"] ? (openBlock(), createElementBlock("div", Ir, [
            renderSlot(g.$slots, "top-extra", { value: g.internalModelValue })
          ])) : createCommentVNode("", true),
          createBaseVNode("div", Er, [
            unref(k)(unref(y), e.instance) && !g.vertical ? (openBlock(), createBlock(Kt, {
              key: 0,
              "aria-label": (se = unref(d)) == null ? void 0 : se.prevMonth,
              disabled: unref(f)(false),
              class: normalizeClass((R = unref(m)) == null ? void 0 : R.navBtnPrev),
              "el-name": "action-prev",
              onActivate: Z[0] || (Z[0] = (M) => unref(H)(false, true)),
              onSetRef: Z[1] || (Z[1] = (M) => oe(M, 0))
            }, {
              default: withCtx(() => [
                g.$slots["arrow-left"] ? renderSlot(g.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                g.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wa), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(["dp__month_year_wrap", {
                dp__year_disable_select: g.disableYearSelect
              }])
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(Y.value, (M, he) => (openBlock(), createElementBlock(Fragment, {
                key: M.type
              }, [
                createBaseVNode("button", {
                  ref_for: true,
                  ref: (pe) => oe(pe, he + 1),
                  type: "button",
                  "data-dp-element": `overlay-${M.type}`,
                  class: normalizeClass(["dp__btn dp__month_year_select", { "dp--hidden-el": x.value }]),
                  "aria-label": `${M.text}-${M.ariaLabel}`,
                  "data-test-id": `${M.type}-toggle-overlay-${e.instance}`,
                  onClick: M.toggle,
                  onKeydown: (pe) => unref(Ze)(pe, () => M.toggle(), true)
                }, [
                  g.$slots[M.type] ? renderSlot(g.$slots, M.type, {
                    key: 0,
                    text: M.text,
                    value: n[M.type]
                  }) : createCommentVNode("", true),
                  g.$slots[M.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(M.text), 1)
                  ], 64))
                ], 42, Nr),
                createVNode(Transition, {
                  name: unref(P)(M.showSelectionGrid),
                  css: unref(U)
                }, {
                  default: withCtx(() => [
                    M.showSelectionGrid ? (openBlock(), createBlock(ea, {
                      key: 0,
                      items: M.items,
                      "arrow-navigation": g.arrowNavigation,
                      "hide-navigation": g.hideNavigation,
                      "is-last": g.autoApply && !unref(_2).keepActionRow,
                      "skip-button-ref": false,
                      config: g.config,
                      type: M.type,
                      "header-refs": [],
                      "esc-close": g.escClose,
                      "menu-wrap-ref": g.menuWrapRef,
                      "text-input": g.textInput,
                      "aria-labels": g.ariaLabels,
                      "overlay-label": M.overlayLabel,
                      onSelected: M.updateModelValue,
                      onToggle: M.toggle
                    }, createSlots({
                      "button-icon": withCtx(() => [
                        g.$slots["calendar-icon"] ? renderSlot(g.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                        g.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      g.$slots[`${M.type}-overlay-value`] ? {
                        name: "item",
                        fn: withCtx(({ item: pe }) => [
                          renderSlot(g.$slots, `${M.type}-overlay-value`, {
                            text: pe.text,
                            value: pe.value
                          })
                        ]),
                        key: "0"
                      } : void 0,
                      g.$slots[`${M.type}-overlay`] ? {
                        name: "overlay",
                        fn: withCtx(() => [
                          renderSlot(g.$slots, `${M.type}-overlay`, mergeProps({ ref_for: true }, fe.value(M.type)))
                        ]),
                        key: "1"
                      } : void 0,
                      g.$slots[`${M.type}-overlay-header`] ? {
                        name: "header",
                        fn: withCtx(() => [
                          renderSlot(g.$slots, `${M.type}-overlay-header`, {
                            toggle: M.toggle
                          })
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ], 64))), 128))
            ], 2),
            unref(k)(unref(y), e.instance) && g.vertical ? (openBlock(), createBlock(Kt, {
              key: 1,
              "aria-label": (ae = unref(d)) == null ? void 0 : ae.prevMonth,
              "el-name": "action-prev",
              disabled: unref(f)(false),
              class: normalizeClass((l = unref(m)) == null ? void 0 : l.navBtnPrev),
              onActivate: Z[2] || (Z[2] = (M) => unref(H)(false, true))
            }, {
              default: withCtx(() => [
                g.$slots["arrow-up"] ? renderSlot(g.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                g.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            unref(z)(unref(y), e.instance) ? (openBlock(), createBlock(Kt, {
              key: 2,
              ref: "rightIcon",
              "el-name": "action-next",
              disabled: unref(f)(true),
              "aria-label": (D = unref(d)) == null ? void 0 : D.nextMonth,
              class: normalizeClass((ue = unref(m)) == null ? void 0 : ue.navBtnNext),
              onActivate: Z[3] || (Z[3] = (M) => unref(H)(true, true)),
              onSetRef: Z[4] || (Z[4] = (M) => oe(M, g.disableYearSelect ? 2 : 3))
            }, {
              default: withCtx(() => [
                g.$slots[g.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(g.$slots, g.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
                g.$slots[g.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(g.vertical ? unref(Ga) : unref(Va)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label", "class"])) : createCommentVNode("", true)
          ])
        ], 64))
      ]);
    };
  }
}), Lr = {
  class: "dp__calendar_header",
  role: "row"
}, zr = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, Hr = ["aria-label"], Ur = {
  key: 0,
  class: "dp__calendar_item dp__week_num",
  role: "gridcell"
}, Wr = { class: "dp__cell_inner" }, Vr = ["id", "aria-pressed", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"], jr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...ct
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, { buildMultiLevelMatrix: u } = At(), {
      defaultedTransitions: d,
      defaultedConfig: y,
      defaultedAriaLabels: i,
      defaultedMultiCalendars: _2,
      defaultedWeekNumbers: c,
      defaultedMultiDates: C,
      defaultedUI: m
    } = _e(n), P = ref(null), U = ref({
      bottom: "",
      left: "",
      transform: ""
    }), N = ref([]), H = ref(null), f = ref(true), I = ref(""), k = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), z = ref([]), q = ref({ left: "50%" }), ee = ref(false), x = computed(() => n.calendar ? n.calendar(n.mappedDates) : n.mappedDates), S = computed(() => n.dayNames ? Array.isArray(n.dayNames) ? n.dayNames : n.dayNames(n.locale, +n.weekStart) : Ml(n.formatLocale, n.locale, +n.weekStart));
    onMounted(() => {
      a("mount", { cmp: "calendar", refs: N }), y.value.noSwipe || H.value && (H.value.addEventListener("touchstart", oe, { passive: false }), H.value.addEventListener("touchend", $, { passive: false }), H.value.addEventListener("touchmove", Y, { passive: false })), n.monthChangeOnScroll && H.value && H.value.addEventListener("wheel", se, { passive: false });
    });
    const X = (M) => M ? n.vertical ? "vNext" : "next" : n.vertical ? "vPrevious" : "previous", O = (M, he) => {
      if (n.transitions) {
        const pe = We(yt(j(), n.month, n.year));
        I.value = Ee(We(yt(j(), M, he)), pe) ? d.value[X(true)] : d.value[X(false)], f.value = false, nextTick(() => {
          f.value = true;
        });
      }
    }, K = computed(
      () => ({
        ...m.value.calendar ?? {}
      })
    ), fe = computed(() => (M) => {
      const he = Al(M);
      return {
        dp__marker_dot: he.type === "dot",
        dp__marker_line: he.type === "line"
      };
    }), me = computed(() => (M) => Ae(M, P.value)), v = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: _2.value.count > 0 && n.instance !== 0
    })), L = computed(() => (M) => n.hideOffsetDates ? M.current : true), ne = async (M, he) => {
      const { width: pe, height: re } = M.getBoundingClientRect();
      P.value = he.value;
      let o = { left: `${pe / 2}px` }, E = -50;
      if (await nextTick(), z.value[0]) {
        const { left: ce, width: B } = z.value[0].getBoundingClientRect();
        ce < 0 && (o = { left: "0" }, E = 0, q.value.left = `${pe / 2}px`), window.innerWidth < ce + B && (o = { right: "0" }, E = 0, q.value.left = `${B - pe / 2}px`);
      }
      U.value = {
        bottom: `${re}px`,
        ...o,
        transform: `translateX(${E}%)`
      };
    }, p = async (M, he, pe) => {
      var o, E, ce;
      const re = Le(N.value[he][pe]);
      re && ((o = M.marker) != null && o.customPosition && ((ce = (E = M.marker) == null ? void 0 : E.tooltip) != null && ce.length) ? U.value = M.marker.customPosition(re) : await ne(re, M), a("tooltip-open", M.marker));
    }, W = async (M, he, pe) => {
      var re, o;
      if (ee.value && C.value.enabled && C.value.dragSelect)
        return a("select-date", M);
      if (a("set-hover-date", M), (o = (re = M.marker) == null ? void 0 : re.tooltip) != null && o.length) {
        if (n.hideOffsetDates && !M.current) return;
        await p(M, he, pe);
      }
    }, T = (M) => {
      P.value && (P.value = null, U.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", M.marker));
    }, oe = (M) => {
      k.value.startX = M.changedTouches[0].screenX, k.value.startY = M.changedTouches[0].screenY;
    }, $ = (M) => {
      k.value.endX = M.changedTouches[0].screenX, k.value.endY = M.changedTouches[0].screenY, g();
    }, Y = (M) => {
      n.vertical && !n.inline && M.preventDefault();
    }, g = () => {
      const M = n.vertical ? "Y" : "X";
      Math.abs(k.value[`start${M}`] - k.value[`end${M}`]) > 10 && a("handle-swipe", k.value[`start${M}`] > k.value[`end${M}`] ? "right" : "left");
    }, Z = (M, he, pe) => {
      M && (Array.isArray(N.value[he]) ? N.value[he][pe] = M : N.value[he] = [M]), n.arrowNavigation && u(N.value, "calendar");
    }, se = (M) => {
      n.monthChangeOnScroll && (M.preventDefault(), a("handle-scroll", M));
    }, R = (M) => c.value.type === "local" ? getWeek(M.value, { weekStartsOn: +n.weekStart }) : c.value.type === "iso" ? getISOWeek(M.value) : typeof c.value.type == "function" ? c.value.type(M.value) : "", ae = (M) => {
      const he = M[0];
      return c.value.hideOnOffsetDates ? M.some((pe) => pe.current) ? R(he) : "" : R(he);
    }, l = (M, he, pe = true) => {
      !pe && Cl() || (!C.value.enabled || y.value.allowPreventDefault) && (Dt(M, y.value), a("select-date", he));
    }, D = (M) => {
      Dt(M, y.value);
    }, ue = (M) => {
      C.value.enabled && C.value.dragSelect ? (ee.value = true, a("select-date", M)) : C.value.enabled && a("select-date", M);
    };
    return t({ triggerTransition: O }), (M, he) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(v.value)
    }, [
      createBaseVNode("div", {
        ref_key: "calendarWrapRef",
        ref: H,
        class: normalizeClass(K.value),
        role: "grid"
      }, [
        createBaseVNode("div", Lr, [
          M.weekNumbers ? (openBlock(), createElementBlock("div", zr, toDisplayString(M.weekNumName), 1)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(S.value, (pe, re) => {
            var o, E;
            return openBlock(), createElementBlock("div", {
              key: re,
              class: "dp__calendar_header_item",
              role: "gridcell",
              "data-test-id": "calendar-header",
              "aria-label": (E = (o = unref(i)) == null ? void 0 : o.weekDay) == null ? void 0 : E.call(o, re)
            }, [
              M.$slots["calendar-header"] ? renderSlot(M.$slots, "calendar-header", {
                key: 0,
                day: pe,
                index: re
              }) : createCommentVNode("", true),
              M.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(pe), 1)
              ], 64))
            ], 8, Hr);
          }), 128))
        ]),
        he[2] || (he[2] = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1)),
        createVNode(Transition, {
          name: I.value,
          css: !!M.transitions
        }, {
          default: withCtx(() => [
            f.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "dp__calendar",
              role: "rowgroup",
              onMouseleave: he[1] || (he[1] = (pe) => ee.value = false)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(x.value, (pe, re) => (openBlock(), createElementBlock("div", {
                key: re,
                class: "dp__calendar_row",
                role: "row"
              }, [
                M.weekNumbers ? (openBlock(), createElementBlock("div", Ur, [
                  createBaseVNode("div", Wr, toDisplayString(ae(pe.days)), 1)
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(pe.days, (o, E) => {
                  var ce, B, Me;
                  return openBlock(), createElementBlock("div", {
                    id: unref(Ha)(o.value),
                    ref_for: true,
                    ref: (be) => Z(be, re, E),
                    key: E + re,
                    role: "gridcell",
                    class: "dp__calendar_item",
                    "aria-pressed": (o.classData.dp__active_date || o.classData.dp__range_start || o.classData.dp__range_start) ?? void 0,
                    "aria-disabled": o.classData.dp__cell_disabled || void 0,
                    "aria-label": (B = (ce = unref(i)) == null ? void 0 : ce.day) == null ? void 0 : B.call(ce, o),
                    tabindex: !o.current && M.hideOffsetDates ? void 0 : 0,
                    "data-test-id": unref(Ha)(o.value),
                    onClick: withModifiers((be) => l(be, o), ["prevent"]),
                    onTouchend: (be) => l(be, o, false),
                    onKeydown: (be) => unref(Ze)(be, () => M.$emit("select-date", o)),
                    onMouseenter: (be) => W(o, re, E),
                    onMouseleave: (be) => T(o),
                    onMousedown: (be) => ue(o),
                    onMouseup: he[0] || (he[0] = (be) => ee.value = false)
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__cell_inner", o.classData])
                    }, [
                      M.$slots.day && L.value(o) ? renderSlot(M.$slots, "day", {
                        key: 0,
                        day: +o.text,
                        date: o.value
                      }) : createCommentVNode("", true),
                      M.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(o.text), 1)
                      ], 64)),
                      o.marker && L.value(o) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                        M.$slots.marker ? renderSlot(M.$slots, "marker", {
                          key: 0,
                          marker: o.marker,
                          day: +o.text,
                          date: o.value
                        }) : (openBlock(), createElementBlock("div", {
                          key: 1,
                          class: normalizeClass(fe.value(o.marker)),
                          style: normalizeStyle(o.marker.color ? { backgroundColor: o.marker.color } : {})
                        }, null, 6))
                      ], 64)) : createCommentVNode("", true),
                      me.value(o.value) ? (openBlock(), createElementBlock("div", {
                        key: 3,
                        ref_for: true,
                        ref_key: "activeTooltip",
                        ref: z,
                        class: "dp__marker_tooltip",
                        style: normalizeStyle(U.value)
                      }, [
                        (Me = o.marker) != null && Me.tooltip ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "dp__tooltip_content",
                          onClick: D
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(o.marker.tooltip, (be, Se) => (openBlock(), createElementBlock("div", {
                            key: Se,
                            class: "dp__tooltip_text"
                          }, [
                            M.$slots["marker-tooltip"] ? renderSlot(M.$slots, "marker-tooltip", {
                              key: 0,
                              tooltip: be,
                              day: o.value
                            }) : createCommentVNode("", true),
                            M.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createBaseVNode("div", {
                                class: "dp__tooltip_mark",
                                style: normalizeStyle(be.color ? { backgroundColor: be.color } : {})
                              }, null, 4),
                              createBaseVNode("div", null, toDisplayString(be.text), 1)
                            ], 64))
                          ]))), 128)),
                          createBaseVNode("div", {
                            class: "dp__arrow_bottom_tp",
                            style: normalizeStyle(q.value)
                          }, null, 4)
                        ])) : createCommentVNode("", true)
                      ], 4)) : createCommentVNode("", true)
                    ], 2)
                  ], 40, Vr);
                }), 128))
              ]))), 128))
            ], 32)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 2)
    ], 2));
  }
}), yn = (e) => Array.isArray(e), Kr = (e, t, r, a) => {
  const n = ref([]), u = ref(/* @__PURE__ */ new Date()), d = ref(), y = () => $(e.isTextInputDate), { modelValue: i, calendars: _2, time: c, today: C } = aa(e, t, y), {
    defaultedMultiCalendars: m,
    defaultedStartTime: P,
    defaultedRange: U,
    defaultedConfig: N,
    defaultedTz: H,
    propDates: f,
    defaultedMultiDates: I
  } = _e(e), { validateMonthYearInRange: k, isDisabled: z, isDateRangeAllowed: q, checkMinMaxRange: ee } = Tt(e), { updateTimeValues: x, getSetDateTime: S, setTime: X, assignStartTime: O, validateTime: K, disabledTimesConfig: fe } = jn(e, c, i, a), me = computed(
    () => (h2) => _2.value[h2] ? _2.value[h2].month : 0
  ), v = computed(
    () => (h2) => _2.value[h2] ? _2.value[h2].year : 0
  ), L = (h2) => !N.value.keepViewOnOffsetClick || h2 ? true : !d.value, ne = (h2, le, w, G = false) => {
    var ie, Xe;
    L(G) && (_2.value[h2] || (_2.value[h2] = { month: 0, year: 0 }), _2.value[h2].month = dn(le) ? (ie = _2.value[h2]) == null ? void 0 : ie.month : le, _2.value[h2].year = dn(w) ? (Xe = _2.value[h2]) == null ? void 0 : Xe.year : w);
  }, p = () => {
    e.autoApply && t("select-date");
  }, W = () => {
    P.value && O(P.value);
  };
  onMounted(() => {
    e.shadow || (i.value || (he(), W()), $(true), e.focusStartDate && e.startDate && he());
  });
  const T = computed(() => {
    var h2;
    return (h2 = e.flow) != null && h2.length && !e.partialFlow ? e.flowStep === e.flow.length : true;
  }), oe = () => {
    e.autoApply && T.value && t("auto-apply", e.partialFlow ? e.flowStep !== e.flow.length : false);
  }, $ = (h2 = false) => {
    if (i.value)
      return Array.isArray(i.value) ? (n.value = i.value, l(h2)) : Z(i.value, h2);
    if (m.value.count && h2 && !e.startDate)
      return g(j(), h2);
  }, Y = () => Array.isArray(i.value) && U.value.enabled ? getMonth(i.value[0]) === getMonth(i.value[1] ?? i.value[0]) : false, g = (h2 = /* @__PURE__ */ new Date(), le = false) => {
    if ((!m.value.count || !m.value.static || le) && ne(0, getMonth(h2), getYear(h2)), m.value.count && (!i.value || Y() || !m.value.solo) && (!m.value.solo || le))
      for (let w = 1; w < m.value.count; w++) {
        const G = set(j(), { month: me.value(w - 1), year: v.value(w - 1) }), ie = add(G, { months: 1 });
        _2.value[w] = { month: getMonth(ie), year: getYear(ie) };
      }
  }, Z = (h2, le) => {
    g(h2), X("hours", getHours(h2)), X("minutes", getMinutes(h2)), X("seconds", getSeconds(h2)), m.value.count && le && M();
  }, se = (h2) => {
    if (m.value.count) {
      if (m.value.solo) return 0;
      const le = getMonth(h2[0]), w = getMonth(h2[1]);
      return Math.abs(w - le) < m.value.count ? 0 : 1;
    }
    return 1;
  }, R = (h2, le) => {
    h2[1] && U.value.showLastInRange ? g(h2[se(h2)], le) : g(h2[0], le);
    const w = (G, ie) => [
      G(h2[0]),
      h2[1] ? G(h2[1]) : c[ie][1]
    ];
    X("hours", w(getHours, "hours")), X("minutes", w(getMinutes, "minutes")), X("seconds", w(getSeconds, "seconds"));
  }, ae = (h2, le) => {
    if ((U.value.enabled || e.weekPicker) && !I.value.enabled)
      return R(h2, le);
    if (I.value.enabled && le) {
      const w = h2[h2.length - 1];
      return Z(w, le);
    }
  }, l = (h2) => {
    const le = i.value;
    ae(le, h2), m.value.count && m.value.solo && M();
  }, D = (h2, le) => {
    const w = set(j(), { month: me.value(le), year: v.value(le) }), G = h2 < 0 ? addMonths(w, 1) : subMonths(w, 1);
    k(getMonth(G), getYear(G), h2 < 0, e.preventMinMaxNavigation) && (ne(le, getMonth(G), getYear(G)), t("update-month-year", { instance: le, month: getMonth(G), year: getYear(G) }), m.value.count && !m.value.solo && ue(le), r());
  }, ue = (h2) => {
    for (let le = h2 - 1; le >= 0; le--) {
      const w = subMonths(set(j(), { month: me.value(le + 1), year: v.value(le + 1) }), 1);
      ne(le, getMonth(w), getYear(w));
    }
    for (let le = h2 + 1; le <= m.value.count - 1; le++) {
      const w = addMonths(set(j(), { month: me.value(le - 1), year: v.value(le - 1) }), 1);
      ne(le, getMonth(w), getYear(w));
    }
  }, M = () => {
    if (Array.isArray(i.value) && i.value.length === 2) {
      const h2 = j(
        j(i.value[1] ? i.value[1] : addMonths(i.value[0], 1))
      ), [le, w] = [getMonth(i.value[0]), getYear(i.value[0])], [G, ie] = [getMonth(i.value[1]), getYear(i.value[1])];
      (le !== G || le === G && w !== ie) && m.value.solo && ne(1, getMonth(h2), getYear(h2));
    } else i.value && !Array.isArray(i.value) && (ne(0, getMonth(i.value), getYear(i.value)), g(j()));
  }, he = () => {
    e.startDate && (ne(0, getMonth(j(e.startDate)), getYear(j(e.startDate))), m.value.count && ue(0));
  }, pe = (h2, le) => {
    if (e.monthChangeOnScroll) {
      const w = (/* @__PURE__ */ new Date()).getTime() - u.value.getTime(), G = Math.abs(h2.deltaY);
      let ie = 500;
      G > 1 && (ie = 100), G > 100 && (ie = 0), w > ie && (u.value = /* @__PURE__ */ new Date(), D(e.monthChangeOnScroll !== "inverse" ? -h2.deltaY : h2.deltaY, le));
    }
  }, re = (h2, le, w = false) => {
    e.monthChangeOnArrows && e.vertical === w && o(h2, le);
  }, o = (h2, le) => {
    D(h2 === "right" ? -1 : 1, le);
  }, E = (h2) => {
    if (f.value.markers)
      return ca(h2.value, f.value.markers);
  }, ce = (h2, le) => {
    switch (e.sixWeeks === true ? "append" : e.sixWeeks) {
      case "prepend":
        return [true, false];
      case "center":
        return [h2 == 0, true];
      case "fair":
        return [h2 == 0 || le > h2, true];
      case "append":
        return [false, false];
      default:
        return [false, false];
    }
  }, B = (h2, le, w, G) => {
    if (e.sixWeeks && h2.length < 6) {
      const ie = 6 - h2.length, Xe = (le.getDay() + 7 - G) % 7, _t = 6 - (w.getDay() + 7 - G) % 7, [Vt, $a] = ce(Xe, _t);
      for (let St = 1; St <= ie; St++)
        if ($a ? !!(St % 2) == Vt : Vt) {
          const la = h2[0].days[0], Aa = Me(addDays(la.value, -7), getMonth(le));
          h2.unshift({ days: Aa });
        } else {
          const la = h2[h2.length - 1], Aa = la.days[la.days.length - 1], Qn = Me(addDays(Aa.value, 1), getMonth(le));
          h2.push({ days: Qn });
        }
    }
    return h2;
  }, Me = (h2, le) => {
    const w = j(h2), G = [];
    for (let ie = 0; ie < 7; ie++) {
      const Xe = addDays(w, ie), st = getMonth(Xe) !== le;
      G.push({
        text: e.hideOffsetDates && st ? "" : Xe.getDate(),
        value: Xe,
        current: !st,
        classData: {}
      });
    }
    return G;
  }, be = (h2, le) => {
    const w = [], G = new Date(le, h2), ie = new Date(le, h2 + 1, 0), Xe = e.weekStart, st = startOfWeek(G, { weekStartsOn: Xe }), _t = (Vt) => {
      const $a = Me(Vt, h2);
      if (w.push({ days: $a }), !w[w.length - 1].days.some(
        (St) => Ae(We(St.value), We(ie))
      )) {
        const St = addDays(Vt, 7);
        _t(St);
      }
    };
    return _t(st), B(w, G, ie, Xe);
  }, Se = (h2) => {
    const le = Mt(j(h2.value), c.hours, c.minutes, Ue());
    t("date-update", le), I.value.enabled ? xa(le, i, I.value.limit) : i.value = le, a(), nextTick().then(() => {
      oe();
    });
  }, b = (h2) => U.value.noDisabledRange ? Yn(n.value[0], h2).some((w) => z(w)) : false, F2 = () => {
    n.value = i.value ? i.value.slice() : [], n.value.length === 2 && !(U.value.fixedStart || U.value.fixedEnd) && (n.value = []);
  }, Re2 = (h2, le) => {
    const w = [
      j(h2.value),
      addDays(j(h2.value), +U.value.autoRange)
    ];
    q(w) ? (le && Fe(h2.value), n.value = w) : t("invalid-date", h2.value);
  }, Fe = (h2) => {
    const le = getMonth(j(h2)), w = getYear(j(h2));
    if (ne(0, le, w), m.value.count > 0)
      for (let G = 1; G < m.value.count; G++) {
        const ie = Yl(
          set(j(h2), { year: v.value(G - 1), month: me.value(G - 1) })
        );
        ne(G, ie.month, ie.year);
      }
  }, mt = (h2) => {
    if (b(h2.value) || !ee(h2.value, i.value, U.value.fixedStart ? 0 : 1))
      return t("invalid-date", h2.value);
    n.value = Un(j(h2.value), i, t, U);
  }, ve2 = (h2, le) => {
    if (F2(), U.value.autoRange) return Re2(h2, le);
    if (U.value.fixedStart || U.value.fixedEnd) return mt(h2);
    n.value[0] ? ee(j(h2.value), i.value) && !b(h2.value) ? Ye(j(h2.value), j(n.value[0])) ? (n.value.unshift(j(h2.value)), t("range-end", n.value[0])) : (n.value[1] = j(h2.value), t("range-end", n.value[1])) : (e.autoApply && t("auto-apply-invalid", h2.value), t("invalid-date", h2.value)) : (n.value[0] = j(h2.value), t("range-start", n.value[0]));
  }, Ue = (h2 = true) => e.enableSeconds ? Array.isArray(c.seconds) ? h2 ? c.seconds[0] : c.seconds[1] : c.seconds : 0, lt = (h2) => {
    n.value[h2] = Mt(
      n.value[h2],
      c.hours[h2],
      c.minutes[h2],
      Ue(h2 !== 1)
    );
  }, ga = () => {
    var h2, le;
    n.value[0] && n.value[1] && +((h2 = n.value) == null ? void 0 : h2[0]) > +((le = n.value) == null ? void 0 : le[1]) && (n.value.reverse(), t("range-start", n.value[0]), t("range-end", n.value[1]));
  }, na = () => {
    n.value.length && (n.value[0] && !n.value[1] ? lt(0) : (lt(0), lt(1), a()), ga(), i.value = n.value.slice(), pa(n.value, t, e.autoApply, e.modelAuto));
  }, ha = (h2, le = false) => {
    if (z(h2.value) || !h2.current && e.hideOffsetDates) return t("invalid-date", h2.value);
    if (d.value = JSON.parse(JSON.stringify(h2)), !U.value.enabled) return Se(h2);
    yn(c.hours) && yn(c.minutes) && !I.value.enabled && (ve2(h2, le), na());
  }, ba = (h2, le) => {
    var G;
    ne(h2, le.month, le.year, true), m.value.count && !m.value.solo && ue(h2), t("update-month-year", { instance: h2, month: le.month, year: le.year }), r(m.value.solo ? h2 : void 0);
    const w = (G = e.flow) != null && G.length ? e.flow[e.flowStep] : void 0;
    !le.fromNav && (w === Ge.month || w === Ge.year) && a();
  }, ka = (h2, le) => {
    Hn({
      value: h2,
      modelValue: i,
      range: U.value.enabled,
      timezone: le ? void 0 : H.value.timezone
    }), p(), e.multiCalendars && nextTick().then(() => $(true));
  }, wa = () => {
    const h2 = Qa(j(), H.value);
    !U.value.enabled && !I.value.enabled ? i.value = h2 : i.value && Array.isArray(i.value) && i.value[0] ? I.value.enabled ? i.value = [...i.value, h2] : i.value = Ye(h2, i.value[0]) ? [h2, i.value[0]] : [i.value[0], h2] : i.value = [h2], p();
  }, Da = () => {
    if (Array.isArray(i.value))
      if (I.value.enabled) {
        const h2 = Ma();
        i.value[i.value.length - 1] = S(h2);
      } else
        i.value = i.value.map((h2, le) => h2 && S(h2, le));
    else
      i.value = S(i.value);
    t("time-update");
  }, Ma = () => Array.isArray(i.value) && i.value.length ? i.value[i.value.length - 1] : null;
  return {
    calendars: _2,
    modelValue: i,
    month: me,
    year: v,
    time: c,
    disabledTimesConfig: fe,
    today: C,
    validateTime: K,
    getCalendarDays: be,
    getMarker: E,
    handleScroll: pe,
    handleSwipe: o,
    handleArrow: re,
    selectDate: ha,
    updateMonthYear: ba,
    presetDate: ka,
    selectCurrentDate: wa,
    updateTime: (h2, le = true, w = false) => {
      x(h2, le, w, Da);
    },
    assignMonthAndYear: g,
    setStartTime: W
  };
}, Gr = { key: 0 }, Qr = /* @__PURE__ */ defineComponent({
  __name: "DatePicker",
  props: {
    ...ct
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, {
      calendars: u,
      month: d,
      year: y,
      modelValue: i,
      time: _2,
      disabledTimesConfig: c,
      today: C,
      validateTime: m,
      getCalendarDays: P,
      getMarker: U,
      handleArrow: N,
      handleScroll: H,
      handleSwipe: f,
      selectDate: I,
      updateMonthYear: k,
      presetDate: z,
      selectCurrentDate: q,
      updateTime: ee,
      assignMonthAndYear: x,
      setStartTime: S
    } = Kr(n, a, Y, g), X = useSlots(), { setHoverDate: O, getDayClassData: K, clearHoverDate: fe } = fo(i, n), { defaultedMultiCalendars: me } = _e(n), v = ref([]), L = ref([]), ne = ref(null), p = tt(X, "calendar"), W = tt(X, "monthYear"), T = tt(X, "timePicker"), oe = (re) => {
      n.shadow || a("mount", re);
    };
    watch(
      u,
      () => {
        n.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: true }
    ), watch(
      me,
      (re, o) => {
        re.count - o.count > 0 && x();
      },
      { deep: true }
    );
    const $ = computed(() => (re) => P(d.value(re), y.value(re)).map((o) => ({
      ...o,
      days: o.days.map((E) => (E.marker = U(E), E.classData = K(E), E))
    })));
    function Y(re) {
      var o;
      re || re === 0 ? (o = L.value[re]) == null || o.triggerTransition(d.value(re), y.value(re)) : L.value.forEach((E, ce) => E.triggerTransition(d.value(ce), y.value(ce)));
    }
    function g() {
      a("update-flow-step");
    }
    const Z = (re, o = false) => {
      I(re, o), n.spaceConfirm && a("select-date");
    }, se = (re, o, E = 0) => {
      var ce;
      (ce = v.value[E]) == null || ce.toggleMonthPicker(re, o);
    }, R = (re, o, E = 0) => {
      var ce;
      (ce = v.value[E]) == null || ce.toggleYearPicker(re, o);
    }, ae = (re, o, E) => {
      var ce;
      (ce = ne.value) == null || ce.toggleTimePicker(re, o, E);
    }, l = (re, o) => {
      var E;
      if (!n.range) {
        const ce = i.value ? i.value : C, B = o ? new Date(o) : ce, Me = re ? startOfWeek(B, { weekStartsOn: 1 }) : endOfWeek(B, { weekStartsOn: 1 });
        I({
          value: Me,
          current: getMonth(B) === d.value(0),
          text: "",
          classData: {}
        }), (E = document.getElementById(Ha(Me))) == null || E.focus();
      }
    }, D = (re) => {
      var o;
      (o = v.value[0]) == null || o.handleMonthYearChange(re, true);
    }, ue = (re) => {
      k(0, { month: d.value(0), year: y.value(0) + (re ? 1 : -1), fromNav: true });
    }, M = (re, o) => {
      re === Ge.time && a(`time-picker-${o ? "open" : "close"}`), a("overlay-toggle", { open: o, overlay: re });
    }, he = (re) => {
      a("overlay-toggle", { open: false, overlay: re }), a("focus-menu");
    };
    return t({
      clearHoverDate: fe,
      presetDate: z,
      selectCurrentDate: q,
      toggleMonthPicker: se,
      toggleYearPicker: R,
      toggleTimePicker: ae,
      handleArrow: N,
      updateMonthYear: k,
      getSidebarProps: () => ({
        modelValue: i,
        month: d,
        year: y,
        time: _2,
        updateTime: ee,
        updateMonthYear: k,
        selectDate: I,
        presetDate: z
      }),
      changeMonth: D,
      changeYear: ue,
      selectWeekDate: l,
      setStartTime: S
    }), (re, o) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(ma, {
        "multi-calendars": unref(me).count,
        collapse: re.collapse,
        "is-mobile": re.isMobile
      }, {
        default: withCtx(({ instance: E, index: ce }) => [
          re.disableMonthYearSelect ? createCommentVNode("", true) : (openBlock(), createBlock(Fr, mergeProps({
            key: 0,
            ref: (B) => {
              B && (v.value[ce] = B);
            },
            months: unref(Sn)(re.formatLocale, re.locale, re.monthNameFormat),
            years: unref(qa)(re.yearRange, re.locale, re.reverseYears),
            month: unref(d)(E),
            year: unref(y)(E),
            instance: E
          }, re.$props, {
            onMount: o[0] || (o[0] = (B) => oe(unref(Rt).header)),
            onResetFlow: o[1] || (o[1] = (B) => re.$emit("reset-flow")),
            onUpdateMonthYear: (B) => unref(k)(E, B),
            onOverlayClosed: he,
            onOverlayOpened: o[2] || (o[2] = (B) => re.$emit("overlay-toggle", { open: true, overlay: B }))
          }), createSlots({ _: 2 }, [
            renderList(unref(W), (B, Me) => ({
              name: B,
              fn: withCtx((be) => [
                renderSlot(re.$slots, B, normalizeProps(guardReactiveProps(be)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          createVNode(jr, mergeProps({
            ref: (B) => {
              B && (L.value[ce] = B);
            },
            "mapped-dates": $.value(E),
            month: unref(d)(E),
            year: unref(y)(E),
            instance: E
          }, re.$props, {
            onSelectDate: (B) => unref(I)(B, E !== 1),
            onHandleSpace: (B) => Z(B, E !== 1),
            onSetHoverDate: o[3] || (o[3] = (B) => unref(O)(B)),
            onHandleScroll: (B) => unref(H)(B, E),
            onHandleSwipe: (B) => unref(f)(B, E),
            onMount: o[4] || (o[4] = (B) => oe(unref(Rt).calendar)),
            onResetFlow: o[5] || (o[5] = (B) => re.$emit("reset-flow")),
            onTooltipOpen: o[6] || (o[6] = (B) => re.$emit("tooltip-open", B)),
            onTooltipClose: o[7] || (o[7] = (B) => re.$emit("tooltip-close", B))
          }), createSlots({ _: 2 }, [
            renderList(unref(p), (B, Me) => ({
              name: B,
              fn: withCtx((be) => [
                renderSlot(re.$slots, B, normalizeProps(guardReactiveProps({ ...be })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]),
      re.enableTimePicker ? (openBlock(), createElementBlock("div", Gr, [
        re.$slots["time-picker"] ? renderSlot(re.$slots, "time-picker", normalizeProps(mergeProps({ key: 0 }, { time: unref(_2), updateTime: unref(ee) }))) : (openBlock(), createBlock(Vn, mergeProps({
          key: 1,
          ref_key: "timePickerRef",
          ref: ne
        }, re.$props, {
          hours: unref(_2).hours,
          minutes: unref(_2).minutes,
          seconds: unref(_2).seconds,
          "internal-model-value": re.internalModelValue,
          "disabled-times-config": unref(c),
          "validate-time": unref(m),
          onMount: o[8] || (o[8] = (E) => oe(unref(Rt).timePicker)),
          "onUpdate:hours": o[9] || (o[9] = (E) => unref(ee)(E)),
          "onUpdate:minutes": o[10] || (o[10] = (E) => unref(ee)(E, false)),
          "onUpdate:seconds": o[11] || (o[11] = (E) => unref(ee)(E, false, true)),
          onResetFlow: o[12] || (o[12] = (E) => re.$emit("reset-flow")),
          onOverlayClosed: o[13] || (o[13] = (E) => M(E, false)),
          onOverlayOpened: o[14] || (o[14] = (E) => M(E, true)),
          onAmPmChange: o[15] || (o[15] = (E) => re.$emit("am-pm-change", E))
        }), createSlots({ _: 2 }, [
          renderList(unref(T), (E, ce) => ({
            name: E,
            fn: withCtx((B) => [
              renderSlot(re.$slots, E, normalizeProps(guardReactiveProps(B)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : createCommentVNode("", true)
    ], 64));
  }
}), qr = (e, t) => {
  const r = ref(), {
    defaultedMultiCalendars: a,
    defaultedConfig: n,
    defaultedHighlight: u,
    defaultedRange: d,
    propDates: y,
    defaultedFilters: i,
    defaultedMultiDates: _2
  } = _e(e), { modelValue: c, year: C, month: m, calendars: P } = aa(e, t), { isDisabled: U } = Tt(e), { selectYear: N, groupedYears: H, showYearPicker: f, isDisabled: I, toggleYearPicker: k, handleYearSelect: z, handleYear: q } = Wn({
    modelValue: c,
    multiCalendars: a,
    range: d,
    highlight: u,
    calendars: P,
    propDates: y,
    month: m,
    year: C,
    filters: i,
    props: e,
    emit: t
  }), ee = (p, W) => [p, W].map((T) => format(T, "MMMM", { locale: e.formatLocale })).join("-"), x = computed(() => (p) => c.value ? Array.isArray(c.value) ? c.value.some((W) => isSameQuarter(p, W)) : isSameQuarter(c.value, p) : false), S = (p) => {
    if (d.value.enabled) {
      if (Array.isArray(c.value)) {
        const W = Ae(p, c.value[0]) || Ae(p, c.value[1]);
        return Jt(c.value, r.value, p) && !W;
      }
      return false;
    }
    return false;
  }, X = (p, W) => p.quarter === getQuarter(W) && p.year === getYear(W), O = (p) => typeof u.value == "function" ? u.value({ quarter: getQuarter(p), year: getYear(p) }) : !!u.value.quarters.find((W) => X(W, p)), K = computed(() => (p) => {
    const W = set(/* @__PURE__ */ new Date(), { year: C.value(p) });
    return eachQuarterOfInterval({
      start: startOfYear(W),
      end: endOfYear(W)
    }).map((T) => {
      const oe = startOfQuarter(T), $ = endOfQuarter(T), Y = U(T), g = S(oe), Z = O(oe);
      return {
        text: ee(oe, $),
        value: oe,
        active: x.value(oe),
        highlighted: Z,
        disabled: Y,
        isBetween: g
      };
    });
  }), fe = (p) => {
    xa(p, c, _2.value.limit), t("auto-apply", true);
  }, me = (p) => {
    c.value = en(c, p, t), pa(c.value, t, e.autoApply, e.modelAuto);
  }, v = (p) => {
    c.value = p, t("auto-apply");
  };
  return {
    defaultedConfig: n,
    defaultedMultiCalendars: a,
    groupedYears: H,
    year: C,
    isDisabled: I,
    quarters: K,
    showYearPicker: f,
    modelValue: c,
    setHoverDate: (p) => {
      r.value = p;
    },
    selectYear: N,
    selectQuarter: (p, W, T) => {
      if (!T)
        return P.value[W].month = getMonth(endOfQuarter(p)), _2.value.enabled ? fe(p) : d.value.enabled ? me(p) : v(p);
    },
    toggleYearPicker: k,
    handleYearSelect: z,
    handleYear: q
  };
}, Xr = { class: "dp--quarter-items" }, Jr = ["data-test-id", "disabled", "onClick", "onMouseover"], Zr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end",
    "overlay-toggle",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, u = useSlots(), d = tt(u, "yearMode"), {
      defaultedMultiCalendars: y,
      defaultedConfig: i,
      groupedYears: _2,
      year: c,
      isDisabled: C,
      quarters: m,
      modelValue: P,
      showYearPicker: U,
      setHoverDate: N,
      selectQuarter: H,
      toggleYearPicker: f,
      handleYearSelect: I,
      handleYear: k
    } = qr(n, a);
    return t({ getSidebarProps: () => ({
      modelValue: P,
      year: c,
      selectQuarter: H,
      handleYearSelect: I,
      handleYear: k
    }) }), (q, ee) => (openBlock(), createBlock(ma, {
      "multi-calendars": unref(y).count,
      collapse: q.collapse,
      stretch: "",
      "is-mobile": q.isMobile
    }, {
      default: withCtx(({ instance: x }) => [
        createBaseVNode("div", {
          class: "dp-quarter-picker-wrap",
          style: normalizeStyle({ minHeight: `${unref(i).modeHeight}px` })
        }, [
          q.$slots["top-extra"] ? renderSlot(q.$slots, "top-extra", {
            key: 0,
            value: q.internalModelValue
          }) : createCommentVNode("", true),
          createBaseVNode("div", null, [
            createVNode(zn, mergeProps(q.$props, {
              items: unref(_2)(x),
              instance: x,
              "show-year-picker": unref(U)[x],
              year: unref(c)(x),
              "is-disabled": (S) => unref(C)(x, S),
              onHandleYear: (S) => unref(k)(x, S),
              onYearSelect: (S) => unref(I)(S, x),
              onToggleYearPicker: (S) => unref(f)(x, S == null ? void 0 : S.flow, S == null ? void 0 : S.show)
            }), createSlots({ _: 2 }, [
              renderList(unref(d), (S, X) => ({
                name: S,
                fn: withCtx((O) => [
                  renderSlot(q.$slots, S, normalizeProps(guardReactiveProps(O)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          createBaseVNode("div", Xr, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(m)(x), (S, X) => (openBlock(), createElementBlock("div", { key: X }, [
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass(["dp--qr-btn", {
                  "dp--qr-btn-active": S.active,
                  "dp--qr-btn-between": S.isBetween,
                  "dp--qr-btn-disabled": S.disabled,
                  "dp--highlighted": S.highlighted
                }]),
                "data-test-id": S.value,
                disabled: S.disabled,
                onClick: (O) => unref(H)(S.value, x, S.disabled),
                onMouseover: (O) => unref(N)(S.value)
              }, [
                q.$slots.quarter ? renderSlot(q.$slots, "quarter", {
                  key: 0,
                  value: S.value,
                  text: S.text
                }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(S.text), 1)
                ], 64))
              ], 42, Jr)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), Kn = (e, t) => {
  const r = ref(0);
  onMounted(() => {
    a(), window.addEventListener("resize", a, { passive: true });
  }), onUnmounted(() => {
    window.removeEventListener("resize", a);
  });
  const a = () => {
    r.value = window.document.documentElement.clientWidth;
  };
  return {
    isMobile: computed(
      () => r.value <= e.value.mobileBreakpoint && !t ? true : void 0
    )
  };
}, xr = ["id", "tabindex", "role", "aria-label"], eo = {
  key: 0,
  class: "dp--menu-load-container"
}, to = {
  key: 1,
  class: "dp--menu-header"
}, ao = ["data-dp-mobile"], no = {
  key: 0,
  class: "dp__sidebar_left"
}, lo = ["data-dp-mobile"], ro = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"], oo = {
  key: 2,
  class: "dp__sidebar_right"
}, so = {
  key: 3,
  class: "dp__action_extra"
}, gn = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...va,
    shadow: { type: Boolean, default: false },
    openOnTop: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: false },
    collapse: { type: Boolean, default: false },
    getInputRect: { type: Function, default: () => ({}) },
    isTextInputDate: { type: Boolean, default: false }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "menu-blur"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, u = ref(null), d = computed(() => {
      const { openOnTop: b, ...F2 } = n;
      return {
        ...F2,
        isMobile: N.value,
        flowStep: K.value,
        menuWrapRef: u.value
      };
    }), { setMenuFocused: y, setShiftKey: i, control: _2 } = Ln(), c = useSlots(), { defaultedTextInput: C, defaultedInline: m, defaultedConfig: P, defaultedUI: U } = _e(n), { isMobile: N } = Kn(P, n.shadow), H = ref(null), f = ref(0), I = ref(null), k = ref(false), z = ref(null), q = ref(false);
    onMounted(() => {
      if (!n.shadow) {
        k.value = true, ee(), window.addEventListener("resize", ee);
        const b = Le(u);
        if (b && !C.value.enabled && !m.value.enabled && (y(true), W()), b) {
          const F2 = (Re2) => {
            q.value = true, P.value.allowPreventDefault && Re2.preventDefault(), Dt(Re2, P.value, true);
          };
          b.addEventListener("pointerdown", F2), b.addEventListener("mousedown", F2);
        }
      }
      document.addEventListener("mousedown", be);
    }), onUnmounted(() => {
      window.removeEventListener("resize", ee), document.addEventListener("mousedown", be);
    });
    const ee = () => {
      const b = Le(I);
      b && (f.value = b.getBoundingClientRect().width);
    }, { arrowRight: x, arrowLeft: S, arrowDown: X, arrowUp: O } = At(), { flowStep: K, updateFlowStep: fe, childMount: me, resetFlow: v, handleFlow: L } = vo(n, a, z), ne = computed(() => n.monthPicker ? yr : n.yearPicker ? hr : n.timePicker ? Br : n.quarterPicker ? Zr : Qr), p = computed(() => {
      var Re2;
      if (P.value.arrowLeft) return P.value.arrowLeft;
      const b = (Re2 = u.value) == null ? void 0 : Re2.getBoundingClientRect(), F2 = n.getInputRect();
      return (F2 == null ? void 0 : F2.width) < (f == null ? void 0 : f.value) && (F2 == null ? void 0 : F2.left) <= ((b == null ? void 0 : b.left) ?? 0) ? `${(F2 == null ? void 0 : F2.width) / 2}px` : (F2 == null ? void 0 : F2.right) >= ((b == null ? void 0 : b.right) ?? 0) && (F2 == null ? void 0 : F2.width) < (f == null ? void 0 : f.value) ? `${(f == null ? void 0 : f.value) - (F2 == null ? void 0 : F2.width) / 2}px` : "50%";
    }), W = () => {
      const b = Le(u);
      b && b.focus({ preventScroll: true });
    }, T = computed(() => {
      var b;
      return ((b = z.value) == null ? void 0 : b.getSidebarProps()) || {};
    }), oe = () => {
      n.openOnTop && a("recalculate-position");
    }, $ = tt(c, "action"), Y = computed(() => n.monthPicker || n.yearPicker ? tt(c, "monthYear") : n.timePicker ? tt(c, "timePicker") : tt(c, "shared")), g = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), Z = computed(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly,
      "dp-menu-loading": n.loading
    })), se = computed(
      () => ({
        dp__menu: true,
        dp__menu_index: !m.value.enabled,
        dp__relative: m.value.enabled,
        ...U.value.menu ?? {}
      })
    ), R = (b) => {
      Dt(b, P.value, true);
    }, ae = () => {
      n.escClose && a("close-picker");
    }, l = (b) => {
      if (n.arrowNavigation) {
        if (b === Je.up) return O();
        if (b === Je.down) return X();
        if (b === Je.left) return S();
        if (b === Je.right) return x();
      } else b === Je.left || b === Je.up ? pe("handleArrow", Je.left, 0, b === Je.up) : pe("handleArrow", Je.right, 0, b === Je.down);
    }, D = (b) => {
      i(b.shiftKey), !n.disableMonthYearSelect && b.code === Oe.tab && b.target.classList.contains("dp__menu") && _2.value.shiftKeyInMenu && (b.preventDefault(), Dt(b, P.value, true), a("close-picker"));
    }, ue = () => {
      W(), a("time-picker-close");
    }, M = (b) => {
      var F2, Re2, Fe;
      (F2 = z.value) == null || F2.toggleTimePicker(false, false), (Re2 = z.value) == null || Re2.toggleMonthPicker(false, false, b), (Fe = z.value) == null || Fe.toggleYearPicker(false, false, b);
    }, he = (b, F2 = 0) => {
      var Re2, Fe, mt;
      return b === "month" ? (Re2 = z.value) == null ? void 0 : Re2.toggleMonthPicker(false, true, F2) : b === "year" ? (Fe = z.value) == null ? void 0 : Fe.toggleYearPicker(false, true, F2) : b === "time" ? (mt = z.value) == null ? void 0 : mt.toggleTimePicker(true, false) : M(F2);
    }, pe = (b, ...F2) => {
      var Re2, Fe;
      (Re2 = z.value) != null && Re2[b] && ((Fe = z.value) == null || Fe[b](...F2));
    }, re = () => {
      pe("selectCurrentDate");
    }, o = (b, F2) => {
      pe("presetDate", toValue(b), F2);
    }, E = () => {
      pe("clearHoverDate");
    }, ce = (b, F2) => {
      pe("updateMonthYear", b, F2);
    }, B = (b, F2) => {
      b.preventDefault(), l(F2);
    }, Me = (b) => {
      var F2, Re2, Fe;
      if (D(b), b.key === Oe.home || b.key === Oe.end)
        return pe(
          "selectWeekDate",
          b.key === Oe.home,
          b.target.getAttribute("id")
        );
      switch ((b.key === Oe.pageUp || b.key === Oe.pageDown) && (b.shiftKey ? (pe("changeYear", b.key === Oe.pageUp), (F2 = La(u.value, "overlay-year")) == null || F2.focus()) : (pe("changeMonth", b.key === Oe.pageUp), (Re2 = La(u.value, b.key === Oe.pageUp ? "action-prev" : "action-next")) == null || Re2.focus()), b.target.getAttribute("id") && ((Fe = u.value) == null || Fe.focus({ preventScroll: true }))), b.key) {
        case Oe.esc:
          return ae();
        case Oe.arrowLeft:
          return B(b, Je.left);
        case Oe.arrowRight:
          return B(b, Je.right);
        case Oe.arrowUp:
          return B(b, Je.up);
        case Oe.arrowDown:
          return B(b, Je.down);
        default:
          return;
      }
    }, be = (b) => {
      var F2;
      m.value.enabled && !m.value.input && !((F2 = u.value) != null && F2.contains(b.target)) && q.value && (q.value = false, a("menu-blur"));
    };
    return t({
      updateMonthYear: ce,
      switchView: he,
      handleFlow: L,
      onValueCleared: () => {
        var b, F2;
        (F2 = (b = z.value) == null ? void 0 : b.setStartTime) == null || F2.call(b);
      }
    }), (b, F2) => {
      var Re2, Fe, mt;
      return openBlock(), createElementBlock("div", {
        id: b.uid ? `dp-menu-${b.uid}` : void 0,
        ref_key: "dpMenuRef",
        ref: u,
        tabindex: unref(m).enabled ? void 0 : "0",
        role: unref(m).enabled ? void 0 : "dialog",
        "aria-label": (Re2 = b.ariaLabels) == null ? void 0 : Re2.menu,
        class: normalizeClass(se.value),
        style: normalizeStyle({ "--dp-arrow-left": p.value }),
        onMouseleave: E,
        onClick: R,
        onKeydown: Me
      }, [
        (b.disabled || b.readonly) && unref(m).enabled || b.loading ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(Z.value)
        }, [
          b.loading ? (openBlock(), createElementBlock("div", eo, F2[19] || (F2[19] = [
            createBaseVNode("span", { class: "dp--menu-loader" }, null, -1)
          ]))) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        b.$slots["menu-header"] ? (openBlock(), createElementBlock("div", to, [
          renderSlot(b.$slots, "menu-header")
        ])) : createCommentVNode("", true),
        !unref(m).enabled && !b.teleportCenter ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(g.value)
        }, null, 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "innerMenuRef",
          ref: I,
          class: normalizeClass({
            dp__menu_content_wrapper: ((Fe = b.presetDates) == null ? void 0 : Fe.length) || !!b.$slots["left-sidebar"] || !!b.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e.collapse && (((mt = b.presetDates) == null ? void 0 : mt.length) || !!b.$slots["left-sidebar"] || !!b.$slots["right-sidebar"])
          }),
          "data-dp-mobile": unref(N),
          style: normalizeStyle({ "--dp-menu-width": `${f.value}px` })
        }, [
          b.$slots["left-sidebar"] ? (openBlock(), createElementBlock("div", no, [
            renderSlot(b.$slots, "left-sidebar", normalizeProps(guardReactiveProps(T.value)))
          ])) : createCommentVNode("", true),
          b.presetDates.length ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass({ "dp--preset-dates-collapsed": e.collapse, "dp--preset-dates": true }),
            "data-dp-mobile": unref(N)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(b.presetDates, (ve2, Ue) => (openBlock(), createElementBlock(Fragment, { key: Ue }, [
              ve2.slot ? renderSlot(b.$slots, ve2.slot, {
                key: 0,
                presetDate: o,
                label: ve2.label,
                value: ve2.value
              }) : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                style: normalizeStyle(ve2.style || {}),
                class: normalizeClass(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e.collapse }]),
                "data-test-id": ve2.testId ?? void 0,
                "data-dp-mobile": unref(N),
                onClick: withModifiers((lt) => o(ve2.value, ve2.noTz), ["prevent"]),
                onKeydown: (lt) => unref(Ze)(lt, () => o(ve2.value, ve2.noTz), true)
              }, toDisplayString(ve2.label), 47, ro))
            ], 64))), 128))
          ], 10, lo)) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref_key: "calendarWrapperRef",
            ref: H,
            class: "dp__instance_calendar",
            role: "document"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(ne.value), mergeProps({
              ref_key: "dynCmpRef",
              ref: z
            }, d.value, {
              "flow-step": unref(K),
              onMount: unref(me),
              onUpdateFlowStep: unref(fe),
              onResetFlow: unref(v),
              onFocusMenu: W,
              onSelectDate: F2[0] || (F2[0] = (ve2) => b.$emit("select-date")),
              onDateUpdate: F2[1] || (F2[1] = (ve2) => b.$emit("date-update", ve2)),
              onTooltipOpen: F2[2] || (F2[2] = (ve2) => b.$emit("tooltip-open", ve2)),
              onTooltipClose: F2[3] || (F2[3] = (ve2) => b.$emit("tooltip-close", ve2)),
              onAutoApply: F2[4] || (F2[4] = (ve2) => b.$emit("auto-apply", ve2)),
              onRangeStart: F2[5] || (F2[5] = (ve2) => b.$emit("range-start", ve2)),
              onRangeEnd: F2[6] || (F2[6] = (ve2) => b.$emit("range-end", ve2)),
              onInvalidFixedRange: F2[7] || (F2[7] = (ve2) => b.$emit("invalid-fixed-range", ve2)),
              onTimeUpdate: F2[8] || (F2[8] = (ve2) => b.$emit("time-update")),
              onAmPmChange: F2[9] || (F2[9] = (ve2) => b.$emit("am-pm-change", ve2)),
              onTimePickerOpen: F2[10] || (F2[10] = (ve2) => b.$emit("time-picker-open", ve2)),
              onTimePickerClose: ue,
              onRecalculatePosition: oe,
              onUpdateMonthYear: F2[11] || (F2[11] = (ve2) => b.$emit("update-month-year", ve2)),
              onAutoApplyInvalid: F2[12] || (F2[12] = (ve2) => b.$emit("auto-apply-invalid", ve2)),
              onInvalidDate: F2[13] || (F2[13] = (ve2) => b.$emit("invalid-date", ve2)),
              onOverlayToggle: F2[14] || (F2[14] = (ve2) => b.$emit("overlay-toggle", ve2)),
              "onUpdate:internalModelValue": F2[15] || (F2[15] = (ve2) => b.$emit("update:internal-model-value", ve2))
            }), createSlots({ _: 2 }, [
              renderList(Y.value, (ve2, Ue) => ({
                name: ve2,
                fn: withCtx((lt) => [
                  renderSlot(b.$slots, ve2, normalizeProps(guardReactiveProps({ ...lt })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          b.$slots["right-sidebar"] ? (openBlock(), createElementBlock("div", oo, [
            renderSlot(b.$slots, "right-sidebar", normalizeProps(guardReactiveProps(T.value)))
          ])) : createCommentVNode("", true),
          b.$slots["action-extra"] ? (openBlock(), createElementBlock("div", so, [
            b.$slots["action-extra"] ? renderSlot(b.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: re
            }) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ], 14, ao),
        !b.autoApply || unref(P).keepActionRow ? (openBlock(), createBlock(sr, mergeProps({
          key: 3,
          "menu-mount": k.value
        }, d.value, {
          "calendar-width": f.value,
          onClosePicker: F2[16] || (F2[16] = (ve2) => b.$emit("close-picker")),
          onSelectDate: F2[17] || (F2[17] = (ve2) => b.$emit("select-date")),
          onInvalidSelect: F2[18] || (F2[18] = (ve2) => b.$emit("invalid-select")),
          onSelectNow: re
        }), createSlots({ _: 2 }, [
          renderList(unref($), (ve2, Ue) => ({
            name: ve2,
            fn: withCtx((lt) => [
              renderSlot(b.$slots, ve2, normalizeProps(guardReactiveProps({ ...lt })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : createCommentVNode("", true)
      ], 46, xr);
    };
  }
});
var It = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(It || {});
const uo = ({
  menuRef: e,
  menuRefInner: t,
  inputRef: r,
  pickerWrapperRef: a,
  inline: n,
  emit: u,
  props: d,
  slots: y
}) => {
  const { defaultedConfig: i } = _e(d), _2 = ref({}), c = ref(false), C = ref({
    top: "0",
    left: "0"
  }), m = ref(false), P = toRef(d, "teleportCenter");
  watch(P, () => {
    C.value = JSON.parse(JSON.stringify({})), q();
  });
  const U = (p) => {
    if (d.teleport) {
      const W = p.getBoundingClientRect();
      return {
        left: W.left + window.scrollX,
        top: W.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, N = (p, W) => {
    C.value.left = `${p + W - _2.value.width}px`;
  }, H = (p) => {
    C.value.left = `${p}px`;
  }, f = (p, W) => {
    d.position === It.left && H(p), d.position === It.right && N(p, W), d.position === It.center && (C.value.left = `${p + W / 2 - _2.value.width / 2}px`);
  }, I = (p) => {
    const { width: W, height: T } = p.getBoundingClientRect(), { top: oe, left: $ } = U(p);
    return { top: +oe, left: +$, width: W, height: T };
  }, k = () => {
    C.value.left = "50%", C.value.top = "50%", C.value.transform = "translate(-50%, -50%)", C.value.position = "fixed", delete C.value.opacity;
  }, z = () => {
    const p = Le(r);
    C.value = d.altPosition(p);
  }, q = (p = true) => {
    var W;
    if (!n.value.enabled) {
      if (P.value) return k();
      if (d.altPosition !== null) return z();
      if (p) {
        const T = d.teleport ? (W = t.value) == null ? void 0 : W.$el : e.value;
        T && (_2.value = T.getBoundingClientRect()), u("recalculate-position");
      }
      return fe();
    }
  }, ee = ({ inputEl: p, left: W, width: T }) => {
    window.screen.width > 768 && !c.value && f(W, T), X(p);
  }, x = (p) => {
    const { top: W, left: T, height: oe, width: $ } = I(p);
    C.value.top = `${oe + W + +d.offset}px`, m.value = false, c.value || (C.value.left = `${T + $ / 2 - _2.value.width / 2}px`), ee({ inputEl: p, left: T, width: $ });
  }, S = (p) => {
    const { top: W, left: T, width: oe } = I(p);
    C.value.top = `${W - +d.offset - _2.value.height}px`, m.value = true, ee({ inputEl: p, left: T, width: oe });
  }, X = (p) => {
    if (d.autoPosition) {
      const { left: W, width: T } = I(p), { left: oe, right: $ } = _2.value;
      if (!c.value) {
        if (Math.abs(oe) !== Math.abs($)) {
          if (oe <= 0)
            return c.value = true, H(W);
          if ($ >= document.documentElement.clientWidth)
            return c.value = true, N(W, T);
        }
        return f(W, T);
      }
    }
  }, O = () => {
    const p = Le(r);
    if (p) {
      if (d.autoPosition === it.top) return it.top;
      if (d.autoPosition === it.bottom) return it.bottom;
      const { height: W } = _2.value, { top: T, height: oe } = p.getBoundingClientRect(), Y = window.innerHeight - T - oe, g = T;
      return W <= Y ? it.bottom : W > Y && W <= g ? it.top : Y >= g ? it.bottom : it.top;
    }
    return it.bottom;
  }, K = (p) => O() === it.bottom ? x(p) : S(p), fe = () => {
    const p = Le(r);
    if (p)
      return d.autoPosition ? K(p) : x(p);
  }, me = function(p) {
    if (p) {
      const W = p.scrollHeight > p.clientHeight, oe = window.getComputedStyle(p).overflowY.indexOf("hidden") !== -1;
      return W && !oe;
    }
    return true;
  }, v = function(p) {
    return !p || p === document.body || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : me(p) ? p : v(
      p.assignedSlot && i.value.shadowDom ? p.assignedSlot.parentNode : p.parentNode
    );
  }, L = (p) => {
    if (p)
      switch (d.position) {
        case It.left:
          return { left: 0, transform: "translateX(0)" };
        case It.right:
          return { left: `${p.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${p.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: m,
    menuStyle: C,
    xCorrect: c,
    setMenuPosition: q,
    getScrollableParent: v,
    shadowRender: (p, W) => {
      var se, R, ae;
      const T = document.createElement("div"), oe = (se = Le(r)) == null ? void 0 : se.getBoundingClientRect();
      T.setAttribute("id", "dp--temp-container");
      const $ = (R = a.value) != null && R.clientWidth ? a.value : document.body;
      $.append(T);
      const Y = L(oe), g = i.value.shadowDom ? Object.keys(y).filter(
        (l) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(l)
      ) : Object.keys(y), Z = h(
        p,
        {
          ...W,
          shadow: true,
          style: { opacity: 0, position: "absolute", ...Y }
        },
        Object.fromEntries(g.map((l) => [l, y[l]]))
      );
      render$7(Z, T), _2.value = (ae = Z.el) == null ? void 0 : ae.getBoundingClientRect(), render$7(null, T), $.removeChild(T);
    }
  };
}, bt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] },
  { name: "tp-inline-arrow-up", use: ["shared", "time"] },
  { name: "tp-inline-arrow-down", use: ["shared", "time"] },
  { name: "menu-header", use: ["menu"] }
], io = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], co = {
  all: () => bt,
  monthYear: () => bt.filter((e) => e.use.includes("month-year")),
  input: () => io,
  timePicker: () => bt.filter((e) => e.use.includes("time")),
  action: () => bt.filter((e) => e.use.includes("action")),
  calendar: () => bt.filter((e) => e.use.includes("calendar")),
  menu: () => bt.filter((e) => e.use.includes("menu")),
  shared: () => bt.filter((e) => e.use.includes("shared")),
  yearMode: () => bt.filter((e) => e.use.includes("year-mode"))
}, tt = (e, t, r) => {
  const a = [];
  return co[t]().forEach((n) => {
    e[n.name] && a.push(n.name);
  }), r != null && r.length && r.forEach((n) => {
    n.slot && a.push(n.slot);
  }), a;
}, ta = (e) => {
  const t = computed(() => (a) => e.value ? a ? e.value.open : e.value.close : ""), r = computed(() => (a) => e.value ? a ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: t, showTransition: !!e.value, menuTransition: r };
}, aa = (e, t, r) => {
  const { defaultedRange: a, defaultedTz: n } = _e(e), u = j(et(j(), n.value.timezone)), d = ref([{ month: getMonth(u), year: getYear(u) }]), y = (m) => {
    const P = {
      hours: getHours(u),
      minutes: getMinutes(u),
      seconds: 0
    };
    return a.value.enabled ? [P[m], P[m]] : P[m];
  }, i = reactive({
    hours: y("hours"),
    minutes: y("minutes"),
    seconds: y("seconds")
  });
  watch(
    a,
    (m, P) => {
      m.enabled !== P.enabled && (i.hours = y("hours"), i.minutes = y("minutes"), i.seconds = y("seconds"));
    },
    { deep: true }
  );
  const _2 = computed({
    get: () => e.internalModelValue,
    set: (m) => {
      !e.readonly && !e.disabled && t("update:internal-model-value", m);
    }
  }), c = computed(
    () => (m) => d.value[m] ? d.value[m].month : 0
  ), C = computed(
    () => (m) => d.value[m] ? d.value[m].year : 0
  );
  return watch(
    _2,
    (m, P) => {
      r && JSON.stringify(m ?? {}) !== JSON.stringify(P ?? {}) && r();
    },
    { deep: true }
  ), {
    calendars: d,
    time: i,
    modelValue: _2,
    month: c,
    year: C,
    today: u
  };
}, fo = (e, t) => {
  const {
    defaultedMultiCalendars: r,
    defaultedMultiDates: a,
    defaultedUI: n,
    defaultedHighlight: u,
    defaultedTz: d,
    propDates: y,
    defaultedRange: i
  } = _e(t), { isDisabled: _2 } = Tt(t), c = ref(null), C = ref(et(/* @__PURE__ */ new Date(), d.value.timezone)), m = (l) => {
    !l.current && t.hideOffsetDates || (c.value = l.value);
  }, P = () => {
    c.value = null;
  }, U = (l) => Array.isArray(e.value) && i.value.enabled && e.value[0] && c.value ? l ? Ee(c.value, e.value[0]) : Ye(c.value, e.value[0]) : true, N = (l, D) => {
    const ue = () => e.value ? D ? e.value[0] || null : e.value[1] : null, M = e.value && Array.isArray(e.value) ? ue() : null;
    return Ae(j(l.value), M);
  }, H = (l) => {
    const D = Array.isArray(e.value) ? e.value[0] : null;
    return l ? !Ye(c.value ?? null, D) : true;
  }, f = (l, D = true) => (i.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !l.current ? false : Ae(j(l.value), e.value[D ? 0 : 1]) : i.value.enabled ? N(l, D) && H(D) || Ae(l.value, Array.isArray(e.value) ? e.value[0] : null) && U(D) : false, I = (l, D) => {
    if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
      const ue = Ae(l.value, c.value);
      return D ? Ee(e.value[0], l.value) && ue : Ye(e.value[0], l.value) && ue;
    }
    return false;
  }, k = (l) => !e.value || t.hideOffsetDates && !l.current ? false : i.value.enabled ? t.modelAuto && Array.isArray(e.value) ? Ae(l.value, e.value[0] ? e.value[0] : C.value) : false : a.value.enabled && Array.isArray(e.value) ? e.value.some((D) => Ae(D, l.value)) : Ae(l.value, e.value ? e.value : C.value), z = (l) => {
    if (i.value.autoRange || t.weekPicker) {
      if (c.value) {
        if (t.hideOffsetDates && !l.current) return false;
        const D = addDays(c.value, +i.value.autoRange), ue = pt(j(c.value), t.weekStart);
        return t.weekPicker ? Ae(ue[1], j(l.value)) : Ae(D, j(l.value));
      }
      return false;
    }
    return false;
  }, q = (l) => {
    if (i.value.autoRange || t.weekPicker) {
      if (c.value) {
        const D = addDays(c.value, +i.value.autoRange);
        if (t.hideOffsetDates && !l.current) return false;
        const ue = pt(j(c.value), t.weekStart);
        return t.weekPicker ? Ee(l.value, ue[0]) && Ye(l.value, ue[1]) : Ee(l.value, c.value) && Ye(l.value, D);
      }
      return false;
    }
    return false;
  }, ee = (l) => {
    if (i.value.autoRange || t.weekPicker) {
      if (c.value) {
        if (t.hideOffsetDates && !l.current) return false;
        const D = pt(j(c.value), t.weekStart);
        return t.weekPicker ? Ae(D[0], l.value) : Ae(c.value, l.value);
      }
      return false;
    }
    return false;
  }, x = (l) => Jt(e.value, c.value, l.value), S = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : false, X = () => t.modelAuto ? Pn(t.internalModelValue) : true, O = (l) => {
    if (t.weekPicker) return false;
    const D = i.value.enabled ? !f(l) && !f(l, false) : true;
    return !_2(l.value) && !k(l) && !(!l.current && t.hideOffsetDates) && D;
  }, K = (l) => i.value.enabled ? t.modelAuto ? S() && k(l) : false : k(l), fe = (l) => u.value ? Rl(l.value, y.value.highlight) : false, me = (l) => {
    const D = _2(l.value);
    return D && (typeof u.value == "function" ? !u.value(l.value, D) : !u.value.options.highlightDisabled);
  }, v = (l) => {
    var D;
    return typeof u.value == "function" ? u.value(l.value) : (D = u.value.weekdays) == null ? void 0 : D.includes(l.value.getDay());
  }, L = (l) => (i.value.enabled || t.weekPicker) && (!(r.value.count > 0) || l.current) && X() && !(!l.current && t.hideOffsetDates) && !k(l) ? x(l) : false, ne = (l) => {
    if (Array.isArray(e.value) && e.value.length === 1) {
      const { before: D, after: ue } = vn(+i.value.maxRange, e.value[0]);
      return isBefore(l.value, D) || isAfter(l.value, ue);
    }
    return false;
  }, p = (l) => {
    if (Array.isArray(e.value) && e.value.length === 1) {
      const { before: D, after: ue } = vn(+i.value.minRange, e.value[0]);
      return Jt([D, ue], e.value[0], l.value);
    }
    return false;
  }, W = (l) => i.value.enabled && (i.value.maxRange || i.value.minRange) ? i.value.maxRange && i.value.minRange ? ne(l) || p(l) : i.value.maxRange ? ne(l) : p(l) : false, T = (l) => {
    const { isRangeStart: D, isRangeEnd: ue } = g(l), M = i.value.enabled ? D || ue : false;
    return {
      dp__cell_offset: !l.current,
      dp__pointer: !t.disabled && !(!l.current && t.hideOffsetDates) && !_2(l.value) && !W(l),
      dp__cell_disabled: _2(l.value) || W(l),
      dp__cell_highlight: !me(l) && (fe(l) || v(l)) && !K(l) && !M && !ee(l) && !(L(l) && t.weekPicker) && !ue,
      dp__cell_highlight_active: !me(l) && (fe(l) || v(l)) && K(l),
      dp__today: !t.noToday && Ae(l.value, C.value) && l.current,
      "dp--past": Ye(l.value, C.value),
      "dp--future": Ee(l.value, C.value)
    };
  }, oe = (l) => ({
    dp__active_date: K(l),
    dp__date_hover: O(l)
  }), $ = (l) => {
    if (e.value && !Array.isArray(e.value)) {
      const D = pt(e.value, t.weekStart);
      return {
        ...se(l),
        dp__range_start: Ae(D[0], l.value),
        dp__range_end: Ae(D[1], l.value),
        dp__range_between_week: Ee(l.value, D[0]) && Ye(l.value, D[1])
      };
    }
    return {
      ...se(l)
    };
  }, Y = (l) => {
    if (e.value && Array.isArray(e.value)) {
      const D = pt(e.value[0], t.weekStart), ue = e.value[1] ? pt(e.value[1], t.weekStart) : [];
      return {
        ...se(l),
        dp__range_start: Ae(D[0], l.value) || Ae(ue[0], l.value),
        dp__range_end: Ae(D[1], l.value) || Ae(ue[1], l.value),
        dp__range_between_week: Ee(l.value, D[0]) && Ye(l.value, D[1]) || Ee(l.value, ue[0]) && Ye(l.value, ue[1]),
        dp__range_between: Ee(l.value, D[1]) && Ye(l.value, ue[0])
      };
    }
    return {
      ...se(l)
    };
  }, g = (l) => {
    const D = r.value.count > 0 ? l.current && f(l) && X() : f(l) && X(), ue = r.value.count > 0 ? l.current && f(l, false) && X() : f(l, false) && X();
    return { isRangeStart: D, isRangeEnd: ue };
  }, Z = (l) => {
    const { isRangeStart: D, isRangeEnd: ue } = g(l);
    return {
      dp__range_start: D,
      dp__range_end: ue,
      dp__range_between: L(l),
      dp__date_hover: Ae(l.value, c.value) && !D && !ue && !t.weekPicker,
      dp__date_hover_start: I(l, true),
      dp__date_hover_end: I(l, false)
    };
  }, se = (l) => ({
    ...Z(l),
    dp__cell_auto_range: q(l),
    dp__cell_auto_range_start: ee(l),
    dp__cell_auto_range_end: z(l)
  }), R = (l) => i.value.enabled ? i.value.autoRange ? se(l) : t.modelAuto ? { ...oe(l), ...Z(l) } : t.weekPicker ? Y(l) : Z(l) : t.weekPicker ? $(l) : oe(l);
  return {
    setHoverDate: m,
    clearHoverDate: P,
    getDayClassData: (l) => t.hideOffsetDates && !l.current ? {} : {
      ...T(l),
      ...R(l),
      [t.dayClass ? t.dayClass(l.value, t.internalModelValue) : ""]: true,
      ...n.value.calendarCell ?? {}
    }
  };
}, Tt = (e) => {
  const { defaultedFilters: t, defaultedRange: r, propDates: a, defaultedMultiDates: n } = _e(e), u = (v) => a.value.disabledDates ? typeof a.value.disabledDates == "function" ? a.value.disabledDates(j(v)) : !!ca(v, a.value.disabledDates) : false, d = (v) => a.value.maxDate ? e.yearPicker ? getYear(v) > getYear(a.value.maxDate) : Ee(v, a.value.maxDate) : false, y = (v) => a.value.minDate ? e.yearPicker ? getYear(v) < getYear(a.value.minDate) : Ye(v, a.value.minDate) : false, i = (v) => {
    const L = d(v), ne = y(v), p = u(v), T = t.value.months.map((Z) => +Z).includes(getMonth(v)), oe = e.disabledWeekDays.length ? e.disabledWeekDays.some((Z) => +Z === getDay(v)) : false, $ = P(v), Y = getYear(v), g = Y < +e.yearRange[0] || Y > +e.yearRange[1];
    return !(L || ne || p || T || g || oe || $);
  }, _2 = (v, L) => Ye(...wt(a.value.minDate, v, L)) || Ae(...wt(a.value.minDate, v, L)), c = (v, L) => Ee(...wt(a.value.maxDate, v, L)) || Ae(...wt(a.value.maxDate, v, L)), C = (v, L, ne) => {
    let p = false;
    return a.value.maxDate && ne && c(v, L) && (p = true), a.value.minDate && !ne && _2(v, L) && (p = true), p;
  }, m = (v, L, ne, p) => {
    let W = false;
    return p && (a.value.minDate || a.value.maxDate) ? a.value.minDate && a.value.maxDate ? W = C(v, L, ne) : (a.value.minDate && _2(v, L) || a.value.maxDate && c(v, L)) && (W = true) : W = true, W;
  }, P = (v) => Array.isArray(a.value.allowedDates) && !a.value.allowedDates.length ? true : a.value.allowedDates ? !ca(v, a.value.allowedDates) : false, U = (v) => !i(v), N = (v) => r.value.noDisabledRange ? !eachDayOfInterval({ start: v[0], end: v[1] }).some((ne) => U(ne)) : true, H = (v) => {
    if (v) {
      const L = getYear(v);
      return L >= +e.yearRange[0] && L <= e.yearRange[1];
    }
    return true;
  }, f = (v, L) => !!(Array.isArray(v) && v[L] && (r.value.maxRange || r.value.minRange) && H(v[L])), I = (v, L, ne = 0) => {
    if (f(L, ne) && H(v)) {
      const p = differenceInCalendarDays(v, L[ne]), W = Yn(L[ne], v), T = W.length === 1 ? 0 : W.filter(($) => U($)).length, oe = Math.abs(p) - (r.value.minMaxRawRange ? 0 : T);
      if (r.value.minRange && r.value.maxRange)
        return oe >= +r.value.minRange && oe <= +r.value.maxRange;
      if (r.value.minRange) return oe >= +r.value.minRange;
      if (r.value.maxRange) return oe <= +r.value.maxRange;
    }
    return true;
  }, k = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, z = (v) => Array.isArray(v) ? [v[0] ? Ca(v[0]) : null, v[1] ? Ca(v[1]) : null] : Ca(v), q = (v, L, ne) => v.find(
    (p) => +p.hours === getHours(L) && p.minutes === "*" ? true : +p.minutes === getMinutes(L) && +p.hours === getHours(L)
  ) && ne, ee = (v, L, ne) => {
    const [p, W] = v, [T, oe] = L;
    return !q(p, T, ne) && !q(W, oe, ne) && ne;
  }, x = (v, L) => {
    const ne = Array.isArray(L) ? L : [L];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? ee(e.disabledTimes, ne, v) : !ne.some((p) => q(e.disabledTimes, p, v)) : v;
  }, S = (v, L) => {
    const ne = Array.isArray(L) ? [Ct(L[0]), L[1] ? Ct(L[1]) : void 0] : Ct(L), p = !e.disabledTimes(ne);
    return v && p;
  }, X = (v, L) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? x(L, v) : S(L, v) : L, O = (v) => {
    let L = true;
    if (!v || k()) return true;
    const ne = !a.value.minDate && !a.value.maxDate ? z(v) : v;
    return (e.maxTime || a.value.maxDate) && (L = fn(
      e.maxTime,
      a.value.maxDate,
      "max",
      Ne(ne),
      L
    )), (e.minTime || a.value.minDate) && (L = fn(
      e.minTime,
      a.value.minDate,
      "min",
      Ne(ne),
      L
    )), X(v, L);
  }, K = (v) => {
    if (!e.monthPicker) return true;
    let L = true;
    const ne = j(dt(v));
    if (a.value.minDate && a.value.maxDate) {
      const p = j(dt(a.value.minDate)), W = j(dt(a.value.maxDate));
      return Ee(ne, p) && Ye(ne, W) || Ae(ne, p) || Ae(ne, W);
    }
    if (a.value.minDate) {
      const p = j(dt(a.value.minDate));
      L = Ee(ne, p) || Ae(ne, p);
    }
    if (a.value.maxDate) {
      const p = j(dt(a.value.maxDate));
      L = Ye(ne, p) || Ae(ne, p);
    }
    return L;
  }, fe = computed(() => (v) => !e.enableTimePicker || e.ignoreTimeValidation ? true : O(v)), me = computed(() => (v) => e.monthPicker ? Array.isArray(v) && (r.value.enabled || n.value.enabled) ? !v.filter((ne) => !K(ne)).length : K(v) : true);
  return {
    isDisabled: U,
    validateDate: i,
    validateMonthYearInRange: m,
    isDateRangeAllowed: N,
    checkMinMaxRange: I,
    isValidTime: O,
    isTimeValid: fe,
    isMonthValid: me
  };
}, ya = () => {
  const e = computed(() => (a, n) => a == null ? void 0 : a.includes(n)), t = computed(() => (a, n) => a.count ? a.solo ? true : n === 0 : true), r = computed(() => (a, n) => a.count ? a.solo ? true : n === a.count - 1 : true);
  return { hideNavigationButtons: e, showLeftIcon: t, showRightIcon: r };
}, vo = (e, t, r) => {
  const a = ref(0), n = reactive({
    [Rt.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [Rt.calendar]: false,
    [Rt.header]: false
  }), u = computed(() => e.monthPicker || e.timePicker), d = (C) => {
    var m;
    if ((m = e.flow) != null && m.length) {
      if (!C && u.value) return c();
      n[C] = true, Object.keys(n).filter((P) => !n[P]).length || c();
    }
  }, y = () => {
    var C, m;
    (C = e.flow) != null && C.length && a.value !== -1 && (a.value += 1, t("flow-step", a.value), c()), ((m = e.flow) == null ? void 0 : m.length) === a.value && nextTick().then(() => i());
  }, i = () => {
    a.value = -1;
  }, _2 = (C, m, ...P) => {
    var U, N;
    e.flow[a.value] === C && r.value && ((N = (U = r.value)[m]) == null || N.call(U, ...P));
  }, c = (C = 0) => {
    C && (a.value += C), _2(Ge.month, "toggleMonthPicker", true), _2(Ge.year, "toggleYearPicker", true), _2(Ge.calendar, "toggleTimePicker", false, true), _2(Ge.time, "toggleTimePicker", true, true);
    const m = e.flow[a.value];
    (m === Ge.hours || m === Ge.minutes || m === Ge.seconds) && _2(m, "toggleTimePicker", true, true, m);
  };
  return { childMount: d, updateFlowStep: y, resetFlow: i, handleFlow: c, flowStep: a };
}, mo = {
  key: 1,
  class: "dp__input_wrap"
}, po = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"], yo = {
  key: 2,
  class: "dp--clear-btn"
}, go = ["aria-label"], ho = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: false },
    inputValue: { type: String, default: "" },
    ...va
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur",
    "text-input"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, {
      defaultedTextInput: u,
      defaultedAriaLabels: d,
      defaultedInline: y,
      defaultedConfig: i,
      defaultedRange: _2,
      defaultedMultiDates: c,
      defaultedUI: C,
      getDefaultPattern: m,
      getDefaultStartTime: P
    } = _e(n), { checkMinMaxRange: U } = Tt(n), N = ref(), H = ref(null), f = ref(false), I = ref(false), k = computed(
      () => ({
        dp__pointer: !n.disabled && !n.readonly && !u.value.enabled,
        dp__disabled: n.disabled,
        dp__input_readonly: !u.value.enabled,
        dp__input: true,
        dp__input_icon_pad: !n.hideInputIcon,
        dp__input_valid: typeof n.state == "boolean" ? n.state : false,
        dp__input_invalid: typeof n.state == "boolean" ? !n.state : false,
        dp__input_focus: f.value || n.isMenuOpen,
        dp__input_reg: !u.value.enabled,
        ...C.value.input ?? {}
      })
    ), z = () => {
      a("set-input-date", null), n.clearable && n.autoApply && (a("set-empty-date"), N.value = null);
    }, q = ($) => {
      const Y = P();
      return Bl(
        $,
        u.value.format ?? m(),
        Y ?? In({}, n.enableSeconds),
        n.inputValue,
        I.value,
        n.formatLocale
      );
    }, ee = ($) => {
      const { rangeSeparator: Y } = u.value, [g, Z] = $.split(`${Y}`);
      if (g) {
        const se = q(g.trim()), R = Z ? q(Z.trim()) : null;
        if (isAfter(se, R)) return;
        const ae = se && R ? [se, R] : [se];
        U(R, ae, 0) && (N.value = se ? ae : null);
      }
    }, x = () => {
      I.value = true;
    }, S = ($) => {
      if (_2.value.enabled)
        ee($);
      else if (c.value.enabled) {
        const Y = $.split(";");
        N.value = Y.map((g) => q(g.trim())).filter((g) => g);
      } else
        N.value = q($);
    }, X = ($) => {
      var g;
      const Y = typeof $ == "string" ? $ : (g = $.target) == null ? void 0 : g.value;
      Y !== "" ? (u.value.openMenu && !n.isMenuOpen && a("open"), S(Y), a("set-input-date", N.value)) : z(), I.value = false, a("update:input-value", Y), a("text-input", $, N.value);
    }, O = ($) => {
      u.value.enabled ? (S($.target.value), u.value.enterSubmit && za(N.value) && n.inputValue !== "" ? (a("set-input-date", N.value, true), N.value = null) : u.value.enterSubmit && n.inputValue === "" && (N.value = null, a("clear"))) : me($);
    }, K = ($, Y) => {
      u.value.enabled && u.value.tabSubmit && !Y && S($.target.value), u.value.tabSubmit && za(N.value) && n.inputValue !== "" ? (a("set-input-date", N.value, true, true), N.value = null) : u.value.tabSubmit && n.inputValue === "" && (N.value = null, a("clear", true));
    }, fe = () => {
      f.value = true, a("focus"), nextTick().then(() => {
        var $;
        u.value.enabled && u.value.selectOnFocus && (($ = H.value) == null || $.select());
      });
    }, me = ($) => {
      if (Dt($, i.value, true), u.value.enabled && u.value.openMenu && !y.value.input) {
        if (u.value.openMenu === "open" && !n.isMenuOpen) return a("open");
        if (u.value.openMenu === "toggle") return a("toggle");
      } else u.value.enabled || a("toggle");
    }, v = () => {
      a("real-blur"), f.value = false, (!n.isMenuOpen || y.value.enabled && y.value.input) && a("blur"), n.autoApply && u.value.enabled && N.value && !n.isMenuOpen && (a("set-input-date", N.value), a("select-date"), N.value = null);
    }, L = ($) => {
      Dt($, i.value, true), a("clear");
    }, ne = () => {
      a("close");
    }, p = ($) => {
      if ($.key === "Tab" && K($), $.key === "Enter" && O($), $.key === "Escape" && u.value.escClose && ne(), !u.value.enabled) {
        if ($.code === "Tab") return;
        $.preventDefault();
      }
    }, W = () => {
      var $;
      ($ = H.value) == null || $.focus({ preventScroll: true });
    }, T = ($) => {
      N.value = $;
    }, oe = ($) => {
      $.key === Oe.tab && K($, true);
    };
    return t({
      focusInput: W,
      setParsedDate: T
    }), ($, Y) => {
      var g, Z, se;
      return openBlock(), createElementBlock("div", { onClick: me }, [
        $.$slots.trigger && !$.$slots["dp-input"] && !unref(y).enabled ? renderSlot($.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
        !$.$slots.trigger && (!unref(y).enabled || unref(y).input) ? (openBlock(), createElementBlock("div", mo, [
          $.$slots["dp-input"] && !$.$slots.trigger && (!unref(y).enabled || unref(y).enabled && unref(y).input) ? renderSlot($.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: X,
            onEnter: O,
            onTab: K,
            onClear: L,
            onBlur: v,
            onKeypress: p,
            onPaste: x,
            onFocus: fe,
            openMenu: () => $.$emit("open"),
            closeMenu: () => $.$emit("close"),
            toggleMenu: () => $.$emit("toggle")
          }) : createCommentVNode("", true),
          $.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
            key: 1,
            id: $.uid ? `dp-input-${$.uid}` : void 0,
            ref_key: "inputRef",
            ref: H,
            "data-test-id": "dp-input",
            name: $.name,
            class: normalizeClass(k.value),
            inputmode: unref(u).enabled ? "text" : "none",
            placeholder: $.placeholder,
            disabled: $.disabled,
            readonly: $.readonly,
            required: $.required,
            value: e.inputValue,
            autocomplete: $.autocomplete,
            "aria-label": (g = unref(d)) == null ? void 0 : g.input,
            "aria-disabled": $.disabled || void 0,
            "aria-invalid": $.state === false ? true : void 0,
            onInput: X,
            onBlur: v,
            onFocus: fe,
            onKeypress: p,
            onKeydown: Y[0] || (Y[0] = (R) => p(R)),
            onPaste: x
          }, null, 42, po)),
          createBaseVNode("div", {
            onClick: Y[3] || (Y[3] = (R) => a("toggle"))
          }, [
            $.$slots["input-icon"] && !$.hideInputIcon ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: Y[1] || (Y[1] = (R) => a("toggle"))
            }, [
              renderSlot($.$slots, "input-icon")
            ])) : createCommentVNode("", true),
            !$.$slots["input-icon"] && !$.hideInputIcon && !$.$slots["dp-input"] ? (openBlock(), createBlock(unref(Wt), {
              key: 1,
              "aria-label": (Z = unref(d)) == null ? void 0 : Z.calendarIcon,
              class: "dp__input_icon dp__input_icons",
              onClick: Y[2] || (Y[2] = (R) => a("toggle"))
            }, null, 8, ["aria-label"])) : createCommentVNode("", true)
          ]),
          $.$slots["clear-icon"] && ($.alwaysClearable || e.inputValue && $.clearable && !$.disabled && !$.readonly) ? (openBlock(), createElementBlock("span", yo, [
            renderSlot($.$slots, "clear-icon", { clear: L })
          ])) : createCommentVNode("", true),
          !$.$slots["clear-icon"] && ($.alwaysClearable || $.clearable && e.inputValue && !$.disabled && !$.readonly) ? (openBlock(), createElementBlock("button", {
            key: 3,
            "aria-label": (se = unref(d)) == null ? void 0 : se.clearInput,
            class: "dp--clear-btn",
            type: "button",
            onKeydown: Y[4] || (Y[4] = (R) => unref(Ze)(R, () => L(R), true, oe)),
            onClick: Y[5] || (Y[5] = withModifiers((R) => L(R), ["prevent"]))
          }, [
            createVNode(unref(Tn), {
              class: "dp__input_icons",
              "data-test-id": "clear-icon"
            })
          ], 40, go)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
}), bo = typeof window < "u" ? window : void 0, Ea = () => {
}, ko = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false, wo = (e, t, r, a) => {
  if (!e) return Ea;
  let n = Ea;
  const u = watch(
    () => unref(e),
    (y) => {
      n(), y && (y.addEventListener(t, r, a), n = () => {
        y.removeEventListener(t, r, a), n = Ea;
      });
    },
    { immediate: true, flush: "post" }
  ), d = () => {
    u(), n();
  };
  return ko(d), d;
}, Do = (e, t, r, a = {}) => {
  const { window: n = bo, event: u = "pointerdown" } = a;
  return n ? wo(n, u, (y) => {
    const i = Le(e), _2 = Le(t);
    !i || !_2 || i === y.target || y.composedPath().includes(i) || y.composedPath().includes(_2) || r(y);
  }, { passive: true }) : void 0;
}, Mo = ["data-dp-mobile"], $o = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...va
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "text-input"
  ],
  setup(e, { expose: t, emit: r }) {
    const a = r, n = e, u = useSlots(), d = ref(false), y = toRef(n, "modelValue"), i = toRef(n, "timezone"), _2 = ref(null), c = ref(null), C = ref(null), m = ref(false), P = ref(null), U = ref(false), N = ref(false), H = ref(false), f = ref(false), { setMenuFocused: I, setShiftKey: k } = Ln(), { clearArrowNav: z } = At(), { validateDate: q, isValidTime: ee } = Tt(n), {
      defaultedTransitions: x,
      defaultedTextInput: S,
      defaultedInline: X,
      defaultedConfig: O,
      defaultedRange: K,
      defaultedMultiDates: fe
    } = _e(n), { menuTransition: me, showTransition: v } = ta(x), { isMobile: L } = Kn(O);
    onMounted(() => {
      R(n.modelValue), nextTick().then(() => {
        if (!X.value.enabled) {
          const w = Y(P.value);
          w == null || w.addEventListener("scroll", E), window == null || window.addEventListener("resize", ce);
        }
      }), X.value.enabled && (d.value = true), window == null || window.addEventListener("keyup", B), window == null || window.addEventListener("keydown", Me);
    }), onUnmounted(() => {
      if (!X.value.enabled) {
        const w = Y(P.value);
        w == null || w.removeEventListener("scroll", E), window == null || window.removeEventListener("resize", ce);
      }
      window == null || window.removeEventListener("keyup", B), window == null || window.removeEventListener("keydown", Me);
    });
    const ne = tt(u, "all", n.presetDates), p = tt(u, "input");
    watch(
      [y, i],
      () => {
        R(y.value);
      },
      { deep: true }
    );
    const { openOnTop: W, menuStyle: T, xCorrect: oe, setMenuPosition: $, getScrollableParent: Y, shadowRender: g } = uo({
      menuRef: _2,
      menuRefInner: c,
      inputRef: C,
      pickerWrapperRef: P,
      inline: X,
      emit: a,
      props: n,
      slots: u
    }), {
      inputValue: Z,
      internalModelValue: se,
      parseExternalModelValue: R,
      emitModelValue: ae,
      formatInputValue: l,
      checkBeforeEmit: D
    } = nr(a, n, m), ue = computed(
      () => ({
        dp__main: true,
        dp__theme_dark: n.dark,
        dp__theme_light: !n.dark,
        dp__flex_display: X.value.enabled,
        "dp--flex-display-collapsed": H.value,
        dp__flex_display_with_input: X.value.input
      })
    ), M = computed(() => n.dark ? "dp__theme_dark" : "dp__theme_light"), he = computed(() => n.teleport ? {
      to: typeof n.teleport == "boolean" ? "body" : n.teleport,
      disabled: !n.teleport || X.value.enabled
    } : {}), pe = computed(() => ({ class: "dp__outer_menu_wrap" })), re = computed(() => X.value.enabled && (n.timePicker || n.monthPicker || n.yearPicker || n.quarterPicker)), o = () => {
      var w, G;
      return ((G = (w = C.value) == null ? void 0 : w.$el) == null ? void 0 : G.getBoundingClientRect()) ?? { width: 0, left: 0, right: 0 };
    }, E = () => {
      d.value && (O.value.closeOnScroll ? Ue() : $());
    }, ce = () => {
      var G;
      d.value && $();
      const w = ((G = c.value) == null ? void 0 : G.$el.getBoundingClientRect().width) ?? 0;
      H.value = document.body.offsetWidth <= w;
    }, B = (w) => {
      w.key === "Tab" && !X.value.enabled && !n.teleport && O.value.tabOutClosesMenu && (P.value.contains(document.activeElement) || Ue()), N.value = w.shiftKey;
    }, Me = (w) => {
      N.value = w.shiftKey;
    }, be = () => {
      !n.disabled && !n.readonly && (g(gn, n), $(false), d.value = true, d.value && a("open"), d.value || ve2(), R(n.modelValue));
    }, Se = () => {
      var w, G;
      Z.value = "", ve2(), (w = c.value) == null || w.onValueCleared(), (G = C.value) == null || G.setParsedDate(null), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), O.value.closeOnClearValue && Ue();
    }, b = () => {
      const w = se.value;
      return !w || !Array.isArray(w) && q(w) ? true : Array.isArray(w) ? fe.value.enabled || w.length === 2 && q(w[0]) && q(w[1]) ? true : K.value.partialRange && !n.timePicker ? q(w[0]) : false : false;
    }, F2 = () => {
      D() && b() ? (ae(), Ue()) : a("invalid-select", se.value);
    }, Re2 = (w) => {
      Fe(), ae(), O.value.closeOnAutoApply && !w && Ue();
    }, Fe = () => {
      C.value && S.value.enabled && C.value.setParsedDate(se.value);
    }, mt = (w = false) => {
      n.autoApply && ee(se.value) && b() && (K.value.enabled && Array.isArray(se.value) ? (K.value.partialRange || se.value.length === 2) && Re2(w) : Re2(w));
    }, ve2 = () => {
      S.value.enabled || (se.value = null);
    }, Ue = (w = false) => {
      w && se.value && O.value.setDateOnMenuClose && F2(), X.value.enabled || (d.value && (d.value = false, oe.value = false, I(false), k(false), z(), a("closed"), Z.value && R(y.value)), ve2(), a("blur"));
    }, lt = (w, G, ie = false) => {
      if (!w) {
        se.value = null;
        return;
      }
      const Xe = Array.isArray(w) ? !w.some((_t) => !q(_t)) : q(w), st = ee(w);
      Xe && st ? (f.value = true, se.value = w, G && (U.value = ie, F2(), a("text-submit")), nextTick().then(() => {
        f.value = false;
      })) : a("invalid-date", w);
    }, ga = () => {
      n.autoApply && ee(se.value) && ae(), Fe();
    }, na = () => d.value ? Ue() : be(), ha = (w) => {
      se.value = w;
    }, ba = () => {
      S.value.enabled && (m.value = true, l()), a("focus");
    }, ka = () => {
      if (S.value.enabled && (m.value = false, R(n.modelValue), U.value)) {
        const w = Pl(P.value, N.value);
        w == null || w.focus();
      }
      a("blur");
    }, wa = (w) => {
      c.value && c.value.updateMonthYear(0, {
        month: un(w.month),
        year: un(w.year)
      });
    }, Da = (w) => {
      R(w ?? n.modelValue);
    }, Ma = (w, G) => {
      var ie;
      (ie = c.value) == null || ie.switchView(w, G);
    }, tn = (w, G) => O.value.onClickOutside ? O.value.onClickOutside(w, G) : Ue(true), h2 = (w = 0) => {
      var G;
      (G = c.value) == null || G.handleFlow(w);
    }, le = () => _2;
    return Do(
      _2,
      C,
      (w) => tn(b, w)
    ), t({
      closeMenu: Ue,
      selectDate: F2,
      clearValue: Se,
      openMenu: be,
      onScroll: E,
      formatInputValue: l,
      // exposed for testing purposes
      updateInternalModelValue: ha,
      // modify internal modelValue
      setMonthYear: wa,
      parseModel: Da,
      switchView: Ma,
      toggleMenu: na,
      handleFlow: h2,
      getDpWrapMenuRef: le
    }), (w, G) => (openBlock(), createElementBlock("div", {
      ref_key: "pickerWrapperRef",
      ref: P,
      class: normalizeClass(ue.value),
      "data-datepicker-instance": "",
      "data-dp-mobile": unref(L)
    }, [
      createVNode(ho, mergeProps({
        ref_key: "inputRef",
        ref: C,
        "input-value": unref(Z),
        "onUpdate:inputValue": G[0] || (G[0] = (ie) => isRef(Z) ? Z.value = ie : null),
        "is-menu-open": d.value
      }, w.$props, {
        onClear: Se,
        onOpen: be,
        onSetInputDate: lt,
        onSetEmptyDate: unref(ae),
        onSelectDate: F2,
        onToggle: na,
        onClose: Ue,
        onFocus: ba,
        onBlur: ka,
        onRealBlur: G[1] || (G[1] = (ie) => m.value = false),
        onTextInput: G[2] || (G[2] = (ie) => w.$emit("text-input", ie))
      }), createSlots({ _: 2 }, [
        renderList(unref(p), (ie, Xe) => ({
          name: ie,
          fn: withCtx((st) => [
            renderSlot(w.$slots, ie, normalizeProps(guardReactiveProps(st)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      (openBlock(), createBlock(resolveDynamicComponent(w.teleport ? Teleport : "div"), normalizeProps(guardReactiveProps(he.value)), {
        default: withCtx(() => [
          createVNode(Transition, {
            name: unref(me)(unref(W)),
            css: unref(v) && !unref(X).enabled
          }, {
            default: withCtx(() => [
              d.value ? (openBlock(), createElementBlock("div", mergeProps({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: _2
              }, pe.value, {
                class: { "dp--menu-wrapper": !unref(X).enabled },
                style: unref(X).enabled ? void 0 : unref(T)
              }), [
                createVNode(gn, mergeProps({
                  ref_key: "dpMenuRef",
                  ref: c
                }, w.$props, {
                  "internal-model-value": unref(se),
                  "onUpdate:internalModelValue": G[3] || (G[3] = (ie) => isRef(se) ? se.value = ie : null),
                  class: { [M.value]: true, "dp--menu-wrapper": w.teleport },
                  "open-on-top": unref(W),
                  "no-overlay-focus": re.value,
                  collapse: H.value,
                  "get-input-rect": o,
                  "is-text-input-date": f.value,
                  onClosePicker: Ue,
                  onSelectDate: F2,
                  onAutoApply: mt,
                  onTimeUpdate: ga,
                  onFlowStep: G[4] || (G[4] = (ie) => w.$emit("flow-step", ie)),
                  onUpdateMonthYear: G[5] || (G[5] = (ie) => w.$emit("update-month-year", ie)),
                  onInvalidSelect: G[6] || (G[6] = (ie) => w.$emit("invalid-select", unref(se))),
                  onAutoApplyInvalid: G[7] || (G[7] = (ie) => w.$emit("invalid-select", ie)),
                  onInvalidFixedRange: G[8] || (G[8] = (ie) => w.$emit("invalid-fixed-range", ie)),
                  onRecalculatePosition: unref($),
                  onTooltipOpen: G[9] || (G[9] = (ie) => w.$emit("tooltip-open", ie)),
                  onTooltipClose: G[10] || (G[10] = (ie) => w.$emit("tooltip-close", ie)),
                  onTimePickerOpen: G[11] || (G[11] = (ie) => w.$emit("time-picker-open", ie)),
                  onTimePickerClose: G[12] || (G[12] = (ie) => w.$emit("time-picker-close", ie)),
                  onAmPmChange: G[13] || (G[13] = (ie) => w.$emit("am-pm-change", ie)),
                  onRangeStart: G[14] || (G[14] = (ie) => w.$emit("range-start", ie)),
                  onRangeEnd: G[15] || (G[15] = (ie) => w.$emit("range-end", ie)),
                  onDateUpdate: G[16] || (G[16] = (ie) => w.$emit("date-update", ie)),
                  onInvalidDate: G[17] || (G[17] = (ie) => w.$emit("invalid-date", ie)),
                  onOverlayToggle: G[18] || (G[18] = (ie) => w.$emit("overlay-toggle", ie)),
                  onMenuBlur: G[19] || (G[19] = (ie) => w.$emit("blur"))
                }), createSlots({ _: 2 }, [
                  renderList(unref(ne), (ie, Xe) => ({
                    name: ie,
                    fn: withCtx((st) => [
                      renderSlot(w.$slots, ie, normalizeProps(guardReactiveProps({ ...st })))
                    ])
                  }))
                ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])
              ], 16)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 3
      }, 16))
    ], 10, Mo));
  }
}), Gn = /* @__PURE__ */ (() => {
  const e = $o;
  return e.install = (t) => {
    t.component("Vue3DatePicker", e);
  }, e;
})(), Ao = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Gn
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(Ao).forEach(([e, t]) => {
  e !== "default" && (Gn[e] = t);
});
const _hoisted_1$c = ["for"];
const _sfc_main$g = {
  __name: "MonthRangePicker",
  props: /* @__PURE__ */ mergeModels({
    label: {
      type: String,
      required: false,
      default: void 0
    },
    format: {
      type: [String, Function],
      required: false,
      default: "M/yyyy"
    },
    // Example string: 2024-12
    minDate: {
      type: [Date, String],
      required: false,
      default: void 0
    },
    maxDate: {
      type: [Date, String],
      required: false,
      default: void 0
    }
  }, {
    "modelValue": { type: Array },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const themeStore = useThemeStore();
    const uid = Uuid();
    const model = useModel(__props, "modelValue");
    const vueDatePickerModel = ref();
    function onVueDatePickerModelUpdate(newValue) {
      model.value = newValue;
    }
    watch(
      model,
      (newValue) => {
        if (newValue === vueDatePickerModel.value) {
          return;
        }
        if (!newValue || !vueDatePickerModel.value || newValue.length !== vueDatePickerModel.value.length) {
          vueDatePickerModel.value = newValue;
          return;
        }
        if (newValue[0].year !== vueDatePickerModel.value[0].year || newValue[0].month !== vueDatePickerModel.value[0].month || newValue[1].year !== vueDatePickerModel.value[1].year || newValue[1].month !== vueDatePickerModel.value[1].month) {
          vueDatePickerModel.value = newValue;
        }
      },
      { immediate: true }
    );
    const rangeConfig = {
      // Always require both ends of the range.
      partialRange: false
    };
    const textInputOptions = { enterSubmit: true, escClose: true };
    const customClasses = { menu: "month-picker__menu" };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          for: `dp-input-${unref(uid)}`,
          class: "month-picker-label"
        }, toDisplayString(props.label), 9, _hoisted_1$c)) : createCommentVNode("", true),
        _cache[1] || (_cache[1] = createTextVNode()),
        createVNode(unref(Gn), {
          modelValue: vueDatePickerModel.value,
          "onUpdate:modelValue": [
            _cache[0] || (_cache[0] = ($event) => vueDatePickerModel.value = $event),
            onVueDatePickerModelUpdate
          ],
          class: "month-picker",
          teleport: "#app",
          uid: unref(uid),
          format: props.format,
          "min-date": props.minDate,
          "max-date": props.maxDate,
          clearable: false,
          "partial-range": false,
          range: rangeConfig,
          dark: unref(themeStore).isDarkThemeActive,
          "text-input-options": textInputOptions,
          ui: customClasses,
          "prevent-min-max-navigation": "",
          "month-picker": "",
          "text-input": ""
        }, null, 8, ["modelValue", "uid", "format", "min-date", "max-date", "dark"])
      ]);
    };
  }
};
const MonthRangePicker = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-994e2a71"]]);
const _hoisted_1$b = { class: "mb16" };
const _hoisted_2$b = { class: "tooltip-info-indicator" };
const _hoisted_3$9 = { class: "flex flex--gap mt8 mb32" };
const _hoisted_4$8 = ["onClick"];
const _sfc_main$f = {
  __name: "ExportOrderHistoryModal",
  setup(__props) {
    const isFinishScreenVisible = ref(false);
    const isProcessing = ref(false);
    const subAccountStore = useSubAccountStore();
    async function onConfirm() {
      isProcessing.value = true;
      try {
        const url = URLService.buildUrl("orderHistoryExportResource");
        let toDateParam = /* @__PURE__ */ new Date(`${selection.value[1].year}-${parseInt(selection.value[1].month) + 1}`);
        const endOfMonthDate = endOfMonth(toDateParam);
        const endOfDayToday = endOfDay(/* @__PURE__ */ new Date());
        toDateParam = endOfMonthDate > endOfDayToday ? endOfDayToday : endOfMonthDate;
        const fromDateParam = /* @__PURE__ */ new Date(`${selection.value[0].year}-${parseInt(selection.value[0].month) + 1}`);
        const payload = {
          fromDate: formatISO(fromDateParam),
          toDate: formatISO(toDateParam)
        };
        if (!subAccountStore.isMainActive) {
          payload.tradeAccountId = subAccountStore.activeSubAccountId;
        }
        await axiosInstance.post(url, payload);
        isFinishScreenVisible.value = true;
      } catch (e) {
        trackException(e);
      } finally {
        isProcessing.value = false;
      }
    }
    const isConfirmDisabled = computed(() => {
      return isProcessing.value;
    });
    const confirmText = computed(() => {
      if (isFinishScreenVisible.value) {
        return "";
      }
      return "Request export";
    });
    const cancelText = computed(() => {
      if (isFinishScreenVisible.value) {
        return "Close";
      }
      if (isProcessing.value) {
        return "";
      }
      return "Cancel";
    });
    const today = /* @__PURE__ */ new Date();
    const selection = ref([
      { month: today.getMonth(), year: today.getFullYear() },
      { month: today.getMonth(), year: today.getFullYear() }
    ]);
    function onPreset(range) {
      selection.value = range;
    }
    const minDate = getDate(PAGE_CONTEXT.registrationDate, true);
    let startOfYearDate = startOfYear(today);
    if (minDate > startOfYearDate) {
      startOfYearDate = minDate;
    }
    const previousMonth = subDays(startOfMonth(today), 1);
    const presets = [
      {
        label: "Current month",
        range: [
          { month: today.getMonth(), year: today.getFullYear() },
          { month: today.getMonth(), year: today.getFullYear() }
        ]
      }
    ];
    if (minDate <= previousMonth) {
      presets.push(
        {
          label: "Previous month",
          range: [
            { month: previousMonth.getMonth(), year: previousMonth.getFullYear() },
            { month: previousMonth.getMonth(), year: previousMonth.getFullYear() }
          ]
        }
      );
      presets.push(
        {
          label: "Year to date",
          range: [
            { month: startOfYearDate.getMonth(), year: startOfYearDate.getFullYear() },
            { month: today.getMonth(), year: today.getFullYear() }
          ]
        }
      );
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(TradeviewModal), {
        "is-open": "",
        title: "Derivatives order history export",
        "cancel-text": cancelText.value,
        "confirm-text": confirmText.value,
        "confirm-disabled": isConfirmDisabled.value,
        onConfirm
      }, {
        body: withCtx(() => [
          isFinishScreenVisible.value ? (openBlock(), createBlock(unref(GeneralNotification), {
            key: 0,
            title: "We’re preparing your derivatives order history export",
            "notification-type": "success"
          }, {
            default: withCtx(() => _cache[1] || (_cache[1] = [
              createBaseVNode("p", null, "\n            Keep an eye on your inbox. You'll receive an email with a download link, typically within a day.\n          ", -1)
            ])),
            _: 1
          })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("p", _hoisted_1$b, [
              _cache[4] || (_cache[4] = createTextVNode("\n          Select the time period for your derivatives order history export for your\n          ")),
              createVNode(unref(AppTooltip), null, {
                trigger: withCtx(() => [
                  createBaseVNode("strong", _hoisted_2$b, toDisplayString(unref(subAccountStore).activeSubAccountDisplayName), 1)
                ]),
                default: withCtx(() => [
                  _cache[2] || (_cache[2] = createTextVNode()),
                  _cache[3] || (_cache[3] = createBaseVNode("span", null, "Switch your active sub account to export its derivatives order history.", -1))
                ]),
                _: 1
              }),
              !unref(subAccountStore).isMainActive ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode("\n            sub account\n          ")
              ], 64)) : createCommentVNode("", true),
              _cache[5] || (_cache[5] = createTextVNode(".\n        "))
            ]),
            _cache[6] || (_cache[6] = createTextVNode()),
            _cache[7] || (_cache[7] = createBaseVNode("p", { class: "mb16" }, "\n          The download will be provided as a CSV file and a link will be emailed to you when the export is ready.\n        ", -1)),
            _cache[8] || (_cache[8] = createTextVNode()),
            createVNode(unref(MonthRangePicker), {
              modelValue: selection.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selection.value = $event),
              "min-date": unref(minDate),
              "max-date": unref(today),
              label: "Select export range:"
            }, null, 8, ["modelValue", "min-date", "max-date"]),
            _cache[9] || (_cache[9] = createTextVNode()),
            createBaseVNode("div", _hoisted_3$9, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.label,
                  class: "preset-button",
                  onClick: ($event) => onPreset(preset.range)
                }, toDisplayString(preset.label), 9, _hoisted_4$8);
              }), 64))
            ])
          ], 64))
        ]),
        _: 1
      }, 8, ["cancel-text", "confirm-text", "confirm-disabled"]);
    };
  }
};
const ExportOrderHistoryModal = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-abe3502a"]]);
const tooltipTimeFormatter = new Intl.DateTimeFormat(constants.LOCALE, {
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
});
const _sfc_main$e = {
  name: "OrderHistory",
  components: {
    ReceiptLink,
    MarginSettingTag,
    AppTooltip,
    AppPagination: Pagination,
    ExpandToggler,
    OrderHistoryDetails,
    TableLayout,
    ExportOrderHistoryModal
  },
  props: {
    activeTab: {
      type: String,
      required: true
    }
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      tradeviewOrderHistoryStore: useTradeviewOrderHistoryStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      tradeviewPrivateTradesStore: useTradeviewPrivateTradesStore(),
      orderHistoryStore: useOrderHistoryStore(),
      marketsStore: useMarketsStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewModalStore: useTradeviewModalStore()
    };
  },
  data() {
    return {
      ordersConstants: constants$1,
      tableTestId: "order-history-table",
      expandedOrders: {}
    };
  },
  computed: {
    isOrderHistoryExportModalOpen() {
      return this.tradeviewModalStore.lastRequestedModalType === EXPORT_ORDER_HISTORY_MODAL;
    },
    columns() {
      const cols = [
        {
          title: "Order",
          slotKey: "order",
          tooltip: `Click [+] to view fills and order summary.

A Stop order will appear within order history as a Market or Limit order once it's triggered.

Additionally order history for finished orders is only available for 30 days.`
        },
        { title: "Order time", slotKey: "datetime", textAlignRight: true },
        { title: "Price", slotKey: "price", textAlignRight: true },
        { title: "Filled / Amount", slotKey: "amount", textAlignRight: true }
      ];
      if (this.activeMarketStore.isPerpetual) {
        cols.push({ title: "Trigger price", slotKey: "triggerPrice", textAlignRight: true });
      }
      cols.push({ title: "Status", slotKey: "status" });
      cols.push({ title: "Details", slotKey: "details", textAlignRight: true });
      return cols;
    },
    formattedOrderHistory() {
      if (this.orderHistoryStore.isDisabledDueToTimeout) {
        return [];
      }
      const orders = [];
      this.orderHistoryStore.orderHistory.forEach((order) => {
        var _a2, _b;
        const market = this.marketsStore.getMarket(order.market);
        if (!market) {
          (_a2 = this.$errorTracking) == null ? void 0 : _a2.track(`Could not find market [${order.market}] when formatting orders.`);
          return;
        }
        const decimals = market.decimals;
        const amountRemaining = order.amountAtCreate.sub(order.amountFilled);
        const filledRatio = order.amountFilled.div(order.amountAtCreate);
        orders.push({
          id: order.orderId,
          key: order.orderId,
          side: order.side,
          tooltipDatetime: tooltipTimeFormatter.format(order.time),
          date: formatDate(order.time, constants$4.TRADEVIEW_DATE),
          time: formatDate(order.time, constants$4.TRADEVIEW_TIME),
          price: order.price,
          amountCurrency: market.base,
          amountRemaining,
          formattedPrice: order.price && order.price.isPositive() ? numberFormatter.decimal({
            value: order.price,
            decimals: decimals.counter,
            smartStripTrailingZeros: true
          }) : "/",
          formattedStopPrice: order.stopPrice ? numberFormatter.decimal({
            value: order.stopPrice,
            decimals: decimals.counter,
            smartStripTrailingZeros: true
          }) : "/",
          formattedActivationPrice: order.activationPrice ? numberFormatter.decimal({
            value: order.activationPrice,
            decimals: decimals.counter,
            smartStripTrailingZeros: true
          }) : "/",
          triggerTypeDisplay: order.trigger ? constants$1.TRIGGER_PRICE_TYPE_DISPLAY[order.trigger] : "",
          formattedAmountAtCreate: numberFormatter.decimal({
            value: order.amountAtCreate,
            decimals: decimals.base
          }),
          formattedAmountRemaining: numberFormatter.decimal({
            value: amountRemaining,
            decimals: decimals.base
          }),
          formattedAmountFilled: order.amountFilled.isZero() ? "0" : numberFormatter.decimal({
            value: order.amountFilled,
            decimals: decimals.base
          }),
          status: constants$1.ORDER_STATUS_DISPLAY[order.status],
          typeDisplay: order.isLiquidation ? "Liquidation" : ((_b = constants$1.ORDER_TYPE_CONFIG[order.type]) == null ? void 0 : _b.display) ?? "UNSUPPORTED TYPE",
          marketKey: market.key,
          marketName: market.name,
          marketLink: URLService.getPageUrl("proTrade", { market: market.key }),
          showSubTable: Boolean(this.expandedOrders[order.orderId]),
          filledProgress: filledRatio.mul(100).toFixed(2, Decimal.ROUND_UP),
          isFillProgressAvailable: order.type === constants$1.ORDER_TYPE.LIMIT,
          isPartiallyFilled: order.amountFilled.gt(0) && order.amountAtCreate.sub(order.amountFilled).gt(0) && order.type === constants$1.ORDER_TYPE.LIMIT,
          marginModeDisplay: constants$1.MARGIN_MODE_DISPLAY[order.marginMode],
          orderReceiptLink: this.$pageContext.enableReceiptsInTradeview ? URLService.getPageUrl("orderReceipt", {
            order_id: order.orderId
          }) : ""
        });
      });
      return orders;
    },
    showHistoryForAllMarkets() {
      return this.activeTab === constants.MARKET_FILTER.ALL;
    },
    itemCountWithPagination() {
      const numEntries = this.orderHistoryStore.orderHistory.length;
      if (numEntries === this.orderHistoryStore.perPage) {
        return this.orderHistoryStore.perPage * this.orderHistoryStore.page + 1;
      }
      return this.orderHistoryStore.perPage * (this.orderHistoryStore.page - 1) + numEntries;
    }
  },
  methods: {
    onPageChange(page) {
      var _a2, _b;
      this.orderHistoryStore.setPage(page);
      (_b = (_a2 = this.$refs.orderHistoryWrapper) == null ? void 0 : _a2.firstChild) == null ? void 0 : _b.scrollTo(0, 0);
    },
    toggleOrderDetails(orderId) {
      if (this.expandedOrders[orderId]) {
        this.expandedOrders[orderId] = false;
      } else {
        this.expandedOrders = { ...this.expandedOrders, [orderId]: true };
      }
    }
  }
};
const _hoisted_1$a = {
  ref: "orderHistoryWrapper",
  class: "orders-wrapper"
};
const _hoisted_2$a = { class: "orders__order" };
const _hoisted_3$8 = { class: "flex flex--gap-small flex--align-center" };
const _hoisted_4$7 = { class: "flex--direction-column" };
const _hoisted_5$5 = { "test-id": "order-history-order__type" };
const _hoisted_6$4 = { "test-id": "order-history-order__side" };
const _hoisted_7$2 = ["href", "title", "onClick"];
const _hoisted_8$2 = ["title"];
const _hoisted_9$2 = { key: 0 };
const _hoisted_10$2 = ["onClick"];
const _hoisted_11$2 = { key: 0 };
const _hoisted_12$2 = { key: 1 };
const _hoisted_13$2 = { class: "flex flex--direction-column" };
const _hoisted_14$2 = { class: "tooltip-info-indicator" };
const _hoisted_15$2 = ["onClick"];
const _hoisted_16$2 = { class: "table-layout__text--bright-text" };
const _hoisted_17$2 = { class: "flex flex--align-center flex--justify-end flex--gap" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppPagination = resolveComponent("AppPagination");
  const _component_MarginSettingTag = resolveComponent("MarginSettingTag");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_ReceiptLink = resolveComponent("ReceiptLink");
  const _component_ExpandToggler = resolveComponent("ExpandToggler");
  const _component_OrderHistoryDetails = resolveComponent("OrderHistoryDetails");
  const _component_TableLayout = resolveComponent("TableLayout");
  const _component_ExportOrderHistoryModal = resolveComponent("ExportOrderHistoryModal");
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    createVNode(_component_TableLayout, {
      items: $options.formattedOrderHistory,
      columns: $options.columns,
      "table-test-id": $data.tableTestId,
      class: "orders"
    }, {
      "details.header": withCtx(() => [
        createVNode(_component_AppPagination, {
          page: $setup.orderHistoryStore.page,
          "per-page": $setup.orderHistoryStore.perPage,
          count: $options.itemCountWithPagination,
          "icon-size": 10,
          "display-current-page": "",
          onNewPage: $options.onPageChange
        }, null, 8, ["page", "per-page", "count", "onNewPage"])
      ]),
      order: withCtx(({ item }) => [
        !item.showSubTable ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(["table-layout__strip", {
            "table-layout__strip--buy": item.side === $data.ordersConstants.ORDER_SIDE.BUY,
            "table-layout__strip--sell": item.side === $data.ordersConstants.ORDER_SIDE.SELL
          }])
        }, null, 2)) : createCommentVNode("", true),
        _cache[3] || (_cache[3] = createTextVNode()),
        createBaseVNode("div", _hoisted_2$a, [
          createBaseVNode("div", _hoisted_3$8, [
            createBaseVNode("div", _hoisted_4$7, [
              createBaseVNode("div", {
                class: normalizeClass({
                  "table-layout__text--buy": item.side === $data.ordersConstants.ORDER_SIDE.BUY,
                  "table-layout__text--sell": item.side === $data.ordersConstants.ORDER_SIDE.SELL
                })
              }, [
                createBaseVNode("span", _hoisted_5$5, toDisplayString(item.typeDisplay), 1),
                _cache[0] || (_cache[0] = createTextVNode()),
                createBaseVNode("span", _hoisted_6$4, toDisplayString(item.side === "buy" ? "Buy" : "Sell"), 1)
              ], 2),
              _cache[1] || (_cache[1] = createTextVNode()),
              createBaseVNode("a", {
                href: item.marketLink,
                title: `Change active market to ${item.marketName}`,
                class: "table-layout__text--link",
                "test-id": "order-history-order__market",
                onClick: withModifiers(($event) => $setup.setActiveMarket(item.marketKey), ["prevent"])
              }, toDisplayString(item.marketName), 9, _hoisted_7$2)
            ]),
            _cache[2] || (_cache[2] = createTextVNode()),
            item.marginModeDisplay ? (openBlock(), createBlock(_component_MarginSettingTag, {
              key: 0,
              "test-id": "margin-mode",
              text: item.marginModeDisplay
            }, null, 8, ["text"])) : createCommentVNode("", true)
          ])
        ])
      ]),
      datetime: withCtx(({ item }) => [
        createBaseVNode("div", {
          title: `Order placed on ${item.tooltipDatetime}`,
          class: "flex flex--direction-column"
        }, [
          createBaseVNode("span", null, toDisplayString(item.time), 1),
          _cache[4] || (_cache[4] = createTextVNode()),
          createBaseVNode("small", null, toDisplayString(item.date), 1)
        ], 8, _hoisted_8$2)
      ]),
      status: withCtx(({ item }) => [
        item.isPartiallyFilled ? (openBlock(), createElementBlock("div", _hoisted_9$2, "\n          Partially filled\n        ")) : createCommentVNode("", true),
        _cache[5] || (_cache[5] = createTextVNode()),
        createBaseVNode("div", null, [
          createBaseVNode("strong", null, toDisplayString(item.status), 1)
        ])
      ]),
      price: withCtx(({ item }) => [
        item.price ? (openBlock(), createElementBlock("span", {
          key: 0,
          title: "Fill order form with this price",
          class: "table-layout__text--bright-text table-layout__text--clickable",
          onClick: ($event) => $setup.tradeviewTriggerValueStore.setPriceSetByTrigger(item.price)
        }, toDisplayString(item.formattedPrice), 9, _hoisted_10$2)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode("\n          /\n        ")
        ], 64))
      ]),
      triggerPrice: withCtx(({ item }) => [
        item.formattedActivationPrice !== "/" ? (openBlock(), createElementBlock("span", _hoisted_11$2, toDisplayString(item.triggerTypeDisplay) + " @ " + toDisplayString(item.formattedActivationPrice), 1)) : item.formattedStopPrice !== "/" ? (openBlock(), createElementBlock("span", _hoisted_12$2, toDisplayString(item.triggerTypeDisplay) + " @ " + toDisplayString(item.formattedStopPrice), 1)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode("\n          /\n        ")
        ], 64))
      ]),
      amount: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_13$2, [
          createBaseVNode("div", null, [
            item.isFillProgressAvailable && item.amountRemaining.gt(0) && item.filledProgress > 0 ? (openBlock(), createBlock(_component_AppTooltip, { key: 0 }, {
              trigger: withCtx(() => [
                createBaseVNode("div", _hoisted_14$2, "\n                  (" + toDisplayString(item.filledProgress) + "%) " + toDisplayString(item.formattedAmountFilled) + " " + toDisplayString(item.amountCurrency), 1)
              ]),
              default: withCtx(() => [
                _cache[6] || (_cache[6] = createTextVNode("\n              Remaining:\n              ")),
                createBaseVNode("a", {
                  href: "#",
                  title: "Fill form with this amount",
                  onClick: ($event) => $setup.tradeviewTriggerValueStore.setAmountSetByTrigger(item.amountRemaining)
                }, toDisplayString(item.formattedAmountRemaining), 9, _hoisted_15$2),
                createTextVNode(" " + toDisplayString(item.amountCurrency), 1)
              ]),
              _: 2
            }, 1024)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("span", null, toDisplayString(item.formattedAmountFilled), 1),
              _cache[7] || (_cache[7] = createTextVNode()),
              createBaseVNode("span", null, toDisplayString(item.amountCurrency), 1)
            ], 64))
          ]),
          _cache[9] || (_cache[9] = createTextVNode()),
          createBaseVNode("div", null, [
            createBaseVNode("span", _hoisted_16$2, toDisplayString(item.formattedAmountAtCreate), 1),
            _cache[8] || (_cache[8] = createTextVNode()),
            createBaseVNode("span", null, toDisplayString(item.amountCurrency), 1)
          ])
        ])
      ]),
      details: withCtx(({ item }) => [
        createBaseVNode("div", _hoisted_17$2, [
          item.orderReceiptLink ? (openBlock(), createBlock(_component_ReceiptLink, {
            key: 0,
            link: item.orderReceiptLink
          }, null, 8, ["link"])) : createCommentVNode("", true),
          _cache[10] || (_cache[10] = createTextVNode()),
          createVNode(_component_ExpandToggler, {
            row: item.id,
            "is-expanded": item.showSubTable,
            onToggle: ($event) => $options.toggleOrderDetails(item.id)
          }, null, 8, ["row", "is-expanded", "onToggle"])
        ])
      ]),
      subTable: withCtx(({ item }) => [
        createVNode(_component_OrderHistoryDetails, {
          "order-id": item.id,
          "is-buy-order": item.side === $data.ordersConstants.ORDER_SIDE.BUY
        }, null, 8, ["order-id", "is-buy-order"])
      ]),
      empty: withCtx(() => [
        $setup.orderHistoryStore.isDisabledDueToTimeout ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode("\n          The order history view is currently not available for this account.\n        ")
        ], 64)) : $setup.orderHistoryStore.initialized ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          $setup.orderHistoryStore.page > 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode("\n            No additional order history entries found.\n          ")
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode("\n            No order history available" + toDisplayString($options.showHistoryForAllMarkets ? "" : " for this market") + ".\n          ", 1)
          ], 64))
        ], 64)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["items", "columns", "table-test-id"]),
    _cache[20] || (_cache[20] = createTextVNode()),
    $options.isOrderHistoryExportModalOpen ? (openBlock(), createBlock(_component_ExportOrderHistoryModal, { key: 0 })) : createCommentVNode("", true)
  ], 512);
}
const OrderHistory = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-b5669a69"]]);
const _sfc_main$d = {
  components: {
    ActionMenu,
    TabSelector,
    WidgetLayout
  },
  props: {
    isHeaderUnderlined: {
      type: Boolean,
      default: false
    },
    widgets: {
      type: Array,
      default: () => []
    },
    useVShowMode: {
      type: Boolean,
      default: false
    },
    initialActivePrimaryTabId: {
      type: String,
      default: null
    },
    initialActiveSecondaryTabId: {
      type: String,
      default: null
    },
    // Adjust to available space and move extra items to an overflow menu
    withOverflowMenu: {
      type: Boolean,
      default: false
    }
  },
  emits: ["primaryTabChange", "secondaryTabChange"],
  data() {
    var _a2;
    return {
      activeOverflowTab: null,
      activePrimaryTab: ((_a2 = this.widgets.find(({ id }) => id === this.initialActivePrimaryTabId)) == null ? void 0 : _a2.id) || this.widgets[0].id,
      activeSecondaryTab: this.initialActiveSecondaryTabId ?? constants.MARKET_FILTER.ALL,
      resizeObserver: null,
      resizing: false,
      overflowCount: 0
    };
  },
  computed: {
    activeWidget() {
      return this.widgets.find(({ id }) => id === this.activePrimaryTab);
    },
    isMobile() {
      return this.$isSmall.value;
    },
    hasTabs() {
      var _a2, _b;
      return ((_b = (_a2 = this.activeWidget) == null ? void 0 : _a2.tabs) == null ? void 0 : _b.length) > 0;
    },
    primaryTabs() {
      return this.widgets.map((widget2) => ({
        text: widget2.titleUpdater ? widget2.titleUpdater() : widget2.title,
        id: widget2.id
      }));
    },
    visiblePrimaryTabs() {
      if (!this.withOverflowMenu || this.overflowCount < 1 || this.overflowTabOptions.length < 1) {
        return this.primaryTabs;
      }
      const overflowTab = this.activeOverflowTab ?? this.overflowTabOptions[0].id;
      const visibleTabs = this.primaryTabs.slice(0, this.primaryTabs.length - this.overflowCount);
      visibleTabs.push(this.overflowTabOptions.find(({ id }) => id === overflowTab));
      return visibleTabs;
    },
    overflowTabOptions() {
      if (this.overflowCount < 1) {
        return [];
      }
      const overflowOptions = [];
      for (let i = this.widgets.length - this.overflowCount; i < this.widgets.length; i++) {
        if (i < 0) {
          continue;
        }
        const tab = this.widgets[i];
        overflowOptions.push({
          text: tab.title,
          id: tab.id,
          callback: () => this.selectOverflowTab(tab.id)
        });
      }
      return overflowOptions;
    }
  },
  watch: {
    initialActivePrimaryTabId(newValue) {
      if (newValue) {
        this.activatePrimaryTab(newValue);
      }
    },
    overflowTabOptions(newOverflowTabs, oldOverflowTabs) {
      if (newOverflowTabs && newOverflowTabs.length !== oldOverflowTabs.length && newOverflowTabs.length > 0) {
        if (!this.visiblePrimaryTabs.some(({ id }) => id === this.activePrimaryTab) && this.overflowTabOptions.some(({ id }) => id === this.activePrimaryTab)) {
          this.selectOverflowTab(this.activePrimaryTab);
        }
      }
    }
  },
  mounted() {
    var _a2;
    if (window.ResizeObserver && this.withOverflowMenu) {
      this.resizeObserver = new ResizeObserver(_.throttle(this.onResize, 200));
      this.resizeObserver.observe((_a2 = this.$refs.widgetLayout) == null ? void 0 : _a2.$el);
    }
  },
  beforeUnmount() {
    var _a2, _b;
    if (this.resizeObserver && ((_a2 = this.$refs.widgetLayout) == null ? void 0 : _a2.$el)) {
      this.resizeObserver.unobserve((_b = this.$refs.widgetLayout) == null ? void 0 : _b.$el);
    }
  },
  methods: {
    selectOverflowTab(tabId) {
      this.activeOverflowTab = tabId;
      this.activatePrimaryTab(tabId);
    },
    onResize() {
      this.resizing = true;
      this.overflowCount = 0;
      this.$nextTick(() => {
        var _a2, _b;
        const container = (_a2 = this.$refs.widgetLayout) == null ? void 0 : _a2.$el;
        const containerWidth = container.clientWidth;
        const secondaryTabs = container.querySelector(".js-right-tabs-and-settings");
        const secondaryTabsWidth = (secondaryTabs == null ? void 0 : secondaryTabs.clientWidth) ?? 0;
        const primaryTabs = (_b = this.$refs.primaryTabs) == null ? void 0 : _b.$el;
        if (!primaryTabs) {
          this.resizing = false;
          return;
        }
        const primaryTabsWidth = primaryTabs.clientWidth;
        const gap = 50;
        const availableSpace = containerWidth - secondaryTabsWidth - gap;
        if (availableSpace >= primaryTabsWidth) {
          this.resizing = false;
          return;
        }
        const primaryTabElements = primaryTabs.querySelectorAll(".js-tab");
        if (primaryTabElements.length !== this.primaryTabs.length) {
          this.resizing = false;
          return;
        }
        let usedWidth = 0;
        for (let i = 0; i < this.primaryTabs.length; i++) {
          const tabWidth = primaryTabElements[i].clientWidth;
          if (availableSpace - usedWidth < tabWidth) {
            this.overflowCount = this.primaryTabs.length - i + 1;
            break;
          }
          usedWidth += tabWidth;
        }
        this.resizing = false;
      });
    },
    activatePrimaryTab(tabId) {
      this.activePrimaryTab = tabId;
      this.$emit("primaryTabChange", tabId);
    },
    onSecondaryTabChange(tabId) {
      this.activeSecondaryTab = tabId ?? this.activeWidget.defaultActiveTab;
      this.$emit("secondaryTabChange", tabId);
    }
  }
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TabSelector = resolveComponent("TabSelector");
  const _component_ActionMenu = resolveComponent("ActionMenu");
  const _component_WidgetLayout = resolveComponent("WidgetLayout");
  return openBlock(), createBlock(_component_WidgetLayout, { ref: "widgetLayout" }, createSlots({
    titleTabs: withCtx(() => [
      (openBlock(), createBlock(_component_TabSelector, {
        ref: "primaryTabs",
        key: `title-tabs-${$options.primaryTabs.length}`,
        tabs: $options.visiblePrimaryTabs,
        "active-tab-id": $data.activePrimaryTab,
        class: normalizeClass({ "resizing": $data.resizing }),
        onActivatedTab: $options.activatePrimaryTab
      }, null, 8, ["tabs", "active-tab-id", "class", "onActivatedTab"])),
      _cache[0] || (_cache[0] = createTextVNode()),
      $options.overflowTabOptions.length > 0 ? (openBlock(), createBlock(_component_ActionMenu, {
        key: 0,
        class: "overflow-selector",
        placement: "bottom",
        "icon-type": "arrow-down",
        "popper-hide-triggers": ["click"],
        options: $options.overflowTabOptions
      }, null, 8, ["options"])) : createCommentVNode("", true)
    ]),
    tabs: withCtx(() => [
      withDirectives((openBlock(), createBlock(_component_TabSelector, {
        key: `widget-tabs-${$options.activeWidget.length}`,
        tabs: $options.activeWidget.tabs,
        "active-tab-id": $data.activeSecondaryTab,
        onActivatedTab: $options.onSecondaryTabChange
      }, null, 8, ["tabs", "active-tab-id", "onActivatedTab"])), [
        [vShow, $options.hasTabs && !$options.isMobile]
      ])
    ]),
    default: withCtx(() => [
      _cache[1] || (_cache[1] = createTextVNode()),
      _cache[2] || (_cache[2] = createTextVNode()),
      $props.useVShowMode ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($props.widgets, (widget2) => {
        return withDirectives((openBlock(), createBlock(resolveDynamicComponent(widget2.component), {
          key: widget2.id,
          "active-tab": $data.activeSecondaryTab,
          "is-visible": widget2.id === $data.activePrimaryTab
        }, null, 8, ["active-tab", "is-visible"])), [
          [vShow, widget2.id === $data.activePrimaryTab]
        ]);
      }), 128)) : (openBlock(), createBlock(resolveDynamicComponent($options.activeWidget.component), {
        key: 1,
        "active-tab": $data.activeSecondaryTab
      }, null, 8, ["active-tab"])),
      _cache[3] || (_cache[3] = createTextVNode()),
      _cache[4] || (_cache[4] = createTextVNode())
    ]),
    _: 2
  }, [
    $options.activeWidget.search && !$options.isMobile ? {
      name: "search",
      fn: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent($options.activeWidget.search)))
      ]),
      key: "0"
    } : void 0,
    $options.activeWidget.settings ? {
      name: "settings",
      fn: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent($options.activeWidget.settings)))
      ]),
      key: "1"
    } : void 0
  ]), 1536);
}
const GroupedWidgetLayout = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c], ["__scopeId", "data-v-1a87e13e"]]);
const OPEN_POSITIONS_TAB_TITLE = "Positions";
const OPEN_ORDERS_TAB_TITLE = "Open orders";
const OPEN_POSITIONS = "positions";
const OPEN_ORDERS = "openOrders";
const ORDER_HISTORY = "orderHistory";
const POSITION_HISTORY = "positionHistory";
const POSITION_SETTLEMENT_HISTORY = "positionSettlementHistory";
const TRADE_HISTORY = "tradeHistory";
const BALANCES = "balances";
const _sfc_main$c = {
  OPEN_POSITIONS,
  OPEN_ORDERS,
  ORDER_HISTORY,
  POSITION_HISTORY,
  POSITION_SETTLEMENT_HISTORY,
  TRADE_HISTORY,
  BALANCES,
  name: "TradeActivity",
  components: {
    GroupedWidgetLayout
  },
  props: {
    initialActiveWidget: {
      type: String,
      required: false,
      default: null
    }
  },
  emits: ["change"],
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewOpenPositionsStore: useTradeviewOpenPositionsStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore(),
      userStateStore: useUserStateStore(),
      subAccountStore: useSubAccountStore()
    };
  },
  data() {
    return {
      activeWidgetId: this.initialActiveWidget ?? null,
      OPEN_POSITIONS
    };
  },
  computed: {
    initialActiveSecondaryTab() {
      if (this.tradeviewSettingsStore.areUserOrdersInAllPairMode) {
        return constants.MARKET_FILTER.ALL;
      }
      return constants.MARKET_FILTER.CURRENT_MARKET;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    },
    widgets() {
      const _widgets = [];
      if (this.activeMarketStore.isPerpetual) {
        _widgets.push(
          {
            id: OPEN_POSITIONS,
            title: OPEN_POSITIONS_TAB_TITLE,
            titleUpdater: this.positionTitleUpdater,
            component: this.isAuthenticated ? markRaw(OpenPositions) : markRaw(LoginPlaceholder),
            tabs: [
              { text: "Current Market", id: constants.MARKET_FILTER.CURRENT_MARKET },
              { text: "All", id: constants.MARKET_FILTER.ALL }
            ],
            defaultActiveTab: constants.MARKET_FILTER.ALL,
            settings: OpenPositionsSettings
          }
        );
      }
      _widgets.push(
        {
          id: OPEN_ORDERS,
          title: OPEN_ORDERS_TAB_TITLE,
          titleUpdater: this.openOrdersTitleUpdater,
          component: this.isAuthenticated ? markRaw(OpenOrders) : markRaw(LoginPlaceholder),
          tabs: [
            { text: "Current Market", id: constants.MARKET_FILTER.CURRENT_MARKET },
            { text: "All", id: constants.MARKET_FILTER.ALL }
          ],
          defaultActiveTab: constants.MARKET_FILTER.ALL
        }
      );
      if (PAGE_CONTEXT.enableOrderHistoryApi && this.$has("trade_orders_read")) {
        _widgets.push(
          {
            id: ORDER_HISTORY,
            title: "Order history",
            component: this.isAuthenticated ? markRaw(OrderHistory) : markRaw(LoginPlaceholder),
            tabs: [
              { text: "Current Market", id: constants.MARKET_FILTER.CURRENT_MARKET },
              { text: "All", id: constants.MARKET_FILTER.ALL }
            ],
            defaultActiveTab: constants.MARKET_FILTER.ALL,
            settings: PAGE_CONTEXT.enableOrderHistoryExport && this.subAccountStore.doesActiveAccountSupportDerivatives ? OrderHistorySettings : null
          }
        );
      }
      _widgets.push(
        {
          id: TRADE_HISTORY,
          title: "Trade history",
          component: this.isAuthenticated ? markRaw(TradeHistory) : markRaw(LoginPlaceholder),
          tabs: [
            { text: "Current Market", id: constants.MARKET_FILTER.CURRENT_MARKET },
            { text: "All", id: constants.MARKET_FILTER.ALL }
          ],
          defaultActiveTab: constants.MARKET_FILTER.ALL
        }
      );
      if (this.activeMarketStore.isPerpetual) {
        _widgets.push(
          {
            id: POSITION_HISTORY,
            title: "Position history",
            component: this.isAuthenticated ? markRaw(PositionHistory) : markRaw(LoginPlaceholder),
            tabs: [
              { text: "Current Market", id: constants.MARKET_FILTER.CURRENT_MARKET },
              { text: "All", id: constants.MARKET_FILTER.ALL }
            ],
            defaultActiveTab: constants.MARKET_FILTER.ALL,
            settings: PositionHistorySettings
          }
        );
      }
      if (this.activeMarketStore.isPerpetual) {
        _widgets.push(
          {
            id: POSITION_SETTLEMENT_HISTORY,
            title: "Settlement history",
            component: this.isAuthenticated ? markRaw(PositionSettlementHistory) : markRaw(LoginPlaceholder),
            tabs: [
              { text: "Current Market", id: constants.MARKET_FILTER.CURRENT_MARKET },
              { text: "All", id: constants.MARKET_FILTER.ALL }
            ],
            defaultActiveTab: constants.MARKET_FILTER.ALL
          }
        );
      }
      _widgets.push(
        {
          id: BALANCES,
          title: "Balances",
          component: this.isAuthenticated ? markRaw(BalancesTable) : markRaw(LoginPlaceholder),
          settings: BalancesTableSettings,
          search: BalancesTableSearch
        }
      );
      return _widgets;
    }
  },
  watch: {
    initialActiveWidget(newValue) {
      if (newValue) {
        this.activeWidgetId = newValue;
      }
    },
    initialActiveSecondaryTab(newValue) {
      var _a2, _b;
      if (newValue) {
        (_b = (_a2 = this.$refs) == null ? void 0 : _a2.groupedWidgetLayout) == null ? void 0 : _b.onSecondaryTabChange(newValue);
      }
    }
  },
  methods: {
    positionTitleUpdater() {
      if (!this.isAuthenticated) {
        return OPEN_POSITIONS_TAB_TITLE;
      }
      const numPositions = this.tradeviewSettingsStore.areUserOrdersInAllPairMode ? this.tradeviewOpenPositionsStore.openPositions.length : this.tradeviewOpenPositionsStore.openPositionsForActiveMarket.length;
      return `${OPEN_POSITIONS_TAB_TITLE} (${numPositions})`;
    },
    openOrdersTitleUpdater() {
      if (!this.isAuthenticated) {
        return OPEN_ORDERS_TAB_TITLE;
      }
      const numOrders = this.tradeviewSettingsStore.areUserOrdersInAllPairMode ? this.tradeviewPrivateOrdersStore.openOrdersForActiveMarketType.length : this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket.length;
      return `${OPEN_ORDERS_TAB_TITLE} (${numOrders})`;
    },
    onPrimaryTabChange(activeWidgetId) {
      this.$emit("change", activeWidgetId);
      this.activeWidgetId = activeWidgetId;
    },
    onSecondaryTabChange(filterType) {
      this.tradeviewSettingsStore.setAreUserOrdersInAllPairMode(filterType === constants.MARKET_FILTER.ALL);
    }
  }
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GroupedWidgetLayout = resolveComponent("GroupedWidgetLayout");
  return openBlock(), createBlock(_component_GroupedWidgetLayout, {
    ref: "groupedWidgetLayout",
    key: $options.widgets.length,
    class: normalizeClass({ "overlay-popper-over-header": $data.activeWidgetId === $data.OPEN_POSITIONS }),
    widgets: $options.widgets,
    "initial-active-primary-tab-id": $data.activeWidgetId,
    "initial-active-secondary-tab-id": $options.initialActiveSecondaryTab,
    "use-v-show-mode": "",
    "with-overflow-menu": "",
    onPrimaryTabChange: $options.onPrimaryTabChange,
    onSecondaryTabChange: $options.onSecondaryTabChange
  }, null, 8, ["class", "widgets", "initial-active-primary-tab-id", "initial-active-secondary-tab-id", "onPrimaryTabChange", "onSecondaryTabChange"]);
}
const TradeActivity = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__scopeId", "data-v-a17e3bbd"]]);
const _imports_0 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xml:space='preserve'%20viewBox='0%200%2030%2030'%3e%3cpath%20d='M25.5.5c2.2%200%204%201.7%204%204v21.1c0%202.2-1.7%204-4%204h-21c-2.2%200-4-1.7-4-4V4.5c0-2.2%201.7-4%204-4zm0-.5h-21C2%200%200%202%200%204.5v21.1C0%2028%202%2030%204.5%2030h21.1c2.5%200%204.5-2%204.5-4.5v-21C30%202%2028%200%2025.5%200'%20style='fill:%23ccc'/%3e%3cpath%20d='M20%2013.7c-.4-.6-1-1-1.6-1.1.5-.2%201-.6%201.3-1%20.3-.5.5-1.1.5-1.7%200-1-.4-1.8-1.1-2.4-.4-.3-.8-.5-1.3-.7s-1.1-.3-1.6-.3H9.4v1.7c1%200%201.9.8%201.9%201.9S10.5%2012%209.4%2012v1.5c1%200%201.9.8%201.9%201.9v.3c0%201-.8%201.9-1.9%201.9V19h7c.6%200%201.1-.1%201.7-.3.4-.1.9-.4%201.3-.7s.6-.7.8-1.1.3-.9.3-1.4c.1-.6-.1-1.3-.5-1.8m-6.9-5.4h2.7c.5%200%201%20.1%201.4.5.4.3.6.8.5%201.3%200%20.5-.2%201-.5%201.3-.4.3-.9.5-1.4.4h-2.7zm4.5%208.4c-.4.4-1%20.6-1.5.5h-2.9v-3.8h3c.6%200%201.1.2%201.5.5s.6.8.6%201.3c-.2.6-.4%201.1-.7%201.5'%20style='fill:%23282827'/%3e%3cpath%20d='M9.4%2021.7h11.2v1.8H9.4z'%20style='fill:%23159e49'/%3e%3c/svg%3e";
const _sfc_main$b = {
  name: "MobileAppPrompt",
  props: {
    url: {
      type: String,
      required: true
    }
  },
  setup() {
    return {
      dismissMilliTimestamp: useLocalStorage(
        localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ANDROID_PROMPT_DISMISS_TIME,
        null
      )
    };
  },
  data() {
    return {
      isHidden: false
    };
  },
  computed: {
    isDismissed() {
      if (!this.dismissMilliTimestamp) {
        return false;
      }
      const dismissedAt = Number(this.dismissMilliTimestamp);
      return Date.now() - dismissedAt < 31 * 24 * 3600;
    }
  },
  methods: {
    close() {
      this.isHidden = true;
      this.dismissMilliTimestamp = `${Date.now()}`;
    }
  }
};
const _hoisted_1$9 = {
  key: 0,
  class: "mobile-app"
};
const _hoisted_2$9 = ["href"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "mobile-banner",
    appear: ""
  }, {
    default: withCtx(() => [
      !$data.isHidden && !$options.isDismissed ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
        createBaseVNode("div", {
          class: "mobile-app__close icon-close",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args))
        }),
        _cache[1] || (_cache[1] = createTextVNode()),
        _cache[2] || (_cache[2] = createBaseVNode("img", {
          src: _imports_0,
          class: "mobile-app__icon"
        }, null, -1)),
        _cache[3] || (_cache[3] = createTextVNode()),
        _cache[4] || (_cache[4] = createBaseVNode("div", { class: "mobile-app__text banner-text" }, [
          createBaseVNode("div", { class: "banner-text__title" }, "\n          Bitstamp – safe crypto trading\n        "),
          createTextVNode(),
          createBaseVNode("div", { class: "banner-text__publisher" }, "\n          Bitstamp Ltd.\n        ")
        ], -1)),
        _cache[5] || (_cache[5] = createTextVNode()),
        createBaseVNode("a", {
          href: $props.url,
          target: "_blank",
          rel: "noopener noreferrer",
          class: "mobile-app__button button"
        }, "\n        Get the app\n      ", 8, _hoisted_2$9)
      ])) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
const MobileAppPrompt = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-ec6bf18a"]]);
const _sfc_main$a = {
  name: "MobileHeader",
  components: {
    BtsButton,
    BtsLink,
    AccountTypeIcon,
    HeaderVaspDisclaimer,
    BitstampProLogo,
    BitstampDemoLogo,
    AnonMenuLinks,
    ProSwitch,
    UserMenu,
    AppIcon,
    UserSettings,
    TradeviewMarketSelector,
    MenuToggleIcon
  },
  setup() {
    const { selectAccount } = useSubAccounts();
    return {
      selectAccount,
      userStateStore: useUserStateStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      currenciesStore: useCurrenciesStore(),
      preferredCurrencyStore: usePreferredCurrencyStore(),
      subAccountStore: useSubAccountStore(),
      balancesStore: useBalancesStore()
    };
  },
  data() {
    return {
      isMarketsMenuOpen: false,
      isMobileMenuOpen: false,
      isAccountSectionActive: false,
      isSettingsSectionActive: false,
      isProfileSectionActive: false,
      downloadApp: URLService.getPageUrl("appStoreRedirect", {}, true, {
        r: "mobile",
        source: "navigation"
      }, true),
      hideEarnLinks: this.$constants.showVaspInvestmentRiskWarning,
      isDemoMode: CONSTANTS.demoMode ?? false,
      isOTCPageEnabledForUser: PAGE_CONTEXT.isOTCPageEnabledForUser,
      isEarnPageEnabledForUser: PAGE_CONTEXT.isEarnPageEnabledForUser
    };
  },
  computed: {
    displayedAccountBalances() {
      const balances = this.accountBalances(this.activeAccountId).filter((asset) => !asset.balance.isZero());
      return _.orderBy(balances, "code", "asc");
    },
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    loginUrl() {
      return URLService.getPageUrl(
        "login",
        {},
        true,
        { next: URLService.getPageUrl("proTrade", { market: this.activeMarket.key }) }
      );
    },
    logoLink() {
      if (this.isAuthenticated) {
        return URLService.getPageUrl("dashboardRouter");
      }
      return "/";
    },
    currencies() {
      return this.currenciesStore.currencies;
    },
    hasSubAccounts() {
      return this.subAccountStore.hasSubAccounts;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    },
    activeSubAccountName() {
      return this.subAccountStore.activeSubAccountDisplayName;
    },
    activeAccountId() {
      return this.subAccountStore.activeSubAccountId;
    },
    accounts() {
      return this.subAccountStore.accountList;
    },
    formattedAccountValue() {
      const value = this.balancesStore.activeAccountValue;
      if (value === null) {
        return "";
      }
      const currencyCode = this.preferredCurrencyStore.preferredCurrency;
      const counter = this.currenciesStore.getCurrency(currencyCode);
      return numberFormatter.price({
        value,
        decimals: counter.decimals,
        currencySymbol: counter.symbol,
        currencyCode
      });
    }
  },
  methods: {
    getPageUrl(name) {
      return URLService.getPageUrl(name);
    },
    formatCurrencyValue(value, currencyCode) {
      return numberFormatter.decimal({
        value,
        decimals: this.currenciesStore.getCurrency(currencyCode).decimals
      });
    },
    accountBalances(accountId) {
      return this.balancesStore.getAccountBalances(accountId);
    },
    logOut() {
      this.userStateStore.logOut();
    },
    formatDecimal(value, decimals) {
      return numberFormatter.decimal({ value, decimals });
    },
    marketValue(marketKey) {
      return this.tradeviewTickersStore.getTickerLastValue(marketKey);
    },
    toggleMobileMenu() {
      this.isMobileMenuOpen = !this.isMobileMenuOpen;
      if (this.isMobileMenuOpen) {
        document.body.classList.add("hide-overflow__mobile-menu");
      } else {
        this.closeMobileMenu();
        document.body.classList.remove("hide-overflow__mobile-menu");
      }
      this.closeMarketsMenu();
    },
    closeMobileMenu() {
      this.isMobileMenuOpen = false;
      this.isAccountSectionActive = false;
      this.isSettingsSectionActive = false;
      this.isProfileSectionActive = false;
    },
    openMarketsMenu() {
      this.isMarketsMenuOpen = true;
      this.closeMobileMenu();
      document.body.classList.add("hide-overflow__market-selector");
    },
    closeMarketsMenu() {
      this.isMarketsMenuOpen = false;
      document.body.classList.remove("hide-overflow__market-selector");
    },
    toggleAccountSection() {
      this.isAccountSectionActive = !this.isAccountSectionActive;
    },
    toggleSettingsSection() {
      this.isSettingsSectionActive = !this.isSettingsSectionActive;
    },
    toggleProfileSection() {
      this.isProfileSectionActive = !this.isProfileSectionActive;
    }
  }
};
const _hoisted_1$8 = { class: "mobile-header__section mobile-header__section--top" };
const _hoisted_2$8 = { class: "mobile-header__brand" };
const _hoisted_3$7 = {
  key: 0,
  class: "header-logo__demo-container"
};
const _hoisted_4$6 = {
  key: 0,
  class: "header-logo__entity"
};
const _hoisted_5$4 = { class: "mobile-header__section mobile-header__section--notifications" };
const _hoisted_6$3 = { class: "mobile-header__section mobile-header__section--bottom" };
const _hoisted_7$1 = { class: "mobile-header__select-currency" };
const _hoisted_8$1 = { class: "current-price__counter" };
const _hoisted_9$1 = { class: "current-price__value" };
const _hoisted_10$1 = {
  key: 0,
  class: "mobile-header__menu"
};
const _hoisted_11$1 = { class: "menu-group-item__name" };
const _hoisted_12$1 = {
  "data-test": "activeSubAccount",
  title: "Active sub account"
};
const _hoisted_13$1 = { class: "menu-wrapper" };
const _hoisted_14$1 = { class: "menu-links" };
const _hoisted_15$1 = ["href"];
const _hoisted_16$1 = { class: "menu-group-item__name" };
const _hoisted_17$1 = { class: "menu-footer" };
const _hoisted_18$1 = {
  key: 2,
  class: "menu-footer"
};
const _hoisted_19$1 = {
  key: 3,
  class: "section"
};
const _hoisted_20$1 = { class: "section__header" };
const _hoisted_21$1 = { class: "section__wrapper" };
const _hoisted_22$1 = { class: "section__content" };
const _hoisted_23$1 = { class: "section__list section__list--balance" };
const _hoisted_24$1 = { class: "selected-account-name" };
const _hoisted_25$1 = { class: "currency__symbol" };
const _hoisted_26$1 = { class: "section__content section__content--bordered" };
const _hoisted_27 = { class: "section__list" };
const _hoisted_28 = ["onClick"];
const _hoisted_29 = { class: "sub-account__name" };
const _hoisted_30 = {
  key: 0,
  class: "section__content section__content--bordered"
};
const _hoisted_31 = {
  key: 4,
  class: "section"
};
const _hoisted_32 = { class: "section__header" };
const _hoisted_33 = { class: "section__wrapper" };
const _hoisted_34 = { class: "section__content section__content--bordered" };
const _hoisted_35 = {
  key: 5,
  class: "section"
};
const _hoisted_36 = { class: "section__header" };
const _hoisted_37 = { class: "section__wrapper" };
const _hoisted_38 = { class: "section__content" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppIcon = resolveComponent("AppIcon");
  const _component_BitstampDemoLogo = resolveComponent("BitstampDemoLogo");
  const _component_BitstampProLogo = resolveComponent("BitstampProLogo");
  const _component_BtsLink = resolveComponent("BtsLink");
  const _component_MenuToggleIcon = resolveComponent("MenuToggleIcon");
  const _component_HeaderVaspDisclaimer = resolveComponent("HeaderVaspDisclaimer");
  const _component_TradeviewMarketSelector = resolveComponent("TradeviewMarketSelector");
  const _component_AccountTypeIcon = resolveComponent("AccountTypeIcon");
  const _component_AnonMenuLinks = resolveComponent("AnonMenuLinks");
  const _component_ProSwitch = resolveComponent("ProSwitch");
  const _component_BtsButton = resolveComponent("BtsButton");
  const _component_UserMenu = resolveComponent("UserMenu");
  const _component_UserSettings = resolveComponent("UserSettings");
  return openBlock(), createElementBlock("header", {
    class: normalizeClass(["mobile-header", { "mobile-header--demo-mode": $data.isDemoMode }])
  }, [
    createBaseVNode("div", _hoisted_1$8, [
      createBaseVNode("div", _hoisted_2$8, [
        createVNode(_component_BtsLink, {
          title: "Bitstamp",
          class: "header-logo",
          to: $options.logoLink,
          external: ""
        }, {
          default: withCtx(() => [
            $data.isDemoMode ? (openBlock(), createElementBlock("div", _hoisted_3$7, [
              createVNode(_component_AppIcon, {
                icon: "monochrome/warning.svg",
                class: "mobile-header__demo-indicator"
              }),
              _cache[9] || (_cache[9] = createTextVNode()),
              createVNode(_component_BitstampDemoLogo, { class: "header-logo__img" })
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createVNode(_component_BitstampProLogo, { class: "header-logo__img" }),
              _cache[10] || (_cache[10] = createTextVNode()),
              $options.isAuthenticated && $setup.userStateStore.state.bitstampEntity ? (openBlock(), createElementBlock("span", _hoisted_4$6, toDisplayString($setup.userStateStore.state.bitstampEntity.shortName), 1)) : createCommentVNode("", true)
            ], 64))
          ]),
          _: 1
        }, 8, ["to"])
      ]),
      _cache[11] || (_cache[11] = createTextVNode()),
      createBaseVNode("div", {
        class: "mobile-header__menu-toggler",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.toggleMobileMenu && $options.toggleMobileMenu(...args))
      }, [
        !$setup.tradeviewSettingsStore.isFullScreenMode ? (openBlock(), createBlock(_component_MenuToggleIcon, {
          key: 0,
          "is-open": $data.isMobileMenuOpen
        }, null, 8, ["is-open"])) : createCommentVNode("", true)
      ])
    ]),
    _cache[67] || (_cache[67] = createTextVNode()),
    createBaseVNode("div", _hoisted_5$4, [
      createVNode(_component_HeaderVaspDisclaimer, { "full-width": "" })
    ]),
    _cache[68] || (_cache[68] = createTextVNode()),
    createBaseVNode("div", _hoisted_6$3, [
      createBaseVNode("div", _hoisted_7$1, [
        createBaseVNode("div", {
          class: "selected-market",
          "test-id": "selected-market",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.openMarketsMenu && $options.openMarketsMenu(...args), ["stop"]))
        }, [
          createTextVNode(toDisplayString($options.activeMarket.name) + " ", 1),
          createVNode(_component_AppIcon, {
            icon: "monochrome/arrow-down.svg",
            class: "arrow-icon"
          })
        ]),
        _cache[13] || (_cache[13] = createTextVNode()),
        createBaseVNode("div", {
          class: "current-price",
          onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.openMarketsMenu && $options.openMarketsMenu(...args), ["stop"]))
        }, [
          createBaseVNode("span", _hoisted_8$1, toDisplayString($options.activeMarket.counter), 1),
          _cache[12] || (_cache[12] = createTextVNode()),
          createBaseVNode("span", _hoisted_9$1, toDisplayString($options.formatDecimal($options.marketValue($options.activeMarket.key), $options.activeMarket.decimals.counter)), 1)
        ])
      ]),
      _cache[14] || (_cache[14] = createTextVNode()),
      $data.isMarketsMenuOpen ? (openBlock(), createBlock(_component_TradeviewMarketSelector, {
        key: 0,
        "is-open": $data.isMarketsMenuOpen,
        mobile: "",
        onClose: $options.closeMarketsMenu
      }, null, 8, ["is-open", "onClose"])) : createCommentVNode("", true)
    ]),
    _cache[69] || (_cache[69] = createTextVNode()),
    createVNode(Transition, { name: "menu" }, {
      default: withCtx(() => [
        $data.isMobileMenuOpen ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
          $options.isAuthenticated ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            $options.hasSubAccounts ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "menu-group-item",
              onClick: _cache[3] || (_cache[3] = (...args) => $options.toggleAccountSection && $options.toggleAccountSection(...args))
            }, [
              createVNode(_component_AccountTypeIcon, {
                "supports-derivatives": $setup.subAccountStore.doesActiveAccountSupportDerivatives,
                "is-main-account": $setup.subAccountStore.isMainActive
              }, null, 8, ["supports-derivatives", "is-main-account"]),
              _cache[15] || (_cache[15] = createTextVNode()),
              createBaseVNode("span", _hoisted_11$1, [
                createBaseVNode("span", _hoisted_12$1, toDisplayString($options.activeSubAccountName), 1)
              ]),
              _cache[16] || (_cache[16] = createTextVNode()),
              createVNode(_component_AppIcon, {
                icon: "monochrome/arrow-right.svg",
                class: "arrow-icon"
              })
            ])) : createCommentVNode("", true),
            _cache[23] || (_cache[23] = createTextVNode()),
            createBaseVNode("div", {
              class: "menu-group-item",
              onClick: _cache[4] || (_cache[4] = (...args) => $options.toggleProfileSection && $options.toggleProfileSection(...args))
            }, [
              createVNode(_component_AppIcon, {
                icon: "monochrome/user.svg",
                class: "menu-group-item__icon"
              }),
              _cache[17] || (_cache[17] = createTextVNode()),
              _cache[18] || (_cache[18] = createBaseVNode("span", { class: "menu-group-item__name" }, "My profile", -1)),
              _cache[19] || (_cache[19] = createTextVNode()),
              createVNode(_component_AppIcon, {
                icon: "monochrome/arrow-right.svg",
                class: "arrow-icon"
              })
            ]),
            _cache[24] || (_cache[24] = createTextVNode()),
            createBaseVNode("div", {
              class: "menu-group-item",
              onClick: _cache[5] || (_cache[5] = (...args) => $options.toggleSettingsSection && $options.toggleSettingsSection(...args))
            }, [
              createVNode(_component_AppIcon, {
                icon: "monochrome/sliders.svg",
                class: "menu-group-item__icon"
              }),
              _cache[20] || (_cache[20] = createTextVNode()),
              _cache[21] || (_cache[21] = createBaseVNode("span", { class: "menu-group-item__name" }, "Tradeview Settings", -1)),
              _cache[22] || (_cache[22] = createTextVNode()),
              createVNode(_component_AppIcon, {
                icon: "monochrome/arrow-right.svg",
                class: "arrow-icon"
              })
            ])
          ], 64)) : createCommentVNode("", true),
          _cache[62] || (_cache[62] = createTextVNode()),
          createBaseVNode("div", _hoisted_13$1, [
            createBaseVNode("div", _hoisted_14$1, [
              $options.isAuthenticated ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createVNode(_component_BtsLink, {
                  class: "menu-links__item menu-links__item--indented",
                  to: $options.getPageUrl("proDashboard"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[25] || (_cache[25] = [
                    createTextVNode("\n                Dashboard\n              ")
                  ])),
                  _: 1
                }, 8, ["to"]),
                _cache[31] || (_cache[31] = createTextVNode()),
                createVNode(_component_BtsLink, {
                  class: "menu-links__item menu-links__item--indented",
                  to: $options.getPageUrl("tradeview"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[26] || (_cache[26] = [
                    createTextVNode("\n                Trade\n              ")
                  ])),
                  _: 1
                }, 8, ["to"]),
                _cache[32] || (_cache[32] = createTextVNode()),
                !$data.isDemoMode && _ctx.$has("deposits_read") ? (openBlock(), createBlock(_component_BtsLink, {
                  key: 0,
                  class: "menu-links__item menu-links__item--indented",
                  to: $options.getPageUrl("deposits_overview"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[27] || (_cache[27] = [
                    createTextVNode("\n                Deposit\n              ")
                  ])),
                  _: 1
                }, 8, ["to"])) : createCommentVNode("", true),
                _cache[33] || (_cache[33] = createTextVNode()),
                !$data.isDemoMode && _ctx.$has("withdrawals_read") ? (openBlock(), createBlock(_component_BtsLink, {
                  key: 1,
                  class: "menu-links__item menu-links__item--indented",
                  to: $options.getPageUrl("accountWithdrawals"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[28] || (_cache[28] = [
                    createTextVNode("\n                Withdraw\n              ")
                  ])),
                  _: 1
                }, 8, ["to"])) : createCommentVNode("", true),
                _cache[34] || (_cache[34] = createTextVNode()),
                !$data.isDemoMode && _ctx.$has("earn_read") && $data.isEarnPageEnabledForUser && !$data.hideEarnLinks ? (openBlock(), createBlock(_component_BtsLink, {
                  key: 2,
                  class: "menu-links__item menu-links__item--indented",
                  to: $options.getPageUrl("earnDashboard"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[29] || (_cache[29] = [
                    createTextVNode("\n                Earn\n              ")
                  ])),
                  _: 1
                }, 8, ["to"])) : createCommentVNode("", true),
                _cache[35] || (_cache[35] = createTextVNode()),
                !$data.isDemoMode && _ctx.$has("otc_history_read") && $data.isOTCPageEnabledForUser ? (openBlock(), createBlock(_component_BtsLink, {
                  key: 3,
                  class: "menu-links__item menu-links__item--indented",
                  to: $options.getPageUrl("otcDashboard"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[30] || (_cache[30] = [
                    createTextVNode("\n                OTC\n              ")
                  ])),
                  _: 1
                }, 8, ["to"])) : createCommentVNode("", true)
              ], 64)) : (openBlock(), createBlock(_component_AnonMenuLinks, {
                key: 1,
                "in-side-menu": "",
                "hide-earn-links": $data.hideEarnLinks
              }, null, 8, ["hide-earn-links"]))
            ])
          ]),
          _cache[63] || (_cache[63] = createTextVNode()),
          $options.isAuthenticated ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !$data.isDemoMode ? (openBlock(), createElementBlock("a", {
              key: 0,
              href: $data.downloadApp,
              target: "_blank",
              class: "menu-group-item menu-group-item--app-download"
            }, [
              createVNode(_component_AppIcon, {
                icon: "monochrome/smartphone.svg",
                class: "menu-group-item__icon"
              }),
              _cache[36] || (_cache[36] = createTextVNode()),
              createBaseVNode("span", _hoisted_16$1, toDisplayString(_ctx.$t("components.navigation.mobileMenu.getBitstampApp")), 1)
            ], 8, _hoisted_15$1)) : createCommentVNode("", true),
            _cache[39] || (_cache[39] = createTextVNode()),
            createBaseVNode("div", _hoisted_17$1, [
              createVNode(_component_BtsLink, {
                "data-test": "logOut",
                class: "logout",
                onClick: $options.logOut
              }, {
                default: withCtx(() => _cache[37] || (_cache[37] = [
                  createTextVNode("\n              Log out\n            ")
                ])),
                _: 1
              }, 8, ["onClick"]),
              _cache[38] || (_cache[38] = createTextVNode()),
              !$data.isDemoMode ? (openBlock(), createBlock(_component_ProSwitch, { key: 0 })) : createCommentVNode("", true)
            ])
          ], 64)) : (openBlock(), createElementBlock("div", _hoisted_18$1, [
            createVNode(_component_BtsButton, {
              secondary: "",
              link: $options.loginUrl,
              external: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$t("components.navigation.mobileMenu.logInButton")), 1)
              ]),
              _: 1
            }, 8, ["link"]),
            _cache[40] || (_cache[40] = createTextVNode()),
            createVNode(_component_BtsButton, {
              link: $options.getPageUrl("register"),
              external: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$t("components.navigation.mobileMenu.getStartedButton")), 1)
              ]),
              _: 1
            }, 8, ["link"])
          ])),
          _cache[64] || (_cache[64] = createTextVNode()),
          $data.isAccountSectionActive ? (openBlock(), createElementBlock("div", _hoisted_19$1, [
            createBaseVNode("div", _hoisted_20$1, [
              createBaseVNode("a", {
                class: "section__back-link",
                onClick: _cache[6] || (_cache[6] = (...args) => $options.toggleAccountSection && $options.toggleAccountSection(...args))
              }, [
                createVNode(_component_AppIcon, {
                  icon: "monochrome/arrow-left.svg",
                  class: "arrow-icon"
                }),
                _cache[41] || (_cache[41] = createTextVNode()),
                _cache[42] || (_cache[42] = createBaseVNode("span", null, "Back", -1))
              ])
            ]),
            _cache[55] || (_cache[55] = createTextVNode()),
            createBaseVNode("div", _hoisted_21$1, [
              createBaseVNode("div", _hoisted_22$1, [
                _cache[45] || (_cache[45] = createBaseVNode("div", { class: "section__title section__title--balance" }, "\n                Account balance\n              ", -1)),
                _cache[46] || (_cache[46] = createTextVNode()),
                createBaseVNode("div", _hoisted_23$1, [
                  createBaseVNode("div", _hoisted_24$1, toDisplayString($options.activeSubAccountName), 1),
                  _cache[44] || (_cache[44] = createTextVNode()),
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.displayedAccountBalances, (currency) => {
                    return openBlock(), createElementBlock("div", {
                      key: currency.code,
                      class: "currency"
                    }, [
                      createBaseVNode("span", _hoisted_25$1, toDisplayString(currency.code), 1),
                      _cache[43] || (_cache[43] = createTextVNode()),
                      createBaseVNode("span", {
                        class: normalizeClass(["currency__value", { "currency__value--zero": currency.balance.eq(0) }]),
                        "data-test": "subAccountBalance"
                      }, toDisplayString($options.formatCurrencyValue(currency.balance, currency.code)), 3)
                    ]);
                  }), 128))
                ])
              ]),
              _cache[53] || (_cache[53] = createTextVNode()),
              createBaseVNode("div", _hoisted_26$1, [
                _cache[48] || (_cache[48] = createBaseVNode("div", { class: "section__title" }, "\n                Switch Accounts\n              ", -1)),
                _cache[49] || (_cache[49] = createTextVNode()),
                createBaseVNode("div", _hoisted_27, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.accounts, (account) => {
                    return openBlock(), createElementBlock("div", {
                      key: account.id,
                      class: normalizeClass(["sub-account", { "sub-account--active": $options.activeAccountId === account.id }]),
                      "data-test": "setActiveSubAccount",
                      onClick: ($event) => $setup.selectAccount(account.id)
                    }, [
                      createVNode(_component_AccountTypeIcon, {
                        "supports-derivatives": account.isDerivativesTradingEnabled,
                        "is-main-account": account.isMainAccount
                      }, null, 8, ["supports-derivatives", "is-main-account"]),
                      _cache[47] || (_cache[47] = createTextVNode()),
                      createBaseVNode("span", _hoisted_29, toDisplayString(account.displayName), 1)
                    ], 10, _hoisted_28);
                  }), 128))
                ])
              ]),
              _cache[54] || (_cache[54] = createTextVNode()),
              _ctx.$has("sub_accounts_create") ? (openBlock(), createElementBlock("div", _hoisted_30, [
                $options.hasSubAccounts ? (openBlock(), createBlock(_component_BtsLink, {
                  key: 0,
                  class: "menu-links__item menu-links__item--submenu",
                  to: $options.getPageUrl("sub_account_transfer"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[50] || (_cache[50] = [
                    createTextVNode("\n                Transfer between accounts\n              ")
                  ])),
                  _: 1
                }, 8, ["to"])) : createCommentVNode("", true),
                _cache[52] || (_cache[52] = createTextVNode()),
                createVNode(_component_BtsLink, {
                  class: "menu-links__item menu-links__item--submenu",
                  to: $options.getPageUrl("createSubAccount"),
                  external: ""
                }, {
                  default: withCtx(() => _cache[51] || (_cache[51] = [
                    createTextVNode("\n                Create new sub account\n              ")
                  ])),
                  _: 1
                }, 8, ["to"])
              ])) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true),
          _cache[65] || (_cache[65] = createTextVNode()),
          $data.isProfileSectionActive ? (openBlock(), createElementBlock("div", _hoisted_31, [
            createBaseVNode("div", _hoisted_32, [
              createBaseVNode("a", {
                class: "section__back-link",
                onClick: _cache[7] || (_cache[7] = (...args) => $options.toggleProfileSection && $options.toggleProfileSection(...args))
              }, [
                createVNode(_component_AppIcon, {
                  icon: "monochrome/arrow-left.svg",
                  class: "arrow-icon"
                }),
                _cache[56] || (_cache[56] = createTextVNode()),
                _cache[57] || (_cache[57] = createBaseVNode("span", null, "Back", -1))
              ])
            ]),
            _cache[58] || (_cache[58] = createTextVNode()),
            createBaseVNode("div", _hoisted_33, [
              createBaseVNode("div", _hoisted_34, [
                createVNode(_component_UserMenu, {
                  "formatted-account-value": $options.formattedAccountValue,
                  tradeview: "",
                  mobile: ""
                }, null, 8, ["formatted-account-value"])
              ])
            ])
          ])) : createCommentVNode("", true),
          _cache[66] || (_cache[66] = createTextVNode()),
          $data.isSettingsSectionActive ? (openBlock(), createElementBlock("div", _hoisted_35, [
            createBaseVNode("div", _hoisted_36, [
              createBaseVNode("a", {
                class: "section__back-link",
                onClick: _cache[8] || (_cache[8] = (...args) => $options.toggleSettingsSection && $options.toggleSettingsSection(...args))
              }, [
                createVNode(_component_AppIcon, {
                  icon: "monochrome/arrow-left.svg",
                  class: "arrow-icon"
                }),
                _cache[59] || (_cache[59] = createTextVNode()),
                _cache[60] || (_cache[60] = createBaseVNode("span", null, "Back", -1))
              ])
            ]),
            _cache[61] || (_cache[61] = createTextVNode()),
            createBaseVNode("div", _hoisted_37, [
              createBaseVNode("div", _hoisted_38, [
                createVNode(_component_UserSettings, { mobile: true })
              ])
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    })
  ], 2);
}
const MobileHeader = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__scopeId", "data-v-8cb47f1c"]]);
const BEST_PERFORMERS = 1;
const WORST_PERFORMERS = 2;
const FAVORITES = 3;
const _sfc_main$9 = {
  name: "QuickView",
  components: {
    AppTooltip,
    RadioGroup,
    Swiper,
    SwiperSlide
  },
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    return {
      setActiveMarket,
      marketsStore: useMarketsStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      favoritesStore: useFavoritesStore(),
      userStateStore: useUserStateStore(),
      modules: [Navigation]
    };
  },
  data() {
    return {
      activeType: null,
      loadTimeout: null
    };
  },
  computed: {
    favoriteMarkets() {
      return Object.keys(this.favoritesStore.favoriteMarkets);
    },
    availableTypes() {
      const types = [
        { value: BEST_PERFORMERS, text: "Best performers" },
        { value: WORST_PERFORMERS, text: "Worst performers" }
      ];
      if (this.isAuthenticated) {
        types.push({ value: FAVORITES, text: "Favorites" });
      }
      return types;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    },
    entries() {
      let marketsToDisplay = [];
      const markets = this.marketsStore.visibleMarkets;
      const direction = this.activeType === BEST_PERFORMERS ? "desc" : "asc";
      switch (this.activeType) {
        case FAVORITES:
          marketsToDisplay = this.favoriteMarkets.filter((key) => markets[key]);
          break;
        case BEST_PERFORMERS:
        case WORST_PERFORMERS:
          marketsToDisplay = _.orderBy(
            Object.keys(markets),
            (marketKey) => {
              var _a2;
              return (_a2 = this.tradeviewTickersStore.getTicker(marketKey).last24) == null ? void 0 : _a2.toNumber();
            },
            direction
          ).slice(0, 18);
          break;
      }
      return marketsToDisplay.map((marketKey) => {
        const market = markets[marketKey];
        const ticker = this.tradeviewTickersStore.getTicker(marketKey);
        return {
          marketKey,
          marketName: market.name,
          link: URLService.getPageUrl("proTrade", { market: market.key }),
          price: numberFormatter.decimal({ value: ticker.last, decimals: market.decimals.counter }),
          change: numberFormatter.percentageChange(ticker.last24),
          isNegativeChange: ticker.last24.isNegative()
        };
      });
    }
  },
  mounted() {
    this.loadTimeout = setTimeout(() => {
      if (this.isAuthenticated && this.favoriteMarkets.length > 0) {
        this.activeType = FAVORITES;
      } else {
        this.activeType = BEST_PERFORMERS;
      }
    }, 500);
  },
  beforeUnmount() {
    clearTimeout(this.loadTimeout);
  }
};
const _hoisted_1$7 = {
  key: 0,
  class: "quick-view"
};
const _hoisted_2$7 = ["href", "test-id", "onClick"];
const _hoisted_3$6 = ["test-id"];
const _hoisted_4$5 = ["test-id"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_swiper_slide = resolveComponent("swiper-slide");
  const _component_swiper = resolveComponent("swiper");
  const _component_RadioGroup = resolveComponent("RadioGroup");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  return $data.activeType !== null ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
    (openBlock(), createBlock(_component_swiper, {
      key: `${$data.activeType}-${$options.favoriteMarkets.length}`,
      modules: $setup.modules,
      navigation: "",
      "slides-per-view": "auto",
      class: "quick-market-view",
      "test-id": "quick-market-view"
    }, {
      default: withCtx(() => [
        _cache[3] || (_cache[3] = createBaseVNode("div", { class: "quick-market-view__fader quick-market-view__fader--left" }, null, -1)),
        _cache[4] || (_cache[4] = createTextVNode()),
        _cache[5] || (_cache[5] = createBaseVNode("div", { class: "quick-market-view__fader quick-market-view__fader--right" }, null, -1)),
        _cache[6] || (_cache[6] = createTextVNode()),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.entries, (entry) => {
          return openBlock(), createBlock(_component_swiper_slide, {
            key: entry.name,
            class: "slide"
          }, {
            default: withCtx(() => [
              createBaseVNode("a", {
                class: "quick-market-view__link",
                href: entry.link,
                "test-id": `quick-market-link-${entry.marketKey}`,
                onClick: withModifiers(($event) => $setup.setActiveMarket(entry.marketKey), ["prevent"])
              }, toDisplayString(entry.marketName), 9, _hoisted_2$7),
              _cache[1] || (_cache[1] = createTextVNode()),
              createBaseVNode("div", {
                class: normalizeClass(["quick-market-view__delta quick-market-view__delta--positive", {
                  "quick-market-view__delta--positive": !entry.isNegativeChange,
                  "quick-market-view__delta--negative": entry.isNegativeChange
                }]),
                "test-id": `quick-market-change-${entry.marketKey}`
              }, toDisplayString(entry.change), 11, _hoisted_3$6),
              _cache[2] || (_cache[2] = createTextVNode()),
              createBaseVNode("div", {
                class: "quick-market-view__price",
                "test-id": `quick-market-price-${entry.marketKey}`
              }, toDisplayString(entry.price), 9, _hoisted_4$5)
            ]),
            _: 2
          }, 1024);
        }), 128))
      ]),
      _: 1
    }, 8, ["modules"])),
    _cache[7] || (_cache[7] = createTextVNode()),
    createVNode(_component_AppTooltip, {
      class: "quick-market-view__settings",
      "icon-size": 16,
      icon: "monochrome/sliders.svg",
      distance: 8,
      placement: "top",
      strategy: "fixed",
      type: "dropdown",
      title: "Select"
    }, {
      default: withCtx(() => [
        createVNode(_component_RadioGroup, {
          value: $data.activeType,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $data.activeType = $event),
          items: $options.availableTypes
        }, null, 8, ["value", "items"])
      ]),
      _: 1
    })
  ])) : createCommentVNode("", true);
}
const QuickView = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__scopeId", "data-v-cdb9bc87"]]);
const _sfc_main$8 = {
  name: "SystemStatus",
  components: {
    AppTooltip
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore()
    };
  },
  data() {
    return {
      TRADING_STATUSES: marketConstants.TRADING_STATUS,
      OK: "ok",
      DOWN: "down",
      WARNING: "warning"
    };
  },
  computed: {
    tradingStatus() {
      var _a2;
      return ((_a2 = this.activeMarketStore.activeMarket) == null ? void 0 : _a2.tradingStatus) ?? marketConstants.TRADING_STATUS.OPERATIONAL;
    },
    status() {
      if (this.tradingStatus === marketConstants.TRADING_STATUS.TRADE_HALT) {
        return this.DOWN;
      }
      if (this.tradingStatus === marketConstants.TRADING_STATUS.NO_MATCHING_HALT || this.activeMarketStore.activeMarket.marketAndInstantOrdersDisabled || this.activeMarketStore.activeMarket.stopOrdersDisabled) {
        return this.WARNING;
      }
      return this.OK;
    }
  }
};
const _hoisted_1$6 = { key: 0 };
const _hoisted_2$6 = { key: 1 };
const _hoisted_3$5 = { key: 0 };
const _hoisted_4$4 = { key: 1 };
const _hoisted_5$3 = { key: 2 };
const _hoisted_6$2 = { class: "system-status" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppTooltip = resolveComponent("AppTooltip");
  return openBlock(), createBlock(_component_AppTooltip, {
    class: "tooltip",
    distance: 8
  }, {
    trigger: withCtx(() => [
      createBaseVNode("div", _hoisted_6$2, [
        _cache[10] || (_cache[10] = createBaseVNode("span", { class: "system-status__text" }, "System status", -1)),
        _cache[11] || (_cache[11] = createTextVNode()),
        createBaseVNode("div", {
          class: normalizeClass(["system-status__indicator", {
            "system-status__indicator--ok": $options.status === $data.OK,
            "system-status__indicator--warning": $options.status === $data.WARNING,
            "system-status__indicator--down": $options.status === $data.DOWN
          }])
        }, null, 2)
      ])
    ]),
    default: withCtx(() => [
      $options.status === $data.OK ? (openBlock(), createElementBlock("p", _hoisted_1$6, toDisplayString($setup.activeMarketStore.activeMarket.name) + " market operational.\n    ", 1)) : $options.tradingStatus === $data.TRADING_STATUSES.TRADE_HALT ? (openBlock(), createElementBlock("p", _hoisted_2$6, [
        _cache[0] || (_cache[0] = createBaseVNode("strong", null, "Warning: ", -1)),
        _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
        createTextVNode("\n      Trade halt in effect for " + toDisplayString($setup.activeMarketStore.activeMarket.name) + ".\n    ", 1)
      ])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        $options.tradingStatus === $data.TRADING_STATUSES.NO_MATCHING_HALT ? (openBlock(), createElementBlock("p", _hoisted_3$5, [
          _cache[2] || (_cache[2] = createBaseVNode("strong", null, "Warning: ", -1)),
          _cache[3] || (_cache[3] = createBaseVNode("br", null, null, -1)),
          createTextVNode("\n        No matching halt in effect for " + toDisplayString($setup.activeMarketStore.activeMarket.name) + ".\n      ", 1)
        ])) : createCommentVNode("", true),
        _cache[8] || (_cache[8] = createTextVNode()),
        $setup.activeMarketStore.activeMarket.stopOrdersDisabled ? (openBlock(), createElementBlock("p", _hoisted_4$4, [
          _cache[4] || (_cache[4] = createBaseVNode("strong", null, "Warning: ", -1)),
          _cache[5] || (_cache[5] = createBaseVNode("br", null, null, -1)),
          createTextVNode("\n        Stop Orders Disabled for " + toDisplayString($setup.activeMarketStore.activeMarket.name), 1)
        ])) : createCommentVNode("", true),
        _cache[9] || (_cache[9] = createTextVNode()),
        $setup.activeMarketStore.activeMarket.marketAndInstantOrdersDisabled ? (openBlock(), createElementBlock("p", _hoisted_5$3, [
          _cache[6] || (_cache[6] = createBaseVNode("strong", null, "Warning: ", -1)),
          _cache[7] || (_cache[7] = createBaseVNode("br", null, null, -1)),
          createTextVNode("\n        Market Orders Disabled for " + toDisplayString($setup.activeMarketStore.activeMarket.name), 1)
        ])) : createCommentVNode("", true)
      ], 64)),
      _cache[12] || (_cache[12] = createTextVNode())
    ]),
    _: 1
  });
}
const SystemStatus = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__scopeId", "data-v-e4f6d9e4"]]);
const _sfc_main$7 = {
  name: "OrderBookTooltip",
  props: {
    side: {
      type: String,
      required: true
    },
    verticalPosition: {
      type: Number,
      required: true
    },
    orders: {
      type: Array,
      required: true
    }
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore()
    };
  },
  computed: {
    verticalPositionStyle() {
      return this.side === constants$2.ORDERBOOK.SIDES.ASKS ? `- ${this.verticalPosition}px` : `+ ${this.verticalPosition}px`;
    },
    amountSum() {
      let sum = new Decimal(0);
      for (const { amount } of this.orders) {
        sum = sum.plus(amount);
      }
      return sum;
    },
    valueSum() {
      let sum = new Decimal(0);
      for (const { amount, price } of this.orders) {
        sum = sum.plus(amount.mul(price));
      }
      return sum;
    },
    formattedValueSum() {
      return numberFormatter.decimal({
        value: this.valueSum,
        decimals: this.activeMarket.decimals.counter
      });
    },
    formattedAmountSum() {
      return numberFormatter.decimal({
        value: this.amountSum,
        decimals: this.activeMarket.decimals.base
      });
    },
    formattedAveragePrice() {
      if (this.amountSum.isZero()) {
        return "";
      }
      return numberFormatter.decimal({
        value: this.valueSum.div(this.amountSum),
        decimals: this.activeMarket.decimals.counter
      });
    },
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    }
  }
};
const _hoisted_1$5 = { class: "orderbook-tooltip__item" };
const _hoisted_2$5 = { class: "orderbook-tooltip__item" };
const _hoisted_3$4 = { class: "orderbook-tooltip__title" };
const _hoisted_4$3 = { class: "orderbook-tooltip__item" };
const _hoisted_5$2 = { class: "orderbook-tooltip__title" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["orderbook-tooltip__overlay", `orderbook-tooltip__overlay--${$props.side}`])
  }, [
    createBaseVNode("div", {
      class: "orderbook-tooltip",
      style: normalizeStyle({ transform: `translateY(calc(-50% ${$options.verticalPositionStyle}))` })
    }, [
      _cache[4] || (_cache[4] = createBaseVNode("div", { class: "orderbook-tooltip__caret" }, null, -1)),
      _cache[5] || (_cache[5] = createTextVNode()),
      createBaseVNode("div", _hoisted_1$5, [
        _cache[0] || (_cache[0] = createBaseVNode("div", { class: "orderbook-tooltip__title" }, "\n          Avg. price:\n        ", -1)),
        _cache[1] || (_cache[1] = createTextVNode()),
        createBaseVNode("div", null, "\n          ≈ " + toDisplayString($options.formattedAveragePrice), 1)
      ]),
      _cache[6] || (_cache[6] = createTextVNode()),
      createBaseVNode("div", _hoisted_2$5, [
        createBaseVNode("div", _hoisted_3$4, "\n          Sum " + toDisplayString($options.activeMarket.base) + ":\n        ", 1),
        _cache[2] || (_cache[2] = createTextVNode()),
        createBaseVNode("div", null, toDisplayString($options.formattedAmountSum), 1)
      ]),
      _cache[7] || (_cache[7] = createTextVNode()),
      createBaseVNode("div", _hoisted_4$3, [
        createBaseVNode("div", _hoisted_5$2, "\n          Sum " + toDisplayString($options.activeMarket.counter) + ":\n        ", 1),
        _cache[3] || (_cache[3] = createTextVNode()),
        createBaseVNode("div", null, toDisplayString($options.formattedValueSum), 1)
      ])
    ], 4)
  ], 2);
}
const OrderBookTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__scopeId", "data-v-d1a88af9"]]);
const SUM_DECIMALS = 2;
const ORDERBOOK_ROW_HEIGHT = 16;
const ORDERBOOK_NUM_ROWS_INC_THRESHOLD = 100;
const _sfc_main$6 = {
  name: "OrderBookData",
  components: { LabeledSwitch, AppScrollbar: _sfc_main$1g, AppTooltip, OrderBookTooltip },
  props: {
    maxStackedOrderRowsDisplayedProp: {
      type: Number,
      required: false,
      default: null
    }
  },
  setup() {
    return {
      orderbook100Store: useOrderbook100Store(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      isTooltipEnabled: useLocalStorage(
        localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ORDERBOOK.SHOW_SUM_TOOLTIP,
        true,
        { listenToStorageChanges: false }
      ),
      areTooltipsLinked: useLocalStorage(
        localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ORDERBOOK.LINKED_TOOLTIPS,
        false,
        { listenToStorageChanges: false }
      ),
      triggerAmountFillOnClick: useLocalStorage(
        localStorageConstants.LOCAL_STORAGE.TRADEVIEW_ORDERBOOK.TRIGGER_AMOUNT_FILL_ON_CLICK,
        false,
        { listenToStorageChanges: false }
      ),
      activeMarketStore: useActiveMarketStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore()
    };
  },
  data() {
    return {
      orderbook: {
        bids: [],
        asks: []
      },
      isAnimationDisabled: true,
      sumTooltip: {
        asks: {
          hovered: false,
          hoveredRow: 0,
          verticalPosition: 0
        },
        bids: {
          hovered: false,
          hoveredRow: 0,
          verticalPosition: 0
        }
      },
      orderbookSideContainerHeight: 0,
      orderbookSideInnerScrollbarHeight: {
        asks: 0,
        bids: 0
      },
      dashboardConstants: constants$2,
      constants,
      orderbookLayout: constants.ORDERBOOK.LAYOUT.STACKED,
      maxSingleOrdersRowsDisplayed: 20,
      amountSum: {
        ask: null,
        bid: null
      },
      pairValueDirection: null,
      pairValueDirectionHistoryMarket: null,
      PAIR_VALUE_UP: "up",
      PAIR_VALUE_DOWN: "down"
    };
  },
  computed: {
    throttleOrderbook() {
      return this.$minMaxThrottle(
        this.updateOrderbook,
        constants.TIMERS.ORDERBOOK.MIN_THROTTLE_FAST,
        constants.TIMERS.ORDERBOOK.MAX_THROTTLE
      );
    },
    decimals() {
      var _a2;
      return {
        base: this.activeMarketStore.activeMarket.decimals.base,
        counter: this.activeMarketStore.activeMarket.decimals.counter,
        value: ((_a2 = CURRENCIES[this.activeMarketStore.activeMarket.counter]) == null ? void 0 : _a2.decimals) ?? 2
      };
    },
    animationDuration() {
      return document.hidden ? 0 : constants.TIMERS.ORDERBOOK.ANIMATION;
    },
    userOpenOrdersPriceToSideMap() {
      const openOrderPriceToSide = {};
      for (const order of this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket) {
        if (!order.priceToFillForm) {
          continue;
        }
        openOrderPriceToSide[order.priceToFillForm.toString()] = order.side;
      }
      return openOrderPriceToSide;
    },
    displayedAsks() {
      if (this.orderbookLayout === constants.ORDERBOOK.LAYOUT.STACKED) {
        return this.orderbook.asks.slice(0, this.maxStackedOrderRowsDisplayed);
      } else {
        return this.orderbook.asks.slice(0, this.maxSingleOrdersRowsDisplayed);
      }
    },
    displayedBids() {
      if (this.orderbookLayout === constants.ORDERBOOK.LAYOUT.STACKED) {
        return this.orderbook.bids.slice(0, this.maxStackedOrderRowsDisplayed);
      } else {
        return this.orderbook.bids.slice(0, this.maxSingleOrdersRowsDisplayed);
      }
    },
    tooltipAsks() {
      return this.displayedAsks.slice(0, this.sumTooltip.asks.hoveredRow + 1);
    },
    tooltipBids() {
      return this.displayedBids.slice(0, this.sumTooltip.bids.hoveredRow + 1);
    },
    maxStackedOrderRowsDisplayed() {
      if (this.maxStackedOrderRowsDisplayedProp) {
        return this.maxStackedOrderRowsDisplayedProp;
      }
      return Math.floor(this.orderbookSideContainerHeight / ORDERBOOK_ROW_HEIGHT);
    },
    pairValue() {
      return this.tradeviewTickersStore.activeMarketTickerLastValue;
    },
    formattedPairValue() {
      if (!this.pairValue) {
        return "";
      }
      return numberFormatter.decimal({
        value: this.pairValue,
        decimals: this.decimals.counter
      });
    },
    formattedSpread() {
      var _a2, _b;
      const bestAskPrice = (_a2 = this.orderbook.asks[0]) == null ? void 0 : _a2.price;
      const bestBidPrice = (_b = this.orderbook.bids[0]) == null ? void 0 : _b.price;
      if (!bestAskPrice || !bestBidPrice || bestAskPrice.isZero()) {
        return "";
      }
      const spread = bestAskPrice.sub(bestBidPrice);
      return numberFormatter.decimal({
        value: spread.div(bestAskPrice).mul(100),
        decimals: 4
      });
    }
  },
  watch: {
    pairValue(newValue, previousValue) {
      const activeMarkeyKey = this.activeMarketStore.activeMarket.key;
      if (this.pairValueDirectionHistoryMarket && this.pairValueDirectionHistoryMarket !== activeMarkeyKey) {
        this.pairValueDirection = null;
        this.pairValueDirectionHistoryMarket = activeMarkeyKey;
        return;
      } else {
        this.pairValueDirectionHistoryMarket = activeMarkeyKey;
      }
      if (newValue && previousValue && !previousValue.isZero() && !newValue.eq(previousValue)) {
        this.pairValueDirection = newValue.gt(previousValue) ? this.PAIR_VALUE_UP : this.PAIR_VALUE_DOWN;
      }
    },
    "tradeviewPrivateOrdersStore.openOrdersForActiveMarket": {
      handler() {
        this.throttleOrderbook(this.orderbook100Store.orderbook);
        this.throttledHeightUpdater();
      },
      deep: true
    },
    "orderbook100Store.orderbook": {
      handler() {
        this.throttleOrderbook(this.orderbook100Store.orderbook);
        this.throttledHeightUpdater();
      },
      immediate: true
    },
    orderbookLayout(newLayout) {
      if (newLayout === constants.ORDERBOOK.LAYOUT.ASKS) {
        this.$nextTick(() => {
          var _a2, _b;
          const askScroller = (_b = (_a2 = this.$refs) == null ? void 0 : _a2.perfectScrollbarAsks) == null ? void 0 : _b.$el;
          if (askScroller) {
            askScroller.scrollTop = askScroller == null ? void 0 : askScroller.scrollHeight;
          }
        });
      }
      this.throttledHeightUpdater();
    },
    "tradeviewOrderFormStore.activeOrderFormType": {
      handler() {
        this.throttledHeightUpdater();
      },
      immediate: true
    }
  },
  mounted() {
    window.addEventListener("resize", this.throttledHeightUpdater);
    this.throttledHeightUpdater();
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.throttledHeightUpdater);
  },
  methods: {
    changeSelectedData({ price, sum }) {
      this.tradeviewTriggerValueStore.setPriceSetByTrigger(price);
      if (this.triggerAmountFillOnClick) {
        this.tradeviewTriggerValueStore.setAmountSetByTrigger(sum);
      }
    },
    updateOrderbook(orderbook) {
      var _a2, _b, _c, _d;
      if (this.orderbook.bids.length === 0 && orderbook.bids.length > 0 || this.orderbook.bids.length > 0 && orderbook.bids.length === 0) {
        this.isAnimationDisabled = true;
        setTimeout(() => {
          this.isAnimationDisabled = false;
        }, constants.TIMERS.ORDERBOOK.ANIMATION * 2);
      } else if ((_b = (_a2 = this.$refs) == null ? void 0 : _a2.perfectScrollbarAsks) == null ? void 0 : _b.ps) {
        this.$refs.perfectScrollbarAsks.ps.isAlive = false;
      } else if ((_d = (_c = this.$refs) == null ? void 0 : _c.perfectScrollbarBids) == null ? void 0 : _d.ps) {
        this.$refs.perfectScrollbarBids.ps.isAlive = false;
      }
      const formattedBids = this.formatOrders(orderbook.bids, constants$2.ORDERBOOK.SIDES.BIDS, this.decimals);
      const formattedAsks = this.formatOrders(orderbook.asks, constants$2.ORDERBOOK.SIDES.ASKS, this.decimals);
      requestAnimationFrame(() => {
        this.orderbook = Object.freeze({
          bids: formattedBids,
          asks: formattedAsks
        });
        requestAnimationFrame(() => {
          var _a3, _b2, _c2, _d2;
          if (((_b2 = (_a3 = this.$refs) == null ? void 0 : _a3.asksOrderbook) == null ? void 0 : _b2.children) > 0) {
            this.$refs.perfectScrollbarAsks.ps.isAlive = true;
          }
          if (((_d2 = (_c2 = this.$refs) == null ? void 0 : _c2.bidsOrderbook) == null ? void 0 : _d2.children) > 0) {
            this.$refs.perfectScrollbarBids.ps.isAlive = true;
          }
        });
      });
    },
    formatOrders(orderbook, orderbookSide, decimals = { base: 8, counter: 2, value: 2 }) {
      const totalBaseAmount = new Decimal(orderbook.length > 0 ? orderbook[orderbook.length - 1].sum : 1);
      return orderbook.map((order) => {
        const amount = new Decimal(order.amount);
        const sum = new Decimal(order.sum);
        const optimizedAmountDecimals = amount.gte(1e6) ? 2 : 5;
        const decimalsForAmount = amount.gte(1e3) && decimals.base > optimizedAmountDecimals ? optimizedAmountDecimals : decimals.base;
        const significantDecimals = amount.decimalPlaces();
        const nonZero = numberFormatter.amount({
          value: amount,
          decimals: Math.min(significantDecimals, decimalsForAmount)
        });
        const isLessThan1k = sum.lessThan(1e3);
        let sumFormatted;
        for (const [factor, suffix] of constants.UNIT_GROUPS) {
          if (isLessThan1k || sum.greaterThanOrEqualTo(factor)) {
            sumFormatted = {
              value: isLessThan1k ? sum.toFixed(SUM_DECIMALS) : sum.div(factor).toFixed(SUM_DECIMALS),
              suffix: isLessThan1k ? "" : suffix
            };
            break;
          }
        }
        const counterRounding = orderbookSide === constants$2.ORDERBOOK.SIDES.ASKS ? constants$2.ORDERBOOK.ROUNDING.ASKS : constants$2.ORDERBOOK.ROUNDING.BIDS;
        const groupedAmount = numberFormatter.groupedPrice({
          value: amount,
          decimals: 3,
          spacer: " "
        });
        const split = groupedAmount.split(" ");
        const groupedAmountNumber = split[0];
        const groupedAmountSuffix = split[1];
        const userOpenOrderSide = this.userOpenOrdersPriceToSideMap[order.price.toString()];
        return {
          percentageOfBook: totalBaseAmount.isPositive() ? sum.div(totalBaseAmount).mul(100) : new Decimal(0),
          price: new Decimal(order.price),
          priceFormatted: numberFormatter.decimal({
            value: order.price,
            decimals: decimals.counter,
            rounding: counterRounding
          }),
          amount,
          sum,
          sumFormatted,
          amountFormatted: {
            nonZero: significantDecimals < 1 && decimalsForAmount > 0 ? `${nonZero}.` : nonZero,
            padding: decimalsForAmount - significantDecimals < 0 ? "" : "0".repeat(decimalsForAmount - significantDecimals)
          },
          useGroupedAmount: amount.gte(1e11),
          groupedAmountNumber,
          groupedAmountSuffix,
          valueFormatted: numberFormatter.decimal({
            value: order.value,
            decimals: decimals.value,
            rounding: counterRounding
          }),
          isOpenBuyOrder: userOpenOrderSide === constants$1.ORDER_SIDE.BUY,
          isOpenSellOrder: userOpenOrderSide === constants$1.ORDER_SIDE.SELL
        };
      });
    },
    isRowInTooltip(isSideHovered, hoveredRow, row) {
      return isSideHovered && hoveredRow >= row;
    },
    setHoveredRow(side, row) {
      var _a2, _b;
      if (!this.isTooltipEnabled) {
        return;
      }
      let rowsScrollingOffset = 0;
      if (this.orderbookLayout !== constants.ORDERBOOK.LAYOUT.STACKED) {
        const orderbookBoundingRect = (_a2 = this.$refs[`${this.orderbookLayout}Orderbook`]) == null ? void 0 : _a2.getBoundingClientRect();
        const scrollbarInnerBoundingRect = (_b = this.$refs[`${this.orderbookLayout}ScrollbarInner`]) == null ? void 0 : _b.getBoundingClientRect();
        if (this.orderbookLayout === constants.ORDERBOOK.LAYOUT.ASKS) {
          rowsScrollingOffset = scrollbarInnerBoundingRect.height - orderbookBoundingRect.bottom + scrollbarInnerBoundingRect.top;
        } else {
          rowsScrollingOffset = scrollbarInnerBoundingRect.height + orderbookBoundingRect.top - scrollbarInnerBoundingRect.bottom;
        }
      }
      this.sumTooltip[side].hovered = true;
      this.sumTooltip[side].hoveredRow = row;
      this.sumTooltip[side].verticalPosition = (row + 1) * ORDERBOOK_ROW_HEIGHT - rowsScrollingOffset;
      if (!this.areTooltipsLinked || this.orderbookLayout !== constants.ORDERBOOK.LAYOUT.STACKED) {
        return;
      }
      const otherSide = side === constants.ORDERBOOK.SIDES.ASKS ? constants.ORDERBOOK.SIDES.BIDS : constants.ORDERBOOK.SIDES.ASKS;
      if (this.orderbook[otherSide].length === 0) {
        return;
      }
      this.heightUpdater();
      const verticalPosition = (row + 1) * ORDERBOOK_ROW_HEIGHT;
      const maxVerticalPositionOtherSide = this.orderbookSideInnerScrollbarHeight[otherSide];
      const otherSideRow = verticalPosition > maxVerticalPositionOtherSide ? this.orderbook[otherSide].length - 1 : row;
      this.sumTooltip[otherSide].verticalPosition = (otherSideRow + 1) * ORDERBOOK_ROW_HEIGHT;
      this.sumTooltip[otherSide].hoveredRow = otherSideRow;
      this.sumTooltip[otherSide].hovered = true;
    },
    throttledHeightUpdater: _.throttle(function() {
      this.$nextTick(() => {
        this.heightUpdater();
      });
    }, 250),
    heightUpdater() {
      var _a2, _b, _c;
      this.orderbookSideContainerHeight = ((_a2 = this.$refs.asksOrderbook) == null ? void 0 : _a2.offsetHeight) ?? 0;
      this.orderbookSideInnerScrollbarHeight.asks = ((_b = this.$refs.asksScrollbarInner) == null ? void 0 : _b.offsetHeight) ?? 0;
      this.orderbookSideInnerScrollbarHeight.bids = ((_c = this.$refs.bidsScrollbarInner) == null ? void 0 : _c.offsetHeight) ?? 0;
    },
    onScrolledToBottom(side) {
      var _a2, _b, _c;
      if (((_c = (_b = (_a2 = this.$refs[`${side}OrderbookTransition`]) == null ? void 0 : _a2.$el) == null ? void 0 : _b.children) == null ? void 0 : _c.length) > 0 && this.maxSingleOrdersRowsDisplayed < ORDERBOOK_NUM_ROWS_INC_THRESHOLD) {
        requestAnimationFrame(() => {
          this.maxSingleOrdersRowsDisplayed += this.maxSingleOrdersRowsDisplayed;
        });
      }
    },
    hideTooltips() {
      this.sumTooltip.bids.hovered = false;
      this.sumTooltip.asks.hovered = false;
    }
  }
};
const _hoisted_1$4 = { class: "orderbook-data" };
const _hoisted_2$4 = { class: "orderbook-controls" };
const _hoisted_3$3 = { class: "orderbook-controls-layout" };
const _hoisted_4$2 = { class: "orderbook-body__container" };
const _hoisted_5$1 = {
  key: 0,
  ref: "asksOrderbook",
  class: "orderbook-body__side orderbook-body__side--asks"
};
const _hoisted_6$1 = { ref: "asksScrollbarInner" };
const _hoisted_7 = ["onClick", "onMouseover"];
const _hoisted_8 = {
  class: "orderbook-table__cell orderbook-row__ask-ask",
  "data-test": "orderbookAskAsk"
};
const _hoisted_9 = {
  class: "orderbook-table__cell orderbook-row__ask-amount",
  "data-test": "orderbookAskAmount"
};
const _hoisted_10 = { class: "group-suffix" };
const _hoisted_11 = { class: "filter-fixed-length" };
const _hoisted_12 = {
  class: "orderbook-table__cell orderbook-row__ask-value orderbook-table__cell--value",
  "data-test": "orderbookAskValue"
};
const _hoisted_13 = { class: "orderbook-table__cell orderbook-row__ask-volume" };
const _hoisted_14 = { class: "price-bar__container" };
const _hoisted_15 = {
  key: 1,
  class: "price-bar__last-trade price-bar__last-trade--empty"
};
const _hoisted_16 = {
  key: 2,
  class: "price-bar__spread",
  "test-id": "orderbookSpread"
};
const _hoisted_17 = {
  key: 3,
  class: "price-bar__spread price-bar__spread--empty"
};
const _hoisted_18 = {
  key: 1,
  ref: "bidsOrderbook",
  class: "orderbook-body__side orderbook-body__side--bids"
};
const _hoisted_19 = { ref: "bidsScrollbarInner" };
const _hoisted_20 = ["onClick", "onMouseover"];
const _hoisted_21 = {
  class: "orderbook-table__cell orderbook-row__bid-bid",
  "data-test": "orderbookBidBid"
};
const _hoisted_22 = {
  class: "orderbook-table__cell orderbook-row__bid-amount",
  "data-test": "orderbookBidAmount"
};
const _hoisted_23 = { class: "group-suffix" };
const _hoisted_24 = { class: "filter-fixed-length" };
const _hoisted_25 = {
  class: "orderbook-table__cell orderbook-row__bid-value orderbook-table__cell--value",
  "data-test": "orderbookBidValue"
};
const _hoisted_26 = { class: "orderbook-table__cell orderbook-row__bid-volume" };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabeledSwitch = resolveComponent("LabeledSwitch");
  const _component_AppTooltip = resolveComponent("AppTooltip");
  const _component_AppScrollbar = resolveComponent("AppScrollbar");
  const _component_OrderBookTooltip = resolveComponent("OrderBookTooltip");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createBaseVNode("div", _hoisted_2$4, [
      createBaseVNode("div", _hoisted_3$3, [
        createBaseVNode("div", {
          class: normalizeClass(["orderbook-controls-layout__option orderbook-controls-layout__option--stacked", { "orderbook-controls-layout__option--active": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED }]),
          "test-id": "orderbookLayoutStacked",
          title: "Order Book",
          onClick: _cache[0] || (_cache[0] = ($event) => $data.orderbookLayout = $data.constants.ORDERBOOK.LAYOUT.STACKED)
        }, _cache[10] || (_cache[10] = [
          createBaseVNode("div", { class: "orderbook-controls-layout__icon orderbook-controls-layout__icon--asks" }, null, -1),
          createTextVNode(),
          createBaseVNode("div", { class: "orderbook-controls-layout__icon orderbook-controls-layout__icon--bids" }, null, -1)
        ]), 2),
        _cache[13] || (_cache[13] = createTextVNode()),
        createBaseVNode("div", {
          class: normalizeClass(["orderbook-controls-layout__option orderbook-controls-layout__option--single", { "orderbook-controls-layout__option--active": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.BIDS }]),
          "test-id": "orderbookLayoutBids",
          title: "Bids",
          onClick: _cache[1] || (_cache[1] = ($event) => $data.orderbookLayout = $data.constants.ORDERBOOK.LAYOUT.BIDS)
        }, _cache[11] || (_cache[11] = [
          createBaseVNode("div", { class: "orderbook-controls-layout__icon orderbook-controls-layout__icon--bids" }, null, -1)
        ]), 2),
        _cache[14] || (_cache[14] = createTextVNode()),
        createBaseVNode("div", {
          class: normalizeClass(["orderbook-controls-layout__option orderbook-controls-layout__option--single", { "orderbook-controls-layout__option--active": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.ASKS }]),
          "test-id": "orderbookLayoutAsks",
          title: "Asks",
          onClick: _cache[2] || (_cache[2] = ($event) => $data.orderbookLayout = $data.constants.ORDERBOOK.LAYOUT.ASKS)
        }, _cache[12] || (_cache[12] = [
          createBaseVNode("div", { class: "orderbook-controls-layout__icon orderbook-controls-layout__icon--asks" }, null, -1)
        ]), 2)
      ]),
      _cache[17] || (_cache[17] = createTextVNode()),
      createVNode(_component_AppTooltip, {
        class: "orderbook-controls__settings",
        "icon-size": 16,
        icon: "monochrome/sliders.svg",
        distance: 8,
        placement: "bottom",
        strategy: "fixed",
        type: "dropdown"
      }, {
        default: withCtx(() => [
          createVNode(_component_LabeledSwitch, {
            value: $setup.isTooltipEnabled,
            "onUpdate:value": _cache[3] || (_cache[3] = ($event) => $setup.isTooltipEnabled = $event),
            label: "Display sum tooltip",
            "test-id": "toggleOrderbookEnableTooltip",
            compact: ""
          }, null, 8, ["value"]),
          _cache[15] || (_cache[15] = createTextVNode()),
          createVNode(_component_LabeledSwitch, {
            value: $setup.areTooltipsLinked,
            "onUpdate:value": _cache[4] || (_cache[4] = ($event) => $setup.areTooltipsLinked = $event),
            disabled: $data.orderbookLayout !== $data.constants.ORDERBOOK.LAYOUT.STACKED || !$setup.isTooltipEnabled,
            label: "Two sided sum tooltip",
            "test-id": "toggleOrderbookLinkTooltips",
            compact: ""
          }, null, 8, ["value", "disabled"]),
          _cache[16] || (_cache[16] = createTextVNode()),
          createVNode(_component_LabeledSwitch, {
            value: $setup.triggerAmountFillOnClick,
            "onUpdate:value": _cache[5] || (_cache[5] = ($event) => $setup.triggerAmountFillOnClick = $event),
            label: "Fill sum amount on click",
            "test-id": "toggleOrderbookFillAmountOnClick",
            compact: ""
          }, null, 8, ["value"])
        ]),
        _: 1
      })
    ]),
    _cache[34] || (_cache[34] = createStaticVNode(' <div class="orderbook-header" data-v-01ab6ab8><div class="orderbook-header--asks" data-v-01ab6ab8><span class="orderbook-table__cell orderbook-table__cell--ask" data-v-01ab6ab8>Price</span> <span class="orderbook-table__cell orderbook-table__cell--amount" data-v-01ab6ab8>Amount</span> <span class="orderbook-table__cell orderbook-table__cell--value" data-v-01ab6ab8>Value</span></div></div> ', 3)),
    createBaseVNode("div", {
      class: normalizeClass(["orderbook-body", {
        "orderbook-body--stacked": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED,
        "orderbook-body--single": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.ASKS,
        "orderbook-body--tooltip-disabled": !$setup.isTooltipEnabled
      }]),
      "data-test": "orderbookDataBody"
    }, [
      createBaseVNode("div", _hoisted_4$2, [
        $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED || $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.ASKS ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
          createVNode(_component_AppScrollbar, {
            ref: "perfectScrollbarAsks",
            disabled: $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED,
            onYEndReached: _cache[7] || (_cache[7] = ($event) => $options.onScrolledToBottom($data.dashboardConstants.ORDERBOOK.SIDES.ASKS))
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_6$1, [
                createVNode(TransitionGroup, {
                  ref: "asksOrderbookTransition",
                  name: `${$data.isAnimationDisabled ? "" : "list"}`,
                  duration: $options.animationDuration,
                  class: "ob-asks",
                  tag: "div"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.displayedAsks, (ask, row) => {
                      return openBlock(), createElementBlock("div", {
                        ref_for: true,
                        ref: "orderbookAsksRow",
                        key: ask.price.toString(),
                        class: normalizeClass([{
                          "orderbook-row--order orderbook-row--order-buy": ask.isOpenBuyOrder,
                          "orderbook-row--order orderbook-row--order-sell": ask.isOpenSellOrder,
                          "orderbook-row--in-tooltip": $options.isRowInTooltip($data.sumTooltip.asks.hovered, $data.sumTooltip.asks.hoveredRow, row),
                          "orderbook-row--hovered": row === $data.sumTooltip.asks.hoveredRow && $data.sumTooltip.asks.hovered
                        }, "orderbook-row orderbook-row--asks"]),
                        "data-test": "orderbookAskRow",
                        onClick: ($event) => $options.changeSelectedData(ask),
                        onMouseleave: _cache[6] || (_cache[6] = (...args) => $options.hideTooltips && $options.hideTooltips(...args)),
                        onMouseover: ($event) => $options.setHoveredRow($data.dashboardConstants.ORDERBOOK.SIDES.ASKS, row)
                      }, [
                        _cache[18] || (_cache[18] = createBaseVNode("div", { class: "orderbook-table__overlay" }, null, -1)),
                        _cache[19] || (_cache[19] = createTextVNode()),
                        createBaseVNode("span", _hoisted_8, toDisplayString(ask.priceFormatted), 1),
                        _cache[20] || (_cache[20] = createTextVNode()),
                        createBaseVNode("span", _hoisted_9, [
                          ask.useGroupedAmount && ask.groupedAmountSuffix ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(ask.groupedAmountNumber) + " ", 1),
                            createBaseVNode("span", _hoisted_10, toDisplayString(ask.groupedAmountSuffix), 1)
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(ask.amountFormatted.nonZero), 1),
                            createBaseVNode("span", _hoisted_11, toDisplayString(ask.amountFormatted.padding), 1)
                          ], 64))
                        ]),
                        _cache[21] || (_cache[21] = createTextVNode()),
                        createBaseVNode("span", _hoisted_12, toDisplayString(ask.valueFormatted), 1),
                        _cache[22] || (_cache[22] = createTextVNode()),
                        createBaseVNode("span", _hoisted_13, [
                          createBaseVNode("span", {
                            style: normalizeStyle({ width: ask.percentageOfBook.toFixed(2) + "%" }),
                            class: "orderbook-ask-volume"
                          }, null, 4)
                        ])
                      ], 42, _hoisted_7);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["name", "duration"])
              ], 512)
            ]),
            _: 1
          }, 8, ["disabled"]),
          _cache[23] || (_cache[23] = createTextVNode()),
          $data.sumTooltip.asks.hovered && $setup.isTooltipEnabled ? (openBlock(), createBlock(_component_OrderBookTooltip, {
            key: 0,
            side: $data.dashboardConstants.ORDERBOOK.SIDES.ASKS,
            "vertical-position": $data.sumTooltip.asks.verticalPosition,
            orders: $options.tooltipAsks
          }, null, 8, ["side", "vertical-position", "orders"])) : createCommentVNode("", true)
        ], 512)) : createCommentVNode("", true),
        _cache[32] || (_cache[32] = createTextVNode()),
        createBaseVNode("div", _hoisted_14, [
          createBaseVNode("div", {
            class: normalizeClass(["price-bar", {
              "price-bar--stacked": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED,
              "price-bar--asks": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.ASKS,
              "price-bar--bids": $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.BIDS
            }])
          }, [
            $options.formattedPairValue ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(["price-bar__last-trade", {
                "price-bar__last-trade--up": $data.pairValueDirection === $data.PAIR_VALUE_UP,
                "price-bar__last-trade--down": $data.pairValueDirection === $data.PAIR_VALUE_DOWN
              }]),
              "test-id": "orderbookLastPrice"
            }, [
              createTextVNode(toDisplayString($options.formattedPairValue) + " ", 1),
              $data.pairValueDirection !== null ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(["price-bar__trend-arrow", {
                  "price-bar__trend-arrow--up": $data.pairValueDirection === $data.PAIR_VALUE_UP,
                  "price-bar__trend-arrow--down": $data.pairValueDirection === $data.PAIR_VALUE_DOWN
                }])
              }, null, 2)) : createCommentVNode("", true)
            ], 2)) : (openBlock(), createElementBlock("div", _hoisted_15)),
            _cache[25] || (_cache[25] = createTextVNode()),
            $options.formattedSpread ? (openBlock(), createElementBlock("span", _hoisted_16, [
              _cache[24] || (_cache[24] = createBaseVNode("span", { class: "price-bar__spread-label" }, "spread:", -1)),
              createTextVNode(" " + toDisplayString($options.formattedSpread) + "%\n            ", 1)
            ])) : (openBlock(), createElementBlock("div", _hoisted_17))
          ], 2)
        ]),
        _cache[33] || (_cache[33] = createTextVNode()),
        $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED || $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.BIDS ? (openBlock(), createElementBlock("div", _hoisted_18, [
          createVNode(_component_AppScrollbar, {
            ref: "perfectScrollbarBids",
            disabled: $data.orderbookLayout === $data.constants.ORDERBOOK.LAYOUT.STACKED,
            onYEndReached: _cache[9] || (_cache[9] = ($event) => $options.onScrolledToBottom($data.dashboardConstants.ORDERBOOK.SIDES.BIDS))
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_19, [
                createVNode(TransitionGroup, {
                  ref: "bidsOrderbookTransition",
                  name: `${$data.isAnimationDisabled ? "" : "list"}`,
                  duration: $options.animationDuration,
                  class: "ob-bids",
                  tag: "div"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.displayedBids, (bid, row) => {
                      return openBlock(), createElementBlock("div", {
                        key: bid.price.toString(),
                        class: normalizeClass([{
                          "orderbook-row--order orderbook-row--order-buy": bid.isOpenBuyOrder,
                          "orderbook-row--order orderbook-row--order-sell": bid.isOpenSellOrder,
                          "orderbook-row--in-tooltip": $options.isRowInTooltip($data.sumTooltip.bids.hovered, $data.sumTooltip.bids.hoveredRow, row),
                          "orderbook-row--hovered": row === $data.sumTooltip.bids.hoveredRow && $data.sumTooltip.bids.hovered
                        }, "orderbook-row orderbook-row--bids"]),
                        "data-test": "orderbookBidRow",
                        onClick: ($event) => $options.changeSelectedData(bid),
                        onMouseleave: _cache[8] || (_cache[8] = (...args) => $options.hideTooltips && $options.hideTooltips(...args)),
                        onMouseover: ($event) => $options.setHoveredRow($data.dashboardConstants.ORDERBOOK.SIDES.BIDS, row)
                      }, [
                        _cache[26] || (_cache[26] = createBaseVNode("div", { class: "orderbook-table__overlay" }, null, -1)),
                        _cache[27] || (_cache[27] = createTextVNode()),
                        createBaseVNode("span", _hoisted_21, toDisplayString(bid.priceFormatted), 1),
                        _cache[28] || (_cache[28] = createTextVNode()),
                        createBaseVNode("span", _hoisted_22, [
                          bid.useGroupedAmount && bid.groupedAmountSuffix ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(bid.groupedAmountNumber) + " ", 1),
                            createBaseVNode("span", _hoisted_23, toDisplayString(bid.groupedAmountSuffix), 1)
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(bid.amountFormatted.nonZero), 1),
                            createBaseVNode("span", _hoisted_24, toDisplayString(bid.amountFormatted.padding), 1)
                          ], 64))
                        ]),
                        _cache[29] || (_cache[29] = createTextVNode()),
                        createBaseVNode("span", _hoisted_25, toDisplayString(bid.valueFormatted), 1),
                        _cache[30] || (_cache[30] = createTextVNode()),
                        createBaseVNode("span", _hoisted_26, [
                          createBaseVNode("span", {
                            style: normalizeStyle({ width: bid.percentageOfBook.toFixed(2) + "%" }),
                            class: "orderbook-bid-volume"
                          }, null, 4)
                        ])
                      ], 42, _hoisted_20);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["name", "duration"])
              ], 512)
            ]),
            _: 1
          }, 8, ["disabled"]),
          _cache[31] || (_cache[31] = createTextVNode()),
          $data.sumTooltip.bids.hovered && $setup.isTooltipEnabled ? (openBlock(), createBlock(_component_OrderBookTooltip, {
            key: 0,
            side: $data.dashboardConstants.ORDERBOOK.SIDES.BIDS,
            "vertical-position": $data.sumTooltip.bids.verticalPosition,
            orders: $options.tooltipBids
          }, null, 8, ["side", "vertical-position", "orders"])) : createCommentVNode("", true)
        ], 512)) : createCommentVNode("", true)
      ])
    ], 2)
  ]);
}
const OrderBookData = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5], ["__scopeId", "data-v-01ab6ab8"]]);
const initHighChart = ({ clickEvent, setExtremesEvent }) => ({
  chart: {
    type: "area",
    inverted: true,
    size: "100%",
    backgroundColor: "transparent",
    animation: false,
    zoomType: "x",
    spacingLeft: 0,
    spacingRight: 8,
    spacingTop: 0,
    spacingBottom: 0,
    style: {
      fontFamily: "var(--default-font-family)"
    },
    resetZoomButton: {
      position: {
        align: "left",
        verticalAlign: "top",
        y: 32,
        x: 8
      },
      theme: {
        r: 5,
        height: 11,
        style: {
          textAlign: "center"
        }
      }
    },
    events: {
      click: clickEvent
    }
  },
  title: {
    text: ""
  },
  credits: {
    enabled: false
  },
  tooltip: {
    borderRadius: 5,
    borderWidth: 0,
    shadow: false,
    valueDecimals: 2,
    padding: 6,
    useHTML: true,
    headerFormat: `
      <span class="highcharts-tooltip__price"><span
        class="highcharts-tooltip__circle"
        style="color:{point.color}">●</span>{point.key}</span><br/>
    `,
    pointFormat: '<span class="highcharts-tooltip__name">{series.name}: </span><span class="highcharts-tooltip__base-sum">{point.y}</span>'
  },
  xAxis: {
    reversed: false,
    opposite: true,
    lineWidth: 1,
    minorGridLineWidth: 0,
    gridLineWidth: 1,
    minorTickLength: 1,
    tickLength: 4,
    gridZIndex: -1,
    title: {
      enabled: false
    },
    labels: {
      y: 4,
      x: 8,
      style: {
        fontSize: "10px"
      }
    },
    crosshair: {
      width: 1,
      color: "var(--bts-tv-depth-chart-selected-price-line-color)",
      dashStyle: "dot"
    },
    events: {
      setExtremes: setExtremesEvent
    }
  },
  yAxis: {
    lineColor: "transparent",
    lineWidth: 0,
    minorGridLineWidth: 0,
    minorTickLength: 0,
    tickLength: 0,
    title: {
      enabled: false
    },
    labels: {
      enabled: false
    },
    visible: false
  },
  plotOptions: {
    series: {
      lineWidth: 1,
      animation: false,
      marker: {
        symbol: "circle",
        radius: 2,
        lineColor: "transparent"
      },
      states: {
        inactive: {
          opacity: 0.85
        },
        hover: {
          halo: {
            size: 0
          }
        }
      }
    },
    line: {
      dashStyle: "dash",
      allowPointSelect: false,
      marker: {
        enabled: false
      }
    }
  },
  legend: {
    enabled: false
  },
  series: [
    {
      type: "area",
      name: "Bids",
      color: "var(--chart-positive-color)",
      fillColor: "var(--chart-positive-fill)",
      point: {
        events: {
          click: clickEvent
        }
      },
      marker: {
        enabled: false
      }
    },
    {
      type: "area",
      name: "Asks",
      color: "var(--chart-negative-color)",
      fillColor: "var(--chart-negative-fill)",
      point: {
        events: {
          click: clickEvent
        }
      },
      marker: {
        enabled: false
      }
    }
  ],
  accessibility: {
    enabled: false
  }
});
function mergeOrderbookWithDiff(orderbook, orderbookDiff, type = "bids") {
  const isAscending = type !== "bids";
  const addOrderToSum = (sum, order) => isAscending ? order.amount + sum : order.amount * order.price + sum;
  const newOrderbook = [];
  let sumDiff = 0;
  orderbook = orderbook.map(({ price, amount }) => ({ price, amount }));
  orderbookDiff = orderbookDiff.map(({ price, amount }) => ({ price, amount }));
  const comparison = isAscending ? -1 : 1;
  while (orderbookDiff[0] && orderbook[0] && comparison * (orderbookDiff[0].price - orderbook[0].price) > 0) {
    const diffHead = orderbookDiff.shift();
    if (diffHead.amount > 0) {
      sumDiff = addOrderToSum(sumDiff, diffHead);
      newOrderbook.push(diffHead);
    }
  }
  orderbook.forEach((order) => {
    while (orderbookDiff[0] && comparison * (orderbookDiff[0].price - order.price) > 0) {
      const diffHead = orderbookDiff.shift();
      if (diffHead.amount > 0) {
        sumDiff = addOrderToSum(sumDiff, diffHead);
        newOrderbook.push(diffHead);
      }
    }
    if (orderbookDiff[0] && orderbookDiff[0].price === order.price) {
      sumDiff = addOrderToSum(sumDiff, { price: order.price, amount: orderbookDiff[0].amount - order.amount });
      order.amount = orderbookDiff[0].amount;
      orderbookDiff.shift();
      if (order.amount > 0) {
        newOrderbook.push(order);
      }
    } else {
      newOrderbook.push(order);
    }
  });
  while (orderbookDiff[0] && orderbookDiff[0].price > 0) {
    sumDiff = addOrderToSum(sumDiff, orderbookDiff[0]);
    newOrderbook.push(orderbookDiff.shift());
  }
  return { orderbook: newOrderbook, sumDiff };
}
class OrderBookDiffQueue {
  constructor() {
    __publicField(this, "ORDERBOOK_TYPES", ["asks", "bids"]);
    // TODO: See if this should be higher when deployed against Incapsula
    __publicField(this, "FULL_ORDERBOOK_CACHE_THRESHOLD", 5);
    // seconds
    __publicField(this, "MAX_QUEUE_SIZE", 5e3);
    this.queue = [];
    this._initDiff();
    this.hasDoneInitialSyncReload = false;
    this.isFullOrderbookRequestPending = false;
    this.hasQueueOverflowed = false;
    this.lastAppliedDiffMicroTimestamp = 0;
  }
  _initDiff() {
    this.diff = {
      asks: [],
      bids: []
    };
  }
  _sortDiff() {
    for (const book of this.ORDERBOOK_TYPES) {
      const direction = book === "asks" ? 1 : -1;
      this.diff[book].sort((a, b) => direction * (a.price - b.price));
    }
  }
  /**
   * During initial load we can miss some diffs, especially due to Orderbook API responses
   * being cached by Incapsula for ~5 seconds.
   * So we try to sync by requesting a secondary API response after we've gathered some Websocket diffs.
   *
   * @param fullUpdateTimestamp
   * @returns {boolean}
   */
  isFullOrderbookSyncRequired(fullUpdateTimestamp) {
    if (this.queue.length < 1) {
      return false;
    }
    const thresholdReached = _.last(this.queue).timestamp - fullUpdateTimestamp > this.FULL_ORDERBOOK_CACHE_THRESHOLD;
    return !this.hasDoneInitialSyncReload && thresholdReached && !this.isFullOrderbookRequestPending;
  }
  /**
   * We expect this to return true when a diff has not been applied for a long time, for instance when
   * a device / TV 'wakes up' or when we've been running as a background tab for a long time
   * without doing a polled refresh.
   *
   * @returns {boolean}
   */
  isFullOrderbookRefreshRequired() {
    if (this.lastAppliedDiffMicroTimestamp && Date.now() * 1e3 - this.lastAppliedDiffMicroTimestamp > constants.TIMERS.POLLING_ORDERBOOK.TIME * 1e6) {
      return true;
    }
    return this.hasQueueOverflowed;
  }
  addDiff(diff) {
    if (this.queue.length >= this.MAX_QUEUE_SIZE) {
      if (this.queue[0].microtimestamp > this.lastAppliedDiffMicroTimestamp) {
        this.hasQueueOverflowed = true;
        this.queue = [];
      } else {
        let i = this.queue.length - 1;
        const oldestTimeToKeep = this.lastAppliedDiffMicroTimestamp - this.FULL_ORDERBOOK_CACHE_THRESHOLD * 1e6;
        while (i > -1 && this.queue[i].microtimestamp > oldestTimeToKeep) {
          i--;
        }
        this.queue = this.queue.slice(i);
      }
    }
    this.queue.push(diff);
  }
  fullOrderbookStartedLoading() {
    this.hasQueueOverflowed = false;
    this.isFullOrderbookRequestPending = true;
  }
  fullOrderbookHasFinishedLoading(success = true, isInitialResync = false) {
    this.isFullOrderbookRequestPending = false;
    if (success) {
      if (isInitialResync) {
        this.hasDoneInitialSyncReload = true;
      }
      this.lastAppliedDiffMicroTimestamp = 0;
    }
  }
  /**
   * Merge queued diffs into a single diff
   *
   * @param fullOrderbookTimestamp
   * @returns {boolean}
   */
  processQueue(fullOrderbookTimestamp) {
    if (this.queue.length < 1) {
      return true;
    }
    this._initDiff();
    let i = this.queue.length - 1;
    let startAt = -1;
    while (i >= 0 && // NOTE: Maybe this check should be >=, seeing as how we have sub-second diff broadcasts on some pairs
    this.queue[i].timestamp > fullOrderbookTimestamp && this.queue[i].microtimestamp > this.lastAppliedDiffMicroTimestamp) {
      startAt = i;
      i--;
    }
    let lastProcessedMicroTimestamp = null;
    for (let i2 = startAt; i2 >= 0 && i2 < this.queue.length; i2++) {
      this._processDiff(this.queue[i2]);
      lastProcessedMicroTimestamp = this.queue[i2].microtimestamp;
    }
    if (lastProcessedMicroTimestamp) {
      this.lastAppliedDiffMicroTimestamp = lastProcessedMicroTimestamp;
    }
    this._sortDiff();
  }
  _processDiff(diff) {
    let priceIndex;
    for (const book of this.ORDERBOOK_TYPES) {
      for (let i = 0; i < diff[book].length; i++) {
        priceIndex = this.diff[book].findIndex((queuedOrder) => queuedOrder.price === diff[book][i].price);
        if (priceIndex > -1) {
          this.diff[book][priceIndex].amount = diff[book][i].amount;
        } else {
          this.diff[book].push(diff[book][i]);
        }
      }
    }
  }
  get bids() {
    return this.diff.bids;
  }
  get asks() {
    return this.diff.asks;
  }
}
const utils = {
  OrderBookDiffQueue,
  mergeOrderbookWithDiff
};
const storeName = "tradeviewDepthChartStore";
const useTradeviewDepthChartStore = addStoreHooks(
  defineStore(storeName, () => {
    const toastStore = useToastStore({ caller: storeName });
    const pollingStore = usePollingStore({ caller: storeName });
    const activeMarketStore = useActiveMarketStore({ caller: storeName });
    const { activeMarket } = storeToRefs(useActiveMarketStore({ caller: storeName }));
    const orderbook100Store = useOrderbook100Store({ caller: storeName });
    const { fullOrderbookFromLastApiCall, initialized: isOrderbookStoreInitialized } = storeToRefs(
      useOrderbook100Store({ caller: storeName })
    );
    const websocketsStore = useWebsocketStore({ caller: storeName });
    const { initialized: wsInitialized } = storeToRefs(useWebsocketStore({ caller: storeName }));
    const visibilityStore = useVisibilityStore({ caller: storeName });
    let disconnectOrderbookDiffWsFn = () => {
    };
    let stopPollingFullOrderbookFn = () => {
    };
    let _diffQueue = new utils.OrderBookDiffQueue();
    let throttledDiffQueueDispatch = null;
    const initialized = ref(false);
    const lastFullUpdateTime = ref(null);
    const orderbook = shallowRef({
      bids: [],
      asks: []
    });
    const sum = shallowRef({
      bids: 0,
      asks: 0
    });
    const connectedWsChannel = ref(null);
    const isSwitchingMarket = ref(false);
    function setOrderbook({ asks, bids }) {
      orderbook.value = { asks, bids };
    }
    function setSum(newSum) {
      sum.value = newSum;
    }
    async function loadFullOrderbook(isInitialResync = false, doApiCall = true) {
      _diffQueue.fullOrderbookStartedLoading();
      if (!activeMarketStore.activeMarketKey) {
        return false;
      }
      const activeMarketBeforeFetch = activeMarketStore.activeMarketKey;
      let orderbook2;
      try {
        if (doApiCall) {
          orderbook2 = await orderbook100Store.fetchActiveMarketFullOrderbook();
        } else {
          orderbook2 = orderbook100Store.fullOrderbookFromLastApiCall;
        }
        if (activeMarketStore.activeMarketKey !== activeMarketBeforeFetch) {
          return false;
        }
        _diffQueue.fullOrderbookHasFinishedLoading(true, isInitialResync);
      } catch (e) {
        toastStore.showNetworkError();
        _diffQueue.fullOrderbookHasFinishedLoading(false, isInitialResync);
        return false;
      }
      updateOrderbook(orderbook2);
      lastFullUpdateTime.value = orderbook2.timestamp;
    }
    function resetDiffSync() {
      _diffQueue = new utils.OrderBookDiffQueue();
      lastFullUpdateTime.value = null;
    }
    function updateOrderbook(orderbook2) {
      let newSum;
      if (!orderbook2.sumDiff) {
        let sumAsks = 0;
        let sumBids = 0;
        let i = orderbook2.asks.length;
        while (i--) {
          sumAsks += orderbook2.asks[i].amount;
        }
        i = orderbook2.bids.length;
        while (i--) {
          sumBids += orderbook2.bids[i].amount * orderbook2.bids[i].price;
        }
        newSum = {
          asks: sumAsks,
          bids: sumBids
        };
      } else {
        newSum = {
          asks: sum.value.asks + orderbook2.sumDiff.asks,
          bids: sum.value.bids + orderbook2.sumDiff.bids
        };
      }
      setSum(newSum);
      setOrderbook(orderbook2);
    }
    function applyDiffQueue() {
      if (!lastFullUpdateTime.value) {
        return false;
      }
      if (_diffQueue.isFullOrderbookSyncRequired(lastFullUpdateTime.value)) {
        loadFullOrderbook(true);
        return false;
      }
      if (_diffQueue.isFullOrderbookRefreshRequired()) {
        loadFullOrderbook(false);
        return false;
      }
      _diffQueue.processQueue(lastFullUpdateTime.value);
      const { orderbook: bids, sumDiff: bidsSumDiff } = utils.mergeOrderbookWithDiff(
        orderbook.value.bids,
        _diffQueue.bids,
        "bids"
      );
      const { orderbook: asks, sumDiff: asksSumDiff } = utils.mergeOrderbookWithDiff(
        orderbook.value.asks,
        _diffQueue.asks,
        "asks"
      );
      const isMatchingDisabledForPair = activeMarketStore.isMatchingDisabled;
      if (!isMatchingDisabledForPair && bids.length > 0 && asks.length > 0 && bids[0].price >= asks[0].price) {
        loadFullOrderbook(false);
      } else {
        updateOrderbook({ bids, asks, sumDiff: { asks: asksSumDiff, bids: bidsSumDiff } });
      }
    }
    function addDiffToQueue(diff) {
      if (!initialized.value) {
        return;
      }
      _diffQueue.addDiff(diff);
      if (!throttledDiffQueueDispatch) {
        throttledDiffQueueDispatch = _.throttle(() => applyDiffQueue(), constants.TIMERS.DEPTH_CHART.MIN_THROTTLE);
      }
      if (!visibilityStore.isHidden) {
        throttledDiffQueueDispatch();
      }
    }
    async function connectWs() {
      if (!activeMarketStore.activeMarket) {
        return;
      }
      const channel = WSApi.getOrderbookDiffChannelName(activeMarketStore.activeMarket.key);
      if (channel !== connectedWsChannel.value) {
        connectedWsChannel.value = channel;
        const { disconnect } = await websocketsStore.subscribeToChannel({
          channel: WSApi.getOrderbookDiffChannelName(activeMarketStore.activeMarket.key),
          event: WSApi.ORDERBOOK_DIFF_EVENT,
          onEvent: addDiffToQueue
        });
        disconnectOrderbookDiffWsFn = disconnect;
      }
    }
    async function initApiCalls() {
      await loadFullOrderbook(true, false);
      const { stop: stopPollingFullOrderbook } = pollingStore.startPolling({
        interval: timersConstants.POLLING_ORDERBOOK.TIME,
        id: timersConstants.POLLING_ORDERBOOK.ID,
        fn: loadFullOrderbook
      });
      stopPollingFullOrderbookFn = stopPollingFullOrderbook;
      initialized.value = true;
    }
    async function _init() {
      _diffQueue = new utils.OrderBookDiffQueue();
      if (wsInitialized.value) {
        await connectWs();
      }
      if (orderbook100Store.initialized) {
        await initApiCalls();
      }
      return () => {
        stopPollingFullOrderbookFn();
        disconnectOrderbookDiffWsFn();
      };
    }
    watch(wsInitialized, async (newValue, prevValue) => {
      if (newValue && !prevValue) {
        await connectWs();
      }
    });
    watch(isOrderbookStoreInitialized, async (newValue, prevValue) => {
      if (newValue && !prevValue) {
        initApiCalls();
      }
    });
    watch(
      activeMarket,
      async (newValue, prevValue) => {
        if ((newValue == null ? void 0 : newValue.key) === (prevValue == null ? void 0 : prevValue.key) && !initialized.value) {
          return;
        }
        resetDiffSync();
        isSwitchingMarket.value = true;
        disconnectOrderbookDiffWsFn();
      },
      {
        deep: true
      }
    );
    watch(fullOrderbookFromLastApiCall, async (newOb) => {
      var _a2, _b;
      if ((((_a2 = newOb == null ? void 0 : newOb.bids) == null ? void 0 : _a2.length) > 0 || ((_b = newOb == null ? void 0 : newOb.asks) == null ? void 0 : _b.length) > 0) && (newOb == null ? void 0 : newOb.pair) === activeMarketStore.activeMarket.key && isSwitchingMarket.value) {
        isSwitchingMarket.value = false;
        loadFullOrderbook(true, false);
        await connectWs();
      }
    });
    return {
      orderbook,
      sum,
      updateOrderbook,
      _init,
      _setSum: setSum,
      _setOrderbook: setOrderbook
    };
  })
);
const _sfc_main$5 = {
  name: "DepthChart",
  components: {
    AppIcon,
    VueSlider: F
  },
  setup() {
    return {
      tradeviewDepthChartStore: useTradeviewDepthChartStore(),
      activeMarketStore: useActiveMarketStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewThemeStore: useTradeviewThemeStore(),
      tradeviewTriggerValueStore: useTradeviewTriggerValueStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      tradeviewPrivateOrdersStore: useTradeviewPrivateOrdersStore()
    };
  },
  data() {
    return {
      applyChartUpdates: true,
      highChartOptions: null,
      ordersIds: [],
      chart: null,
      isZoomResetRequired: true,
      activeZoom: 6,
      maxZoom: 7,
      userChangedZoom: false,
      userChangedMarket: false
    };
  },
  computed: {
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    activePairOrders() {
      return this.tradeviewPrivateOrdersStore.openOrdersForActiveMarket;
    },
    // TODO: Added temporary test, to see if we can increase Depth Chart size
    tmpDepthChartLimit() {
      return LocalStorageService.read("_tdcs_", constants.DEPTH_CHART_SIZE_LIMIT);
    },
    bids() {
      return this.buildDepthChart(
        this.tradeviewDepthChartStore.orderbook.bids.slice(0, this.tmpDepthChartLimit),
        true
      );
    },
    asks() {
      return this.buildDepthChart(
        this.tradeviewDepthChartStore.orderbook.asks.slice(0, this.tmpDepthChartLimit),
        false
      );
    },
    asksSum() {
      if (this.asks.length > 0) {
        return `${numberFormatter.decimal({
          value: this.tradeviewDepthChartStore.sum.asks,
          decimals: 0,
          rounding: Decimal.ROUND_FLOOR
        })} ${this.activeMarket.base}`;
      } else {
        return "";
      }
    },
    bidsSum() {
      if (this.bids.length > 0) {
        return `${numberFormatter.decimal({
          value: this.tradeviewDepthChartStore.sum.bids,
          decimals: 0,
          rounding: Decimal.ROUND_FLOOR
        })} ${this.activeMarket.counter}`;
      } else {
        return "";
      }
    },
    priceRange() {
      let priceRange;
      if (this.bids.length < 1 || this.asks.length < 1) {
        priceRange = 0;
      } else {
        const bidsPriceRange = _.last(this.bids)[0] - _.first(this.bids)[0];
        const asksPriceRange = _.last(this.asks)[0] - _.first(this.asks)[0];
        priceRange = Math.min(bidsPriceRange, asksPriceRange);
      }
      return priceRange;
    },
    depthChartData() {
      return {
        bidsSum: this.bidsSum,
        asksSum: this.asksSum
      };
    },
    isDepthChartDataReady() {
      return this.asks.length > 0 && this.bids.length > 0;
    },
    zoomOutRightLimit() {
      return this.isDepthChartDataReady ? _.first(this.asks)[0] + this.priceRange : 0;
    },
    zoomOutLeftLimit() {
      return this.isDepthChartDataReady ? _.last(this.bids)[0] - this.priceRange : 0;
    },
    zoomStep() {
      return (this.zoomOutRightLimit - this.zoomOutLeftLimit) / 15;
    },
    currentLeftLimit() {
      return this.zoomOutLeftLimit + this.activeZoom * this.zoomStep;
    },
    currentRightLimit() {
      return this.zoomOutRightLimit - this.activeZoom * this.zoomStep;
    },
    canZoomIn() {
      return this.currentLeftLimit + this.zoomStep < this.currentRightLimit - this.zoomStep;
    },
    canZoomOut() {
      return this.currentLeftLimit > this.zoomOutLeftLimit && this.currentRightLimit < this.zoomOutRightLimit;
    }
  },
  watch: {
    "activeMarketStore.activeMarket.key": {
      handler() {
        this.isZoomResetRequired = true;
        this.userChangedZoom = false;
        this.userChangedMarket = true;
      },
      deep: true
    },
    depthChartData: {
      handler({ bidsSum, asksSum }) {
        if (!this.userChangedZoom && (this.asks.length > 0 && this.asks.length < 20 || this.bids.length > 0 && this.bids.length < 20)) {
          this.activeZoom = 0;
        } else if (!this.userChangedZoom && (this.asks.length > 0 && this.asks.length >= 20 || this.bids.length > 0 && this.bids.length >= 20)) {
          this.activeZoom = 6;
        }
        if (bidsSum !== "" || asksSum !== "" || this.userChangedMarket) {
          requestAnimationFrame(() => {
            this.updateChart();
          });
        }
      },
      immediate: true
    },
    "tradeviewOrderFormStore.activeOrderFormType": {
      handler(type) {
        if (type === constants$1.ORDER_FORM_TYPE.MARKET) {
          this.deleteOrderLine();
        }
      }
    },
    "tradeviewTriggerValueStore.priceSetByTrigger": {
      handler(newPrice) {
        if (newPrice !== null) {
          this.changeSelectedPrice(newPrice);
        } else {
          this.deleteOrderLine();
        }
      },
      immediate: true
    },
    "tradeviewSettingsStore.areOnChartOrdersEnabled": {
      handler() {
        this.drawOrders(this.activePairOrders);
      }
    },
    activePairOrders: {
      handler(orders) {
        if (this.chart) {
          this.drawOrders(orders);
        }
      },
      immediate: true
    }
  },
  created() {
    this.highChartOptions = Object.freeze(initHighChart({
      clickEvent: this.onHighChartClick,
      setExtremesEvent: this.setExtremesEvent
    }));
  },
  mounted() {
    this.chart = this.$refs.HighchartsDepthchart.chart;
    if (this.tradeviewSettingsStore.areOnChartOrdersEnabled) {
      this.drawOrders(this.activePairOrders);
    }
  },
  beforeUnmount() {
    this.applyChartUpdates = false;
  },
  methods: {
    hideResetButton() {
      if (this.chart.resetZoomButton) {
        this.chart.resetZoomButton.element.hcEvents.click[0].fn();
      }
    },
    buildDepthChart(orders, reverse = false) {
      const depthChart = [];
      let sum = 0;
      for (const order of orders) {
        sum = sum + order.amount;
        depthChart.push(Object.freeze([order.price, sum]));
      }
      if (reverse) {
        depthChart.reverse();
      }
      return Object.freeze(depthChart);
    },
    reflow() {
      if (this.chart) {
        this.chart.reflow();
      }
    },
    applyCurrentZoom(userChanged = false, redraw = true) {
      this.hideResetButton();
      if (this.chart.xAxis) {
        this.chart.xAxis[0].setExtremes(
          this.currentLeftLimit,
          this.currentRightLimit,
          redraw
        );
      }
      this.isZoomResetRequired = false;
      this.userChangedZoom = userChanged;
    },
    setExtremesEvent(event) {
      if (typeof event.min === "undefined" && typeof event.max === "undefined") {
        this.$nextTick(() => {
          this.applyCurrentZoom();
        });
      }
      if (event.trigger === "zoom") {
        this.userChangedZoom = true;
      }
    },
    zoomIn() {
      if (this.canZoomIn) {
        this.hideResetButton();
        this.chart.xAxis[0].setExtremes(
          this.currentLeftLimit + this.zoomStep,
          this.currentRightLimit - this.zoomStep,
          true
        );
        this.activeZoom += 1;
        this.userChangedZoom = true;
      }
    },
    zoomOut() {
      if (this.canZoomOut) {
        this.hideResetButton();
        this.chart.xAxis[0].setExtremes(
          Math.max(
            this.currentLeftLimit - this.zoomStep,
            this.zoomOutLeftLimit
          ),
          Math.min(
            this.currentRightLimit + this.zoomStep,
            this.zoomOutRightLimit
          ),
          true
        );
        this.activeZoom -= 1;
        this.userChangedZoom = true;
      }
    },
    onHighChartClick(event) {
      let xPrice;
      if (_.has(event, "xAxis")) {
        xPrice = event.xAxis[0].value;
      } else {
        xPrice = event.point.x;
      }
      if (isNaN(xPrice)) {
        return false;
      }
      const price = new Decimal(xPrice).toDecimalPlaces(
        this.activeMarket.decimals.counter
      );
      this.tradeviewTriggerValueStore.setPriceSetByTrigger(price);
    },
    changeSelectedPrice(newPrice) {
      if (!this.chart || newPrice === null) {
        return false;
      }
      this.deleteOrderLine();
      if (!newPrice) {
        return;
      }
      const value = newPrice.toFixed(this.activeMarket.decimals.counter);
      this.chart.xAxis[0].addPlotLine({
        value,
        width: 1,
        // rendering issue on some prices if set to 1
        dashStyle: "solid",
        id: "orderLine",
        className: "selected-price",
        zIndex: 3,
        label: {
          text: value,
          verticalAlign: "top"
        }
      });
    },
    deleteOrderLine() {
      if (!this.chart) {
        return false;
      }
      this.chart.xAxis[0].removePlotLine("orderLine");
    },
    /**
     * @param {module:ordersStore.Order[]} orders
     */
    drawOrders(orders) {
      this.ordersIds.forEach((orderId) => {
        this.chart.xAxis[0].removePlotLine(`order-${orderId}`);
      });
      this.ordersIds = [];
      if (!this.tradeviewSettingsStore.areOnChartOrdersEnabled) {
        return;
      }
      orders.forEach((order) => {
        const theme2 = this.tradeviewThemeStore.activeTradeviewThemeSettings;
        const color = order.side === constants$1.ORDER_SIDE.BUY ? theme2.COLORS.TREND_UP : theme2.COLORS.TREND_DOWN;
        let value;
        if (order.stopPrice) {
          value = order.stopPrice.toFixed(this.activeMarket.decimals.counter);
        } else {
          value = order.price.toFixed(this.activeMarket.decimals.counter);
        }
        this.chart.xAxis[0].addPlotLine({
          value,
          color,
          width: 1,
          dashStyle: "dot",
          zIndex: 3,
          id: `order-${order.id}`,
          label: {
            text: value,
            verticalAlign: "top",
            style: {
              color,
              fontWeight: "bold"
            }
          }
        });
        this.ordersIds.push(order.id);
      });
      this.changeSelectedPrice(this.tradeviewTriggerValueStore.priceSetByTrigger);
    },
    updateChart() {
      if (!this.applyChartUpdates) {
        return false;
      }
      const redrawDuringZoom = this.chart.resetZoomButton === void 0 || this.isZoomResetRequired;
      this.chart.update({
        series: [
          {
            type: "area",
            name: "Bids",
            data: [...this.bids]
          },
          {
            type: "area",
            name: "Asks",
            data: [...this.asks]
          }
        ]
      }, !redrawDuringZoom);
      if (redrawDuringZoom) {
        requestAnimationFrame(() => {
          if (this.applyChartUpdates) {
            this.applyCurrentZoom(true);
          }
        });
      }
    }
  }
};
const _hoisted_1$3 = { class: "depth-chart" };
const _hoisted_2$3 = { class: "sums" };
const _hoisted_3$2 = {
  class: "sums__asks",
  "data-test": "depthchartAsks"
};
const _hoisted_4$1 = {
  class: "sums__bids",
  "data-test": "depthchartBids"
};
const _hoisted_5 = { class: "depth-chart__wrapper" };
const _hoisted_6 = { class: "depth-chart__controls" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_highcharts = resolveComponent("highcharts");
  const _component_AppIcon = resolveComponent("AppIcon");
  const _component_vue_slider = resolveComponent("vue-slider");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createBaseVNode("div", _hoisted_2$3, [
      createBaseVNode("span", _hoisted_3$2, toDisplayString($options.depthChartData.asksSum), 1),
      _cache[4] || (_cache[4] = createTextVNode()),
      createBaseVNode("span", _hoisted_4$1, toDisplayString($options.depthChartData.bidsSum), 1)
    ]),
    _cache[7] || (_cache[7] = createTextVNode()),
    createBaseVNode("div", _hoisted_5, [
      createVNode(_component_highcharts, {
        ref: "HighchartsDepthchart",
        options: $data.highChartOptions,
        class: "depth-chart__highcharts",
        "data-test": "highchartsDepthchart"
      }, null, 8, ["options"])
    ]),
    _cache[8] || (_cache[8] = createTextVNode()),
    createBaseVNode("div", _hoisted_6, [
      createBaseVNode("span", {
        title: "Zoom out",
        class: normalizeClass(["depth-chart__icon", { "depth-chart__icon--can-zoom": $options.canZoomOut }]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.zoomOut && $options.zoomOut(...args))
      }, [
        createVNode(_component_AppIcon, { icon: "monochrome/zoom-out.svg" })
      ], 2),
      _cache[5] || (_cache[5] = createTextVNode()),
      createVNode(_component_vue_slider, {
        modelValue: $data.activeZoom,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.activeZoom = $event),
        min: 0,
        max: $data.maxZoom,
        interval: 1,
        tooltip: "none",
        "min-range": 1,
        "dot-size": 10,
        height: 3,
        width: "100%",
        clickable: "",
        contained: "",
        "drag-on-click": "",
        onChange: _cache[2] || (_cache[2] = ($event) => $options.applyCurrentZoom(true))
      }, null, 8, ["modelValue", "max"]),
      _cache[6] || (_cache[6] = createTextVNode()),
      createBaseVNode("span", {
        title: "Zoom in",
        class: normalizeClass(["depth-chart__icon", { "depth-chart__icon--can-zoom": $options.canZoomIn }]),
        onClick: _cache[3] || (_cache[3] = (...args) => $options.zoomIn && $options.zoomIn(...args))
      }, [
        createVNode(_component_AppIcon, { icon: "monochrome/zoom-in.svg" })
      ], 2)
    ])
  ]);
}
const DepthChart = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-1d0e8c4e"]]);
const _sfc_main$4 = {
  name: "MarketActivity",
  components: {
    GroupedWidgetLayout
  },
  props: {
    showTrades: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      allWidgets: [
        {
          id: "orderbook",
          title: "Order book",
          component: markRaw(OrderBookData)
        },
        {
          id: "depthchart",
          title: "Depth chart",
          component: markRaw(DepthChart)
        },
        {
          id: "trades",
          title: "Trades",
          component: markRaw(TradeBookData)
        }
      ]
    };
  },
  computed: {
    widgets() {
      if (this.showAllTabs) {
        return this.allWidgets;
      }
      return this.allWidgets.slice(0, -1);
    },
    showAllTabs() {
      return this.showTrades;
    }
  }
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GroupedWidgetLayout = resolveComponent("GroupedWidgetLayout");
  return openBlock(), createBlock(_component_GroupedWidgetLayout, { widgets: $options.widgets }, null, 8, ["widgets"]);
}
const MarketActivity = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3]]);
var define_process_env_default = {};
const SUBSCRIBER_TRADEVIEW = "tradeview";
const handleReloadEvent = (fallbackMaxDelaySeconds, subscriberId, { version: version2, maxDelaySeconds, subscribers }) => {
  if (subscribers && !subscribers.includes(subscriberId)) {
    console.log("Skipping reload due to mismatched subscriber");
    return null;
  } else if (version2 === define_process_env_default.VERSION) {
    console.log(`Client version matches reload version: ${version2} -- skipping ...`);
    return null;
  }
  const reloadMaxDelaySeconds = parseNumberSafely(maxDelaySeconds, fallbackMaxDelaySeconds);
  const reloadDelaySeconds = Math.ceil(Math.random() * reloadMaxDelaySeconds);
  setTimeout(() => {
    window.location.reload();
  }, reloadDelaySeconds * 1e3);
  console.info(`Reload scheduled in ${reloadDelaySeconds}s`);
  return reloadDelaySeconds;
};
function useTradeviewReload() {
  const websocketsStore = useWebsocketStore();
  const { showToast } = useToastStore();
  const disconnectFn = ref(() => {
  });
  function reloadTradeview(e) {
    const reloadDelaySeconds = handleReloadEvent(constants.RELOAD_MAX_DELAY_SECONDS, SUBSCRIBER_TRADEVIEW, e);
    if (reloadDelaySeconds === null) {
      return;
    }
    const reloadDelayMinutes = Math.floor(reloadDelaySeconds / 60);
    const reloadDelayText = reloadDelayMinutes > 0 ? `${reloadDelayMinutes} ${reloadDelayMinutes === 1 ? "minute" : "minutes"}` : "less than 1 minute";
    const notification = {
      title: "Reload scheduled",
      text: `Your browser will automatically reload in ${reloadDelayText}.`,
      type: constants$3.NOTIFICATIONS.TYPES.WARNING
    };
    showToast(notification);
  }
  onMounted(async () => {
    const { disconnect } = await websocketsStore.subscribeToChannel({
      channel: WSApi.CHANNEL_GROUP_RELOAD,
      event: WSApi.RELOAD_EVENT,
      onEvent: reloadTradeview
    });
    disconnectFn.value = disconnect;
  });
  onUnmounted(() => {
    var _a2;
    (_a2 = disconnectFn.value) == null ? void 0 : _a2.call(disconnectFn);
  });
}
const _sfc_main$3 = {
  name: "AccountMarketTypeSwitcher",
  components: {
    GeneralNotification,
    AppDropdown: Dropdown,
    WidgetLayout
  },
  setup() {
    const { selectAccount } = useSubAccounts();
    return {
      selectAccount,
      activeMarketStore: useActiveMarketStore(),
      subAccountStore: useSubAccountStore()
    };
  },
  data() {
    return {
      NOTIFICATION_TYPE_INFO: GeneralNotification.INFO,
      MARKET_TYPE_SPOT: marketConstants.MARKET_TYPES.SPOT,
      MARKET_TYPE_PERPETUAL: marketConstants.MARKET_TYPES.PERPETUAL,
      MAIN_ACCOUNT_ICON: "monochrome/wallet.svg",
      SPOT_ACCOUNT_ICON: "monochrome/spot-account.svg",
      DERIVATIVES_ACCOUNT_ICON: "monochrome/derivatives-account.svg"
    };
  },
  computed: {
    action() {
      if (this.accountCreationRequired) {
        return {
          text: "Create a new sub account"
        };
      } else if (!this.canSwitchToMultipleAccounts) {
        return {
          text: `Switch to ${this.accountsSupportingActiveMarketType[0].displayName}`
        };
      }
      return null;
    },
    activeMarketType() {
      return this.activeMarketStore.activeMarket.type;
    },
    accountsSupportingActiveMarketType() {
      return Object.values(this.subAccountStore.accounts).filter((a) => a.enabledMarketTypes.includes(this.activeMarketType));
    },
    accountSelectorOptions() {
      const options = this.accountsSupportingActiveMarketType.map((a) => ({
        value: a.id,
        text: a.displayName,
        icon: a.isMainAccount ? this.MAIN_ACCOUNT_ICON : this.activeMarketType === marketConstants.MARKET_TYPES.SPOT ? this.SPOT_ACCOUNT_ICON : this.DERIVATIVES_ACCOUNT_ICON
      }));
      options.sort((a, b) => {
        if (a.value === accountConstants.MAIN_ACCOUNT_ID) {
          return -1;
        }
        return a.value - b.value;
      });
      return options;
    },
    canSwitchToMultipleAccounts() {
      return this.accountsSupportingActiveMarketType.length > 1;
    },
    accountCreationRequired() {
      return this.accountsSupportingActiveMarketType.length < 1;
    }
  },
  methods: {
    onAction() {
      if (this.accountCreationRequired) {
        if (this.$isSmall.value || this.$isMedium.value) {
          window.location.href = URLService.getPageUrl("createSubAccount");
        } else {
          this.subAccountStore.openCreateSubAccountModal();
        }
      } else if (!this.canSwitchToMultipleAccounts) {
        this.selectAccount(this.accountsSupportingActiveMarketType[0].id);
      }
    }
  }
};
const _hoisted_1$2 = { class: "account-type-switcher" };
const _hoisted_2$2 = { class: "flex flex--direction-column flex--gap" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppDropdown = resolveComponent("AppDropdown");
  const _component_GeneralNotification = resolveComponent("GeneralNotification");
  const _component_WidgetLayout = resolveComponent("WidgetLayout");
  return openBlock(), createBlock(_component_WidgetLayout, { class: "widget create-order" }, {
    title: withCtx(() => _cache[0] || (_cache[0] = [
      createTextVNode("\n      Switch account to trade\n    ")
    ])),
    default: withCtx(() => [
      _cache[2] || (_cache[2] = createTextVNode()),
      createBaseVNode("div", _hoisted_1$2, [
        createVNode(_component_GeneralNotification, {
          pro: "",
          "single-column-layout": "",
          "notification-type": $data.NOTIFICATION_TYPE_INFO,
          action: $options.action,
          onAction: $options.onAction
        }, createSlots({
          default: withCtx(() => [
            createTextVNode("\n        Trading " + toDisplayString($setup.activeMarketStore.activeMarket.name) + " is not supported on your\n        " + toDisplayString($setup.subAccountStore.isMainActive ? "Main account" : "active sub account") + ".\n        ", 1)
          ]),
          _: 2
        }, [
          $options.canSwitchToMultipleAccounts ? {
            name: "action",
            fn: withCtx(() => [
              createBaseVNode("div", _hoisted_2$2, [
                createBaseVNode("p", null, "\n              Switch to a sub account that supports\n              " + toDisplayString($options.activeMarketType === $data.MARKET_TYPE_PERPETUAL ? "derivatives" : "spot") + "\n              trading.\n            ", 1),
                _cache[1] || (_cache[1] = createTextVNode()),
                createVNode(_component_AppDropdown, {
                  class: "account-type-switcher__dropdown",
                  options: $options.accountSelectorOptions,
                  searchable: "",
                  compact: "",
                  "display-search-icon": "",
                  "clear-search-query-on-open": "",
                  label: "Select account",
                  "no-results-text": "No matching account",
                  "reserve-space-for-error-row": false,
                  "onUpdate:value": $setup.selectAccount
                }, null, 8, ["options", "onUpdate:value"])
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["notification-type", "action", "onAction"])
      ])
    ]),
    _: 1
  });
}
const AccountMarketTypeSwitcher = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__scopeId", "data-v-9d692b5a"]]);
const MARKET_TYPE_TO_PRODUCT_AFFILIATION_TYPE = {
  [marketConstants.MARKET_TYPES.PERPETUAL]: "DERIVATIVES_PERPETUALS"
};
const MARKET_TYPE_TO_COMPLIANCE_REQUEST_ACTION_TYPE = {
  [marketConstants.MARKET_TYPES.PERPETUAL]: "derivatives_perpetuals"
};
const AFFILIATION_STATUS = {
  ONBOARDING_REQUIRED: "ONBOARDING_REQUIRED",
  ONBOARDING_IN_PROGRESS_PENDING_SYSTEM_OR_AGENT: "ONBOARDING_IN_PROGRESS_PENDING_SYSTEM_OR_AGENT",
  ONBOARDING_IN_PROGRESS_PENDING_USER_ACTION: "ONBOARDING_IN_PROGRESS_PENDING_USER_ACTION",
  NOT_AVAILABLE: "NOT_AVAILABLE",
  AFFILIATED: "AFFILIATED"
};
const _sfc_main$2 = {
  name: "TradeviewProductAffiliation",
  components: {
    AppButton: BtsButton,
    TradeviewModal,
    ThemeBasedImage,
    WidgetLayout
  },
  setup() {
    return {
      activeMarketStore: useActiveMarketStore(),
      toastStore: useToastStore(),
      pollingStore: usePollingStore(),
      featureStatusStore: useFeatureStatusStore(),
      visibilityStore: useVisibilityStore(),
      userStateStore: useUserStateStore()
    };
  },
  data() {
    return {
      initialized: false,
      processing: false,
      isConfirmationModalOpen: false,
      productAffiliationCtaUrl: null,
      productAffiliationCtaText: null,
      productAffiliationMessage: null,
      productAffiliationStatus: null,
      requestActionUuid: null
    };
  },
  computed: {
    message() {
      if (!this.userStateStore.isVerified) {
        if (this.userStateStore.state.hasPendingVerificationRequest) {
          return `We're processing your account verification, please try again when your account is verified.`;
        }
        return "You need to verify your account before you can star trading.";
      }
      return this.productAffiliationMessage;
    },
    image() {
      if (!this.userStateStore.isVerified) {
        if (this.userStateStore.state.hasPendingVerificationRequest) {
          return "waiting-for-agent";
        }
        return "user-action-required";
      }
      switch (this.productAffiliationStatus) {
        case AFFILIATION_STATUS.ONBOARDING_IN_PROGRESS_PENDING_USER_ACTION:
          return "user-action-required";
        case AFFILIATION_STATUS.ONBOARDING_IN_PROGRESS_PENDING_SYSTEM_OR_AGENT:
          return "waiting-for-agent";
        case AFFILIATION_STATUS.ONBOARDING_REQUIRED:
          return "user-action-required";
      }
      return "";
    },
    ctaText() {
      if (!this.userStateStore.isVerified && !this.userStateStore.state.hasPendingVerificationRequest) {
        return "Verify your account";
      }
      return this.productAffiliationCtaText;
    },
    ctaUrl() {
      if (!this.userStateStore.isVerified && !this.userStateStore.state.hasPendingVerificationRequest) {
        return URLService.getPageUrl("account_verify");
      }
      return this.productAffiliationCtaUrl;
    },
    canCancelRequest() {
      if (!this.userStateStore.isVerified) {
        return false;
      }
      return this.requestActionUuid && (this.productAffiliationStatus === AFFILIATION_STATUS.ONBOARDING_IN_PROGRESS_PENDING_SYSTEM_OR_AGENT || this.productAffiliationStatus === AFFILIATION_STATUS.ONBOARDING_IN_PROGRESS_PENDING_USER_ACTION);
    }
  },
  watch: {
    productAffiliationStatus(newValue, oldValue) {
      if (oldValue && (newValue === AFFILIATION_STATUS.AFFILIATED || newValue === AFFILIATION_STATUS.NOT_AVAILABLE)) {
        this.stopPolling();
        this.featureStatusStore.fetch(featureStatusConstants.FEATURE_TYPES.TRADE_DERIVATIVES);
      }
    },
    "visibilityStore.isHidden": {
      // Recheck when switching tabs/visibility as we might complete onboarding before next polling
      handler(isHidden, wasHidden) {
        if (!isHidden && wasHidden && this.productAffiliationStatus !== AFFILIATION_STATUS.NOT_AVAILABLE) {
          this.fetchProductAffiliationState();
        }
      }
    }
  },
  async created() {
    await this.fetchProductAffiliationState();
    this.initialized = true;
    if (this.productAffiliationStatus !== AFFILIATION_STATUS.AFFILIATED && this.productAffiliationStatus !== AFFILIATION_STATUS.NOT_AVAILABLE) {
      this.pollingStore.startPolling({
        id: "tv-product-affiliation",
        interval: 60 * 1e3,
        fn: this.fetchProductAffiliationState
      });
    }
  },
  beforeUnmount() {
    this.stopPolling();
  },
  methods: {
    stopPolling() {
      this.pollingStore.stopPolling("tv-product-affiliation");
    },
    onCancelClicked(e) {
      e == null ? void 0 : e.preventDefault();
      this.isConfirmationModalOpen = true;
    },
    async fetchProductAffiliationState() {
      var _a2, _b, _c;
      try {
        const productType = MARKET_TYPE_TO_PRODUCT_AFFILIATION_TYPE[this.activeMarketStore.activeMarket.type];
        const url = URLService.buildUrl("productAffiliationResource", { product_type: productType });
        const responseData = (_b = (_a2 = await axiosInstance.get(url)) == null ? void 0 : _a2.data) == null ? void 0 : _b.data;
        this.productAffiliationCtaUrl = responseData == null ? void 0 : responseData.ctaUrl;
        this.productAffiliationCtaText = responseData == null ? void 0 : responseData.ctaText;
        this.productAffiliationMessage = responseData == null ? void 0 : responseData.message;
        this.productAffiliationStatus = responseData == null ? void 0 : responseData.status;
        this.requestActionUuid = responseData == null ? void 0 : responseData.requestActionUuid;
      } catch (e) {
        (_c = this.$errorTracking) == null ? void 0 : _c.trackException(e);
      }
    },
    async cancelOnboardingRequest() {
      if (this.processing) {
        return false;
      }
      try {
        this.processing = true;
        await api.requestAction.cancel(
          this.requestActionUuid,
          MARKET_TYPE_TO_COMPLIANCE_REQUEST_ACTION_TYPE[this.activeMarketStore.activeMarket.type]
        );
        this.toastStore.showToast({
          type: constants$3.NOTIFICATIONS.TYPES.SUCCESS,
          title: "Request canceled",
          text: "You can start again at any time."
        });
      } catch (e) {
        this.toastStore.showToast({
          type: constants$3.NOTIFICATIONS.TYPES.ERROR,
          title: "Error",
          text: "Failed to cancel request."
        });
      } finally {
        await this.fetchProductAffiliationState();
        this.processing = false;
        this.isConfirmationModalOpen = false;
      }
    }
  }
};
const _hoisted_1$1 = {
  key: 0,
  class: "pa-status"
};
const _hoisted_2$1 = { class: "pa-status__message" };
const _hoisted_3$1 = {
  key: 1,
  class: "pa-status pa-status--unavailable"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ThemeBasedImage = resolveComponent("ThemeBasedImage");
  const _component_AppButton = resolveComponent("AppButton");
  const _component_TradeviewModal = resolveComponent("TradeviewModal");
  const _component_WidgetLayout = resolveComponent("WidgetLayout");
  return openBlock(), createBlock(_component_WidgetLayout, {
    class: "widget",
    "is-header-visible": false
  }, {
    default: withCtx(() => [
      $options.message ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
        $options.image ? (openBlock(), createBlock(_component_ThemeBasedImage, {
          key: 0,
          class: "pa-status__image",
          dark: `compliance/${$options.image}--dark.svg`,
          light: `compliance/${$options.image}--light.svg`
        }, null, 8, ["dark", "light"])) : createCommentVNode("", true),
        _cache[4] || (_cache[4] = createTextVNode()),
        createBaseVNode("div", _hoisted_2$1, toDisplayString($options.message), 1),
        _cache[5] || (_cache[5] = createTextVNode()),
        createBaseVNode("div", null, [
          $options.ctaText ? (openBlock(), createBlock(_component_AppButton, {
            key: 0,
            link: $options.ctaUrl
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($options.ctaText), 1)
            ]),
            _: 1
          }, 8, ["link"])) : createCommentVNode("", true),
          _cache[3] || (_cache[3] = createTextVNode()),
          $options.canCancelRequest ? (openBlock(), createBlock(_component_AppButton, {
            key: 1,
            class: "pa-status__cancel-button",
            disabled: $data.processing,
            "as-link": "",
            onClick: $options.onCancelClicked
          }, {
            default: withCtx(() => _cache[2] || (_cache[2] = [
              createTextVNode("\n          Cancel request\n        ")
            ])),
            _: 1
          }, 8, ["disabled", "onClick"])) : createCommentVNode("", true)
        ])
      ])) : $data.initialized ? (openBlock(), createElementBlock("div", _hoisted_3$1, _cache[6] || (_cache[6] = [
        createBaseVNode("div", { class: "pa-status__message" }, "\n        Trading this market is not currently available for your account.\n      ", -1)
      ]))) : createCommentVNode("", true),
      _cache[10] || (_cache[10] = createTextVNode()),
      createVNode(_component_TradeviewModal, {
        "is-open": $data.isConfirmationModalOpen,
        "onUpdate:isOpen": _cache[0] || (_cache[0] = ($event) => $data.isConfirmationModalOpen = $event),
        "confirm-disabled": $data.processing,
        "confirm-text": "Yes, I'm sure",
        "cancel-text": "No",
        onClose: _cache[1] || (_cache[1] = ($event) => $data.isConfirmationModalOpen = false),
        onConfirm: $options.cancelOnboardingRequest
      }, {
        title: withCtx(() => _cache[7] || (_cache[7] = [
          createTextVNode("\n        Cancel request\n      ")
        ])),
        body: withCtx(() => _cache[8] || (_cache[8] = [
          createTextVNode("\n        Are you sure you want to cancel your product onboarding request?\n      ")
        ])),
        _: 1
      }, 8, ["is-open", "confirm-disabled", "onConfirm"])
    ]),
    _: 1
  });
}
const TradeviewProductAffiliation = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__scopeId", "data-v-45659574"]]);
const _sfc_main$1 = {
  __name: "DerivativesEntityDisclaimerModal",
  setup(__props) {
    const isDisclaimerAccepted = useLocalStorage(
      localStorageConstants.LOCAL_STORAGE.TV_DERIVATIVES_ENTITY_DISCLAIMER_ACCEPTED,
      false
    );
    const isOpen = ref(!isDisclaimerAccepted.value);
    function onConfirm() {
      isDisclaimerAccepted.value = true;
      isOpen.value = false;
      try {
        axiosInstance.post(URLService.buildUrl("derivativesEntityDisclaimerAckResource", { user_id: "own" }));
      } catch (e) {
        trackException(e);
      }
    }
    function onClose() {
      if (!isDisclaimerAccepted.value) {
        window.location = URLService.getPageUrl("dashboardRouter");
      }
      isOpen.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(TradeviewModal), {
        "is-open": isOpen.value,
        title: "Crypto derivatives",
        "confirm-text": "Acknowledge",
        "cancel-text": "Cancel",
        onClose,
        onConfirm
      }, {
        body: withCtx(() => [
          _cache[1] || (_cache[1] = createBaseVNode("p", { class: "mb16" }, "\n        You are now entering the crypto derivatives trading venue provided by Bitstamp Financial Services,\n        brokerage company, Ltd. (“BFS”).\n      ", -1)),
          _cache[2] || (_cache[2] = createTextVNode()),
          _cache[3] || (_cache[3] = createBaseVNode("p", { class: "mb16" }, "\n        BFS is authorized as a MiFID investment firm and is supervised by the\n        Slovenian Securities Market Agency (ATVP) to provide MiFID investment services.\n      ", -1)),
          _cache[4] || (_cache[4] = createTextVNode()),
          createVNode(unref(GeneralNotification), {
            title: "Risk disclaimer",
            "notification-type": unref(GeneralNotification).WARNING
          }, {
            default: withCtx(() => _cache[0] || (_cache[0] = [
              createTextVNode("\n        Trading crypto derivatives involves significant risk, including the possibility of substantial losses.\n        Please ensure you fully understand the risks before proceeding.\n      ")
            ])),
            _: 1
          }, 8, ["notification-type"])
        ]),
        _: 1
      }, 8, ["is-open"]);
    };
  }
};
const _sfc_main = {
  components: {
    AppScrollbar: _sfc_main$1g,
    TradeviewProductAffiliation,
    ToastsAndLiquidationAlerts,
    DerivativesEntityDisclaimerModal: _sfc_main$1,
    PastPerformanceDisclaimer,
    AccountMarketTypeSwitcher,
    MarketActivity,
    TradeviewHeader: __nuxt_component_0,
    MobileHeader,
    MobileAppPrompt,
    TradeBook,
    TradingviewContainer,
    TradeActivity,
    CreateOrder,
    QuickView,
    SystemStatus
  },
  mixins: [DeferMixin(9), branchAttributionMixin],
  setup() {
    const { setActiveMarket } = useSetActiveMarket();
    const { selectAccount } = useSubAccounts();
    useTradeviewDepthChartStore();
    useTradeviewReload();
    useTradeviewPrivateOrdersStore();
    useTradeviewPrivateTradesStore();
    useTradeviewPositionSettlementHistoryStore();
    const s = {
      setActiveMarket,
      selectAccount,
      activeMarketStore: useActiveMarketStore(),
      balancesStore: useBalancesStore(),
      currenciesStore: useCurrenciesStore(),
      conversionPathStore: useConversionPathStore(),
      feeScheduleStore: useFeeScheduleStore(),
      marketsStore: useMarketsStore(),
      orderHistoryStore: useOrderHistoryStore(),
      pollingStore: usePollingStore(),
      settlementBatchStore: useSettlementBatchStore(),
      subAccountStore: useSubAccountStore(),
      tradesStore: useTradesStore(),
      tradeviewOrderFormStore: useTradeviewOrderFormStore(),
      tradeviewThemeStore: useTradeviewThemeStore(),
      tradeviewMarginInfoStore: useTradeviewMarginInfoStore(),
      tradeviewSettingsStore: useTradeviewSettingsStore(),
      userStateStore: useUserStateStore(),
      visibilityStore: useVisibilityStore(),
      tradeviewMarginSettingsStore: useTradeviewMarginSettingsStore(),
      tradeviewTickersStore: useTradeviewTickersStore(),
      featureStatusStore: useFeatureStatusStore()
    };
    if (PAGE_CONTEXT.derivativesEnabled && ENDPOINTS_PRELOADED_DATA.userResource !== null) {
      s.notificationStore = useNotificationStore();
    }
    return s;
  },
  data() {
    return {
      SCREEN_SIZES,
      isTradeActivityShaking: false,
      isAndroid: isAndroid(),
      clientWidth: 1920,
      selector: {
        width: 0,
        offset: 0
      },
      playStore: CONSTANTS.playStore,
      activeTradeActivityTab: null,
      isDemoMode: this.$constants.demoMode ?? false
    };
  },
  computed: {
    activeMarket() {
      return this.activeMarketStore.activeMarket;
    },
    activeMarketTypeUnsupported() {
      return this.isAuthenticated && !this.subAccountStore.activeSubAccount.enabledMarketTypes.includes(this.activeMarketStore.activeMarket.type);
    },
    isChartInFullScreenMode() {
      return this.tradeviewSettingsStore.isFullScreenMode && this.$isExtraLarge.value;
    },
    isSmallScreen() {
      return this.$isSmall.value;
    },
    isMobileScreen() {
      return this.$isSmall.value || this.$isMedium.value;
    },
    isAuthenticated() {
      return this.userStateStore.isLoggedIn;
    },
    displaySeparateTrades() {
      return this.activeMarketStore.isSpot && this.clientWidth > 1200;
    },
    isProductAffiliationFlowVisible() {
      if (!PAGE_CONTEXT.requireProductAffiliation || !this.isAuthenticated) {
        return false;
      }
      return this.activeMarketStore.isPerpetual && !this.featureStatusStore.isTradeDerivativesEnabled;
    }
  },
  watch: {
    "tradesStore.activeMarketTrades": {
      handler(trades) {
        this.titleUpdater(trades);
      },
      immediate: true
    }
  },
  created() {
    this.initState();
    const pageRoot = document.getElementsByTagName("html")[0];
    pageRoot.classList.add(this.tradeviewThemeStore.activeColorScheme);
    this.setIosMaximumScale();
  },
  beforeMount() {
    this.updateLayout();
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.updateLayout);
    window.removeEventListener("popstate", this.onPopState);
  },
  mounted() {
    var _a2;
    window.addEventListener("resize", this.updateLayout);
    window.addEventListener("popstate", this.onPopState);
    if (this.notificationStore && ((_a2 = (this._.provides[PageRouteSymbol] || this.$route).query) == null ? void 0 : _a2.alertId)) {
      const alertId = (this._.provides[PageRouteSymbol] || this.$route).query.alertId;
      window.history.replaceState({}, document.title, (this._.provides[PageRouteSymbol] || this.$route).path);
      setTimeout(() => {
        const alert = this.notificationStore.liquidationAlerts.find((a) => a.id === alertId);
        if (alert) {
          this.onLiquidationAlertAction(alert);
        }
      }, 2e3);
    }
  },
  methods: {
    onActiveTradeActivityTabChange(tabId) {
      this.activeTradeActivityTab = tabId;
    },
    tradeActivityAnimationEnded() {
      this.isTradeActivityShaking = false;
    },
    /**
     * @param {module:notifications.LiquidationAlert} alert
     */
    onLiquidationAlertAction(alert) {
      if (alert.market) {
        this.setActiveMarket(alert.market);
      } else if (!this.activeMarketStore.isPerpetual) {
        this.setActiveMarket(marketConstants.DEFAULT_PERP_MARKET_KEY);
      }
      if (!this.subAccountStore.activeSubAccountId !== alert.accountId) {
        this.selectAccount(alert.accountId);
      }
      this.tradeviewSettingsStore.setAreUserOrdersInAllPairMode(true);
      switch (alert.alertType) {
        case constants$3.LIQUIDATION_ALERTS.TYPE.ACCOUNT_LIQUIDATION:
        case constants$3.LIQUIDATION_ALERTS.TYPE.OPEN_ORDERS_CANCELED:
          this.activeTradeActivityTab = TradeActivity.ORDER_HISTORY;
          break;
        case constants$3.LIQUIDATION_ALERTS.TYPE.WARNING:
        case constants$3.LIQUIDATION_ALERTS.TYPE.ACCOUNT_IM_DEPLETION:
        case constants$3.LIQUIDATION_ALERTS.TYPE.POSITION_LIQUIDATION:
        case constants$3.LIQUIDATION_ALERTS.TYPE.ADL_LIQUIDATION:
          this.activeTradeActivityTab = TradeActivity.OPEN_POSITIONS;
          break;
      }
      this.isTradeActivityShaking = true;
    },
    getCurrentMarketCandidate() {
      var _a2;
      const pathname = new URL(window.location).pathname;
      let marketKey = null;
      if (pathname.includes("/market/tradeview/")) {
        marketKey = LocalStorageService.read(
          marketConstants.LOCAL_STORAGE.ACTIVE_MARKET,
          marketConstants.DEFAULT_MARKET_KEY
        );
      } else {
        const spotMarketMatch = pathname.match(/trade\/(?<base>[a-zA-Z0-9]+)\/(?<counter>[a-zA-Z0-9]+)\//i);
        if (spotMarketMatch) {
          marketKey = `${spotMarketMatch.groups.base.toLowerCase()}${spotMarketMatch.groups.counter.toLowerCase()}`;
        } else {
          const genericMarketMatch = pathname.match(/trade\/(?<market>[^/]+)\//);
          if (genericMarketMatch) {
            marketKey = genericMarketMatch.groups.market;
          }
        }
      }
      return ((_a2 = this.marketsStore.getVisibleMarket(marketKey)) == null ? void 0 : _a2.key) ?? marketConstants.DEFAULT_MARKET_KEY;
    },
    onPopState() {
      const newMarket = this.getCurrentMarketCandidate();
      if (newMarket && this.activeMarketStore.activeMarket.key !== newMarket) {
        this.setActiveMarket(newMarket, true);
      }
    },
    titleUpdater(trades) {
      var _a2;
      if (!trades || !this.activeMarket) {
        return;
      }
      const price = ((_a2 = trades[0]) == null ? void 0 : _a2.price) ?? this.tradeviewTickersStore.activeMarketTickerLastValue;
      const counterSymbol = this.currenciesStore.getCurrency(this.activeMarket.counter).symbol;
      const formattedPrice = numberFormatter.price({
        value: price,
        decimals: this.activeMarket.decimals.counter,
        currencySymbol: counterSymbol
      });
      const demoPrefix = CONSTANTS.demoMode ? "DEMO | " : "";
      document.title = `${demoPrefix}${formattedPrice} ${this.activeMarket.name} - Bitstamp – Buy and sell Bitcoin and Ethereum`;
    },
    initState() {
      var _a2;
      this.activeMarketStore.setActiveMarket(this.getCurrentMarketCandidate());
      this.userStateStore.startPolling();
      const prefill = { ...((_a2 = this._.provides[PageRouteSymbol] || this.$route) == null ? void 0 : _a2.query) ?? {} };
      this.tradeviewOrderFormStore.setPrefill(prefill);
      this.pollingStore.startPolling({
        id: constants.TIMERS.POLLING_MARKETS.ID,
        interval: constants.TIMERS.POLLING_MARKETS.TIME,
        fn: () => {
          this.marketsStore.fetchMarkets();
        }
      });
      if (this.activeMarketStore.activeMarket) {
        this.conversionPathStore.loadUsdConversionPath(this.activeMarketStore.activeMarket.counter);
      }
      this.feeScheduleStore.fetch().then(this.feeScheduleStore.startPolling);
      this.balancesStore.fetch().then(this.balancesStore.startPolling);
    },
    updateLayout() {
      this.clientWidth = document.documentElement.clientWidth;
    },
    setIosMaximumScale() {
      if (isIos()) {
        const metaViewport = document.querySelector("[name=viewport]");
        const attributes = metaViewport.getAttribute("content");
        if (attributes) {
          metaViewport.setAttribute("content", `${attributes}, maximum-scale=1`);
        }
      }
    }
  }
};
const _hoisted_1 = {
  key: 0,
  id: "app",
  "data-test": "app"
};
const _hoisted_2 = { class: "grid" };
const _hoisted_3 = { class: "modal-portal" };
const _hoisted_4 = { class: "footer" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MobileAppPrompt = resolveComponent("MobileAppPrompt");
  const _component_MobileHeader = resolveComponent("MobileHeader");
  const _component_TradeviewHeader = __nuxt_component_0;
  const _component_TradingviewContainer = resolveComponent("TradingviewContainer");
  const _component_MarketActivity = resolveComponent("MarketActivity");
  const _component_TradeBook = resolveComponent("TradeBook");
  const _component_PastPerformanceDisclaimer = resolveComponent("PastPerformanceDisclaimer");
  const _component_TradeviewProductAffiliation = resolveComponent("TradeviewProductAffiliation");
  const _component_AccountMarketTypeSwitcher = resolveComponent("AccountMarketTypeSwitcher");
  const _component_CreateOrder = resolveComponent("CreateOrder");
  const _component_AppScrollbar = resolveComponent("AppScrollbar");
  const _component_TradeActivity = resolveComponent("TradeActivity");
  const _component_ToastsAndLiquidationAlerts = resolveComponent("ToastsAndLiquidationAlerts");
  const _component_portal_target = resolveComponent("portal-target");
  const _component_DerivativesEntityDisclaimerModal = resolveComponent("DerivativesEntityDisclaimerModal");
  const _component_SystemStatus = resolveComponent("SystemStatus");
  const _component_QuickView = resolveComponent("QuickView");
  return _ctx.activeMarketStore.activeMarket ? (openBlock(), createElementBlock("div", _hoisted_1, [
    $data.isAndroid && _ctx.defer(8) && !$data.isDemoMode ? (openBlock(), createBlock(_component_MobileAppPrompt, {
      key: 0,
      url: $data.playStore
    }, null, 8, ["url"])) : createCommentVNode("", true),
    _cache[7] || (_cache[7] = createTextVNode()),
    $options.isMobileScreen ? (openBlock(), createBlock(_component_MobileHeader, { key: 1 })) : (openBlock(), createBlock(_component_TradeviewHeader, { key: 2 })),
    _cache[8] || (_cache[8] = createTextVNode()),
    createBaseVNode("div", _hoisted_2, [
      createBaseVNode("div", {
        class: normalizeClass(["charting", { "charting--full-screen": $options.isChartInFullScreenMode }])
      }, [
        _ctx.marketsStore.initialized ? (openBlock(), createBlock(_component_TradingviewContainer, {
          key: `loggedIn-${_ctx.userStateStore.isLoggedIn}`,
          class: "widget"
        })) : createCommentVNode("", true)
      ], 2),
      _cache[3] || (_cache[3] = createTextVNode()),
      !$options.isSmallScreen && !$options.isChartInFullScreenMode ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["market-activity", { "market-activity--perpetual": _ctx.activeMarketStore.isPerpetual }])
      }, [
        createVNode(_component_MarketActivity, {
          class: "widget market-activity__order-book",
          "show-trades": !$options.displaySeparateTrades
        }, null, 8, ["show-trades"]),
        _cache[1] || (_cache[1] = createTextVNode()),
        $options.displaySeparateTrades ? (openBlock(), createBlock(_component_TradeBook, {
          key: 0,
          class: "widget market-activity__trades"
        })) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true),
      _cache[4] || (_cache[4] = createTextVNode()),
      createVNode(_component_AppScrollbar, {
        class: "order-form",
        "always-visible": ""
      }, {
        default: withCtx(() => [
          _ctx.$isExtraLarge ? (openBlock(), createBlock(_component_PastPerformanceDisclaimer, {
            key: 0,
            class: "order-form__past-performance-disclaimer",
            pro: ""
          })) : createCommentVNode("", true),
          _cache[2] || (_cache[2] = createTextVNode()),
          $options.isProductAffiliationFlowVisible ? (openBlock(), createBlock(_component_TradeviewProductAffiliation, { key: 1 })) : $options.activeMarketTypeUnsupported ? (openBlock(), createBlock(_component_AccountMarketTypeSwitcher, { key: 2 })) : !_ctx.userStateStore.isLoggedIn || _ctx.balancesStore.initialized ? (openBlock(), createBlock(_component_CreateOrder, { key: 3 })) : createCommentVNode("", true)
        ]),
        _: 1
      }),
      _cache[5] || (_cache[5] = createTextVNode()),
      !$options.isChartInFullScreenMode ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["trade-activity", {
          "trade-activity--perpetual": _ctx.activeMarketStore.isPerpetual,
          "trade-activity--shake": $data.isTradeActivityShaking
        }]),
        onAnimationend: _cache[0] || (_cache[0] = (...args) => $options.tradeActivityAnimationEnded && $options.tradeActivityAnimationEnded(...args))
      }, [
        createVNode(_component_TradeActivity, {
          "initial-active-widget": $data.activeTradeActivityTab,
          onChange: $options.onActiveTradeActivityTabChange
        }, null, 8, ["initial-active-widget", "onChange"])
      ], 34)) : createCommentVNode("", true)
    ]),
    _cache[9] || (_cache[9] = createTextVNode()),
    createVNode(_component_ToastsAndLiquidationAlerts, {
      tradeview: "",
      onAction: $options.onLiquidationAlertAction
    }, null, 8, ["onAction"]),
    _cache[10] || (_cache[10] = createTextVNode()),
    createBaseVNode("div", _hoisted_3, [
      createVNode(_component_portal_target, {
        name: "modal",
        multiple: ""
      })
    ]),
    _cache[11] || (_cache[11] = createTextVNode()),
    _ctx.activeMarketStore.isPerpetual && $options.isAuthenticated ? (openBlock(), createBlock(_component_DerivativesEntityDisclaimerModal, { key: 3 })) : createCommentVNode("", true),
    _cache[12] || (_cache[12] = createTextVNode()),
    createBaseVNode("footer", _hoisted_4, [
      createVNode(_component_SystemStatus, { class: "footer__system-status" }),
      _cache[6] || (_cache[6] = createTextVNode()),
      createVNode(_component_QuickView)
    ])
  ])) : createCommentVNode("", true);
}
const index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-8f3fb5f1"]]);
export {
  index as default
};
